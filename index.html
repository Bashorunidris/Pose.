<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pose - African Creator Platform</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        /* ====== CSS Variables for Theme ====== */
        :root {
            --primary: #4C1D95;
            --primary-light: #6D28D9;
            --primary-dark: #3B0764;
            --bg-main: #f7f8fb;
            --bg-card: #ffffff;
            --text-primary: #111;
            --text-secondary: #666;
            --text-muted: #999;
            --border: #e5e7eb;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.07);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.1);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* ====== Reset & Base ====== */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0
        }

        html {
            scroll-behavior: smooth
        }

        html,
        body {
            height: 100%;
            overflow-x: hidden
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--bg-main);
            -webkit-font-smoothing: antialiased;
        }

        a {
            color: inherit;
            text-decoration: none;
            transition: var(--transition)
        }

        button {
            font-family: inherit;
            cursor: pointer;
            transition: var(--transition)
        }

        img {
            max-width: 100%;
            display: block
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: #1a1a1a;
            border-radius: var(--radius-md);
            padding: 30px;
            width: 90%;
            max-width: 400px;
            color: white;
            position: relative;
            box-shadow: var(--shadow-lg);
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }

        .modal h2 {
            margin: 0 0 20px 0;
            font-size: 24px;
        }

        .modal input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: #2a2a2a;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: white;
            font-size: 14px;
            transition: var(--transition);
        }

        .modal input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .modal-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, var(--primary), var(--primary-light));
            border: none;
            border-radius: var(--radius-sm);
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            transition: var(--transition);
        }

        .modal-btn:hover {
            opacity: 0.9;
        }

        .modal-switch {
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            color: #aaa;
        }

        .modal-switch a {
            color: var(--primary);
            cursor: pointer;
            text-decoration: none;
        }

        .error-msg {
            background: var(--primary);
            padding: 10px;
            border-radius: var(--radius-sm);
            margin-bottom: 15px;
            font-size: 14px;
            box-shadow: var(--shadow-sm);
        }

        /* ====== UPLOAD PROGRESS CONTAINER ====== */
        .upload-progress-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            background: #1a1a1a;
            border: 1px solid #4C1D95;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 2500;
            display: none;
            flex-direction: column;
            max-height: 500px;
        }

        .upload-progress-container.active {
            display: flex;
        }

        .upload-progress-header {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 15px;
            background: linear-gradient(135deg, #4C1D95, #6D28D9);
            border-radius: 12px 12px 0 0;
            user-select: none;
        }

        .upload-progress-header h3 {
            font-size: 14px;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .upload-progress-body {
            padding: 15px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 400px;
        }

        .upload-progress-container.collapsed .upload-progress-body {
            display: none;
        }

        /* Step Item */
        .upload-step {
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        .step-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .step-icon.pending {
            background: #333;
            color: #888;
        }

        .step-icon.active {
            background: #4C1D95;
            color: white;
            animation: pulse 1s infinite;
        }

        .step-icon.completed {
            background: #22c55e;
            color: white;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Spinner Animation */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .fa-spin {
            animation: spin 1s linear infinite;
        }

        .step-content {
            flex: 1;
        }

        .step-label {
            font-size: 13px;
            font-weight: 600;
            color: white;
            margin-bottom: 4px;
        }

        .step-progress {
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
        }

        .step-bar {
            width: 100%;
            height: 4px;
            background: #222;
            border-radius: 2px;
            overflow: hidden;
            display: none;
        }

        .step-bar.active {
            display: block;
        }

        .step-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4C1D95, #6D28D9);
            width: 0%;
            transition: width 0.3s;
        }

        /* Overall Progress */
        .overall-progress {
            border-top: 1px solid #333;
            padding-top: 12px;
            margin-top: 8px;
        }

        .overall-bar {
            width: 100%;
            height: 6px;
            background: #222;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .overall-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4C1D95, #22c55e);
            width: 0%;
            transition: width 0.3s;
        }

        .overall-stats {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #888;
        }

        /* ====== SUCCESS/ERROR MESSAGE MODAL - RESPONSIVE ====== */
        .upload-result-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            animation: fadeIn 0.3s ease;
        }

        .upload-result-modal.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                backdrop-filter: blur(0px);
            }

            to {
                opacity: 1;
                backdrop-filter: blur(5px);
            }
        }

        .upload-result-content {
            background: linear-gradient(135deg, #1a1a1a, #2d1b4e);
            border-radius: 24px;
            padding: 30px;
            max-width: 320px;
            width: 90%;
            text-align: center;
            box-shadow: 0 25px 60px rgba(76, 29, 149, 0.3);
            border: 1px solid rgba(76, 29, 149, 0.5);
            animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .upload-result-thumbnail {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            margin: 0 auto 20px;
            background: linear-gradient(135deg, #4C1D95, #6D28D9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(76, 29, 149, 0.4);
            animation: popIn 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes popIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .upload-result-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .upload-result-title {
            font-size: 22px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 10px;
            letter-spacing: -0.5px;
        }

        .upload-result-message {
            font-size: 14px;
            color: #bbb;
            margin-bottom: 20px;
            line-height: 1.6;
            font-weight: 400;
        }

        .upload-result-message.success {
            color: #86efac;
            font-weight: 500;
        }

        .upload-result-message.error {
            color: #fca5a5;
            font-weight: 500;
        }

        .upload-result-btn {
            width: 100%;
            background: linear-gradient(135deg, #ff0050, #ff4081);
            color: white;
            border: none;
            padding: 14px 20px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(255, 0, 80, 0.3);
        }

        .upload-result-btn:hover {
            background: linear-gradient(135deg, #ff1a66, #ff5fa0);
            box-shadow: 0 6px 25px rgba(255, 0, 80, 0.5);
            transform: translateY(-2px);
        }

        .upload-result-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(255, 0, 80, 0.3);
        }

        /* Countdown Progress Bar */
        .upload-result-countdown {
            margin: 20px 0 15px 0;
            text-align: center;
            animation: fadeIn 0.5s ease 0.3s both;
        }

        .upload-result-countdown-text {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .countdown-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid rgba(76, 29, 149, 0.3);
        }

        .countdown-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4C1D95, #ff0050);
            width: 100%;
            transition: width 0.1s linear;
            border-radius: 2px;
        }

        .countdown-time {
            font-size: 24px;
            font-weight: 700;
            color: #ff0050;
            margin-top: 10px;
            font-variant-numeric: tabular-nums;
        }

        /* ====== RESPONSIVE MODAL ====== */

        /* Tablet */
        @media (max-width: 768px) {
            .upload-result-content {
                padding: 25px;
                max-width: 300px;
                border-radius: 20px;
            }

            .upload-result-thumbnail {
                width: 90px;
                height: 90px;
                font-size: 44px;
                margin-bottom: 18px;
            }

            .upload-result-title {
                font-size: 20px;
                margin-bottom: 8px;
            }

            .upload-result-message {
                font-size: 13px;
                margin-bottom: 18px;
            }

            .upload-result-btn {
                padding: 12px 18px;
                font-size: 14px;
            }

            .upload-result-countdown {
                margin: 18px 0 12px 0;
            }

            .countdown-time {
                font-size: 22px;
                margin-top: 8px;
            }
        }

        /* Mobile */
        @media (max-width: 480px) {
            .upload-result-modal {
                padding: 20px;
            }

            .upload-result-content {
                padding: 20px;
                max-width: 100%;
                width: 95%;
                border-radius: 16px;
            }

            .upload-result-thumbnail {
                width: 80px;
                height: 80px;
                font-size: 40px;
                margin-bottom: 15px;
            }

            .upload-result-title {
                font-size: 18px;
                margin-bottom: 8px;
            }

            .upload-result-message {
                font-size: 12px;
                margin-bottom: 15px;
                line-height: 1.5;
            }

            .upload-result-btn {
                padding: 11px 16px;
                font-size: 13px;
                border-radius: 10px;
            }

            .upload-result-countdown-text {
                font-size: 11px;
            }

            .countdown-bar {
                height: 5px;
            }

            .countdown-time {
                font-size: 20px;
                margin-top: 6px;
            }
        }

        /* ====== NOTIFICATIONS PAGE ====== */
        .notifications-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-main);
            z-index: 1999;
            display: none;
            flex-direction: column;
            animation: slideUp 0.3s ease;
        }

        .notifications-overlay.active {
            display: flex;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100%);
            }

            to {
                transform: translateY(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }

        /* ====== UPLOAD PROGRESS MODAL ====== */
        .upload-progress-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            animation: fadeIn 0.3s ease;
        }

        .upload-progress-modal.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .upload-progress-content {
            background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
            border-radius: 16px;
            padding: 40px;
            width: 90%;
            max-width: 380px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(76, 29, 149, 0.3), 0 0 40px rgba(76, 29, 149, 0.1);
            border: 1px solid #333;
            position: relative;
        }

        .upload-progress-icon {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4C1D95, #6D28D9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            margin: 0 auto 20px;
            animation: slideUp 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .upload-progress-icon.uploading {
            animation: pulse 2s infinite;
        }

        .upload-progress-title {
            font-size: 20px;
            font-weight: bold;
            color: white;
            margin-bottom: 10px;
        }

        .upload-progress-subtitle {
            font-size: 13px;
            color: #888;
            margin-bottom: 25px;
        }

        .upload-progress-bar-container {
            width: 100%;
            height: 8px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 12px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .upload-progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4C1D95, #6D28D9, #22c55e);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(76, 29, 149, 0.5);
        }

        .upload-progress-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 20px;
        }

        .upload-stat {
            background: rgba(76, 29, 149, 0.1);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(76, 29, 149, 0.2);
        }

        .upload-stat-label {
            font-size: 11px;
            color: #999;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .upload-stat-value {
            font-size: 16px;
            font-weight: 700;
            color: #fff;
        }

        .upload-progress-text {
            font-size: 12px;
            color: #666;
            margin-top: 15px;
            font-style: italic;
        }

        .upload-progress-success {
            animation: scaleIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.5);
            }

            to {
                transform: scale(1);
            }
        }

        .notifications-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .notifications-header h2 {
            font-size: 20px;
            font-weight: 700;
            margin: 0;
        }

        .notifications-close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-primary);
            padding: 4px 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notifications-container {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .notification-item {
            display: flex;
            gap: 12px;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: var(--transition);
            background: var(--bg-card);
        }

        .notification-item:hover {
            background: #f9fafb;
        }

        .notification-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--primary-light));
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            object-fit: cover;
        }

        .notification-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }

        .notification-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .notification-title {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
        }

        .notification-message {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .notification-time {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .notification-badge {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ef4444;
            flex-shrink: 0;
            margin-top: 8px;
        }

        .notifications-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            gap: 12px;
            color: var(--text-muted);
            padding: 40px 20px;
        }

        .notifications-empty-icon {
            font-size: 48px;
            opacity: 0.5;
        }

        .notifications-empty-text {
            font-size: 16px;
            font-weight: 500;
        }

        /* ====== RECORDING UI OVERLAY ====== */
        .recording-ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            z-index: 1998;
            display: none;
            flex-direction: column;
            animation: slideUpRecording 0.3s ease;
        }

        .recording-ui-overlay.active {
            display: flex;
        }

        @keyframes slideUpRecording {
            from {
                transform: translateY(100%);
            }

            to {
                transform: translateY(0);
            }
        }

        /* Main Recording Screen Container */
        .recording-screen {
            display: none;
            width: 100%;
            height: 100vh;
            position: relative;
            flex-direction: column;
        }

        .recording-screen.active {
            display: flex;
        }

        /* Camera Preview - Fully Responsive */
        .camera-preview {
            flex: 1;
            background: #000;
            position: relative;
            display: block;
            font-size: 24px;
            color: rgba(255, 255, 255, 0.5);
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            /* Performance optimizations */
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transform: translate3d(0, 0, 0) scaleX(-1);
            /* Ensure fills container */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Video element - Live streaming */
        video#videoPreview {
            display: block !important;
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #000;
            /* Performance optimizations */
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transform: translate3d(0, 0, 0) scaleX(-1);
            -webkit-transform: scaleX(-1);
        }

        /* Ensure video fills entire screen */
        @supports (object-fit: cover) {
            video#videoPreview {
                object-fit: cover;
            }
        }

        /* Edit video container - takes flex space */
        .edit-video-container {
            position: relative;
            flex: 1;
            width: 100%;
            background: #000;
            overflow: hidden;
        }

        /* Edit screen video wrapper and preview */
        .edit-video-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #editVideoPreview {
            display: block !important;
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #000;
        }

        /* Video Controls - Always visible like TikTok */
        .edit-video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
            padding: 16px 15px 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            opacity: 1;
            transition: opacity 0.3s ease;
            z-index: 10;
            pointer-events: all;
        }

        .edit-video-controls.visible {
            opacity: 1;
            pointer-events: all;
        }

        .edit-video-wrapper:hover .edit-video-controls {
            opacity: 1;
            pointer-events: all;
        }

        .edit-video-controls:hover {
            opacity: 1;
            pointer-events: all;
        }

        /* Large center play button for tap-to-play */
        .video-center-play {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 0, 80, 0.9);
            border: none;
            color: white;
            font-size: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9;
            transition: all 0.2s ease;
            box-shadow: 0 4px 20px rgba(255, 0, 80, 0.4);
        }

        .video-center-play:hover {
            background: rgba(255, 0, 80, 1);
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 6px 25px rgba(255, 0, 80, 0.6);
        }

        .video-center-play:active {
            transform: translate(-50%, -50%) scale(0.95);
        }

        .video-center-play.hidden {
            display: none;
        }

        /* Progress Bar */
        .video-progress-bar {
            position: relative;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            cursor: pointer;
            overflow: hidden;
        }

        .video-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0050, #ff4081);
            width: 0%;
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        .video-progress-slider {
            position: absolute;
            top: -8px;
            left: 0;
            width: 100%;
            height: 20px;
            cursor: pointer;
            opacity: 0;
            z-index: 5;
        }

        .video-progress-slider::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff0050;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(255, 0, 80, 0.5);
        }

        .video-progress-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff0050;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(255, 0, 80, 0.5);
        }

        /* Bottom Controls */
        .video-controls-bottom {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .video-play-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .video-play-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .video-play-btn:active {
            transform: scale(0.92);
        }

        /* Time Display */
        .video-time-display {
            display: flex;
            align-items: center;
            gap: 4px;
            color: #fff;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            font-weight: 500;
            flex: 1;
            padding: 0 8px;
        }

        .time-separator {
            opacity: 0.6;
            margin: 0 2px;
        }

        /* Fullscreen Button */
        .video-fullscreen-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .video-fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .video-fullscreen-btn:active {
            transform: scale(0.92);
        }

        /* Video controls responsive */
        video::-webkit-media-controls {
            max-height: 50px;
        }

        /* Responsive Video Controls */
        @media (max-width: 768px) {
            .edit-video-controls {
                padding: 12px 10px 10px;
                gap: 8px;
                opacity: 1;
                pointer-events: all;
            }

            .video-center-play {
                width: 70px;
                height: 70px;
                font-size: 32px;
                box-shadow: 0 4px 15px rgba(255, 0, 80, 0.3);
            }

            .video-progress-bar {
                height: 6px;
                cursor: pointer;
            }

            .video-progress-slider {
                height: 30px;
                top: -12px;
            }

            .video-play-btn,
            .video-fullscreen-btn {
                width: 44px;
                height: 44px;
                font-size: 16px;
            }

            .video-time-display {
                font-size: 13px;
                padding: 0 12px;
            }
        }

        @media (max-width: 480px) {
            .edit-video-controls {
                padding: 10px 8px 8px;
                gap: 8px;
                opacity: 1;
                pointer-events: all;
            }

            .video-center-play {
                width: 72px;
                height: 72px;
                font-size: 36px;
                box-shadow: 0 4px 18px rgba(255, 0, 80, 0.4);
            }

            .video-progress-bar {
                height: 8px;
                cursor: pointer;
            }

            .video-progress-slider {
                height: 40px;
                top: -16px;
            }

            .video-play-btn,
            .video-fullscreen-btn {
                width: 48px;
                height: 48px;
                font-size: 18px;
            }

            .video-time-display {
                font-size: 12px;
                gap: 3px;
                padding: 0 10px;
            }

            .video-progress-slider::-webkit-slider-thumb {
                width: 16px;
                height: 16px;
            }

            .video-progress-slider::-moz-range-thumb {
                width: 16px;
                height: 16px;
            }
        }

        /* Mobile video responsive */
        @media (max-width: 768px) {
            video#videoPreview {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }
        }

        @media (max-width: 480px) {
            video#videoPreview {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }
        }

        /* Ensure recording video element is visible */
        #recordingVideoPreview {
            display: block !important;
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #000;
            transform: scaleX(-1);
        }

        .camera-error-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(76, 29, 149, 0.3), rgba(109, 40, 217, 0.3));
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5;
        }

        .recording-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 4;
            pointer-events: none;
        }

        .recording-overlay>div:first-child {
            animation: recordingPulse 1s infinite;
        }

        @keyframes recordingPulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.7;
            }
        }

        .edit-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 6;
        }

        .edit-loading-overlay>div {
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* Ratio Guide Frame - Shows what will be captured */
        .ratio-guide-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 3px solid rgba(76, 29, 149, 0.7);
            border-radius: 8px;
            background: transparent;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.35);
            pointer-events: none;
            z-index: 8;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.85;
        }

        /* Corner indicators for professional look */
        .ratio-guide-frame::before,
        .ratio-guide-frame::after {
            content: '';
            position: absolute;
            background: rgba(76, 29, 149, 0.8);
        }

        .ratio-guide-frame::before {
            width: 40px;
            height: 3px;
            top: -15px;
            left: -15px;
        }

        /* Top Bar - Responsive */
        .rec-top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 16px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 10;
            gap: 10px;
        }

        .rec-icon-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            flex-shrink: 0;
        }

        .rec-icon-btn:hover {
            background: rgba(0, 0, 0, 0.6);
            border-color: rgba(76, 29, 149, 0.6);
        }

        .rec-icon-btn:active {
            transform: scale(0.88);
        }

        /* Left Side Menu - Responsive */
        .rec-left-menu {
            position: absolute;
            left: 16px;
            top: 70px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            opacity: 0;
            pointer-events: none;
            transform: translateY(-15px) scale(0.9);
            transition: opacity 0.25s ease, transform 0.25s ease;
            z-index: 999;
            min-width: 160px;
            width: max-content;
            max-width: 200px;
        }

        .rec-left-menu.show {
            opacity: 1;
            pointer-events: all;
            transform: translateY(0) scale(1);
        }

        .rec-menu-item {
            padding: 11px 18px;
            background: rgba(0, 0, 0, 0.75);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(76, 29, 149, 0.4);
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            white-space: nowrap;
            color: #fff;
            text-align: left;
            width: 100%;
            box-sizing: border-box;
        }

        .rec-menu-item:hover {
            background: rgba(0, 0, 0, 0.8);
            border-color: rgba(76, 29, 149, 0.6);
            transform: translateX(4px);
        }

        .rec-menu-item:active {
            transform: scale(0.93);
        }

        /* Responsive Top Bar */
        @media (max-width: 768px) {
            .rec-top-bar {
                padding: 12px;
            }

            .rec-icon-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .rec-left-menu {
                left: 12px;
                top: 65px;
                gap: 8px;
                min-width: 150px;
                max-width: 180px;
            }

            .rec-menu-item {
                padding: 9px 14px;
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            .rec-top-bar {
                padding: 10px;
            }

            .rec-icon-btn {
                width: 36px;
                height: 36px;
                font-size: 14px;
            }

            .rec-left-menu {
                left: 8px;
                top: 60px;
                gap: 6px;
                min-width: 140px;
                max-width: 160px;
            }

            .rec-menu-item {
                padding: 8px 12px;
                font-size: 11px;
                white-space: normal;
            }
        }

        /* Quick Stats Bar */
        .rec-stats-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            z-index: 9;
            font-size: 13px;
            color: #fff;
            font-weight: 600;
        }

        .rec-stats-bar span {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Right Side Effects */
        .rec-effects-bar {
            position: absolute;
            right: 20px;
            top: 80px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 9;
        }

        .rec-effect-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .rec-effect-icon:active {
            transform: scale(0.9);
        }

        /* Effect Filters */
        .camera-preview.effect-sparkle {
            filter: brightness(1.2) contrast(1.1);
        }

        .camera-preview.effect-mask {
            filter: saturate(1.5) hue-rotate(15deg);
        }

        .camera-preview.effect-ghost {
            filter: opacity(0.8) blur(2px) brightness(1.1);
        }

        .camera-preview.effect-star {
            filter: saturate(1.8) brightness(1.15) contrast(1.2);
        }

        /* Bottom Controls */
        .rec-bottom-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 30px 20px 40px 20px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.95), rgba(0, 0, 0, 0.7) 50%, transparent);
        }

        .rec-control-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 50px;
            margin-bottom: 30px;
            width: 100%;
        }

        .rec-control-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            background: none;
            border: none;
            color: #fff;
        }

        .rec-control-btn:hover .rec-control-icon {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
        }

        .rec-control-btn:active {
            transform: scale(0.92);
        }

        .rec-control-icon {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.12);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .rec-control-label {
            font-size: 13px;
            opacity: 0.85;
            font-weight: 500;
            letter-spacing: 0.3px;
        }

        /* Record Button */
        .rec-record-btn-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
            padding: 20px 0;
            gap: 20px;
            position: relative;
        }

        /* Recording Status Bar */
        .rec-recording-status {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 80, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 12px 20px;
            animation: slideDown 0.3s ease;
            z-index: 10;
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-20px);
                opacity: 0;
            }

            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        .rec-status-content {
            display: flex;
            align-items: center;
            gap: 15px;
            color: white;
            font-weight: 600;
        }

        .rec-recording-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rec-record-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #fff;
            animation: blink-dot 1s ease-in-out infinite;
        }

        @keyframes blink-dot {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        .rec-status-text {
            font-size: 13px;
            letter-spacing: 0.5px;
        }

        .rec-status-indicator {
            font-size: 18px;
            animation: pulse-indicator 1s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 20px;
        }

        @keyframes pulse-indicator {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.6;
                transform: scale(1.1);
            }
        }

        .rec-timer-display {
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 1px;
            font-family: 'Courier New', monospace;
            min-width: 50px;
            text-align: right;
        }

        /* Button Container */
        .rec-btn-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .rec-record-btn {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            border: 4px solid #fff;
            background: linear-gradient(135deg, #ff0050 0%, #ff4478 100%);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            box-shadow: 0 10px 30px rgba(255, 0, 80, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rec-btn-inner {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .rec-btn-circle {
            width: 40px;
            height: 40px;
            background: #fff;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .rec-record-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(255, 0, 80, 0.8);
        }

        .rec-record-btn:hover .rec-btn-circle {
            transform: scale(1.15);
        }

        .rec-record-btn:active {
            transform: scale(0.95);
        }

        .rec-record-btn.recording {
            animation: pulse-recording 0.8s ease-in-out infinite;
        }

        .rec-record-btn.recording .rec-btn-circle {
            width: 28px;
            height: 28px;
            border-radius: 3px;
            background: #ff0050;
        }

        @keyframes pulse-recording {

            0%,
            100% {
                box-shadow: 0 10px 30px rgba(255, 0, 80, 0.6);
            }

            50% {
                box-shadow: 0 15px 50px rgba(255, 0, 80, 0.9);
            }
        }

        /* Button Label */
        .rec-btn-label {
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            opacity: 0.8;
            transition: all 0.3s ease;
        }

        .rec-record-btn.recording~.rec-btn-label {
            opacity: 0.5;
        }

        /* Recording Controls */
        .rec-recording-controls {
            display: flex;
            gap: 15px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .rec-control-action-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: #fff;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rec-control-action-btn:hover {
            transform: scale(1.1);
        }

        .rec-control-action-btn:active {
            transform: scale(0.95);
        }

        .rec-control-pause-btn {
            background: rgba(100, 150, 255, 0.3);
        }

        .rec-control-pause-btn:hover {
            background: rgba(100, 150, 255, 0.5);
            border-color: rgba(150, 200, 255, 0.8);
        }

        .rec-control-stop-btn {
            background: rgba(255, 100, 100, 0.3);
        }

        .rec-control-stop-btn:hover {
            background: rgba(255, 100, 100, 0.5);
            border-color: rgba(255, 150, 150, 0.8);
        }

        /* Quality Badge */
        .rec-quality-badge {
            position: absolute;
            bottom: -10px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            padding: 6px 12px;
            font-size: 11px;
            color: #fff;
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .rec-quality-icon {
            font-size: 12px;
        }

        .rec-quality-text {
            letter-spacing: 0.5px;
        }

        /* Sound Display on Screen 1 */
        .rec-sound-display {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 320px;
            background: linear-gradient(135deg, rgba(76, 29, 149, 0.9), rgba(109, 40, 217, 0.9));
            border: 1px solid rgba(100, 200, 255, 0.5);
            border-radius: 12px;
            padding: 10px 12px;
            box-shadow: 0 4px 20px rgba(76, 29, 149, 0.4);
            z-index: 50;
            animation: slideDown 0.4s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .rec-sound-display-content {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .rec-sound-thumbnail {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #fff;
            flex-shrink: 0;
            overflow: hidden;
        }

        .rec-sound-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .rec-sound-info {
            flex: 1;
            min-width: 0;
        }

        .rec-sound-title {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .rec-sound-artist {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .rec-sound-remove {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(255, 100, 100, 0.2);
            border: 1px solid rgba(255, 100, 100, 0.5);
            color: #ff6464;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.3s ease;
        }

        .rec-sound-remove:hover {
            background: rgba(255, 100, 100, 0.4);
            border-color: rgba(255, 100, 100, 0.8);
            transform: scale(1.1);
        }

        /* Mode Tabs */
        .rec-mode-tabs {
            display: flex;
            justify-content: center;
            gap: 35px;
            padding: 15px 10px 10px 10px;
            position: relative;
        }

        .rec-mode-tab {
            font-size: 16px;
            opacity: 0.4;
            cursor: pointer;
            transition: all 0.3s ease;
            background: none;
            border: none;
            color: #fff;
            font-weight: 600;
            position: relative;
            padding: 8px 15px;
        }

        .rec-mode-tab:hover:not(.active) {
            opacity: 0.7;
        }

        .rec-mode-tab:active {
            transform: scale(0.95);
        }

        .rec-mode-tab.active {
            opacity: 1;
            font-size: 20px;
            color: #fff;
            text-shadow: 0 2px 8px rgba(255, 255, 255, 0.3);
        }

        .rec-mode-tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 4px;
            background: #fff;
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* Photo Mode Controls */
        .photo-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .photo-control-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 30px;
            width: 100%;
        }

        .photo-control-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            transition: all 0.3s;
            background: none;
            border: 2px solid transparent;
            color: #fff;
            border-radius: 8px;
            padding: 8px;
        }

        .photo-control-btn:active {
            transform: scale(0.9);
        }

        .photo-control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .photo-record-btn-wrapper {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }

        .photo-record-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 5px solid #fff;
            background: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .photo-record-btn:active {
            transform: scale(0.92);
        }

        /* Photo Filters Panel - Vertical on Right, Responsive */
        .photo-filters-panel {
            position: absolute;
            right: 20px;
            top: 50px;
            width: 85px;
            height: auto;
            max-height: calc(100vh - 150px);
            border-radius: 20px;
            padding: 0;
            z-index: 99;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(20, 20, 20, 0.92);
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: none;
            transition: all 0.3s ease;
        }

        .photo-filters-panel.show {
            display: block;
        }

        .photo-filters-panel.collapsed {
            width: auto;
        }

        .photo-filters-panel.collapsed .photo-filters-scroll {
            display: none;
        }

        .photo-filters-header {
            display: flex;
            padding: 10px 16px;
            background: rgba(76, 29, 149, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            user-select: none;
            align-items: center;
            justify-content: space-between;
            font-size: 13px;
            color: white;
            font-weight: 600;
            transition: background 0.3s ease;
            width: 100%;
            gap: 8px;
        }

        .photo-filters-header:hover {
            background: rgba(76, 29, 149, 0.5);
        }

        .toggle-icon {
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
        }

        .photo-filters-panel.collapsed .toggle-icon {
            transform: rotate(180deg);
        }

        .photo-filters-scroll {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px 6px;
            align-items: center;
            scroll-behavior: smooth;
            transition: all 0.3s ease;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .photo-filters-panel {
                right: 12px;
                top: 48px;
                width: 75px;
                padding: 8px 5px;
            }

            .photo-filters-scroll {
                gap: 8px;
            }
        }

        @media (max-width: 480px) {
            .photo-filters-panel {
                right: 10px;
                top: 45px;
                width: 65px;
                padding: 6px 4px;
            }

            .photo-filters-scroll {
                gap: 6px;
            }
        }

        .photo-filters-scroll::-webkit-scrollbar {
            width: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
        }

        .photo-filters-scroll::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
        }

        .photo-filters-scroll::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            transition: background 0.3s;
        }

        .photo-filters-scroll::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        /* Bottom Photo Filters Panel */
        .photo-filters-bottom-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            background: rgba(20, 20, 20, 0.98);
            backdrop-filter: blur(15px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.5);
            transform: translateY(100%);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .photo-filters-bottom-panel.open {
            transform: translateY(0);
        }

        .photo-filters-toggle-header {
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(76, 29, 149, 0.4), rgba(109, 40, 217, 0.2));
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            color: white;
            font-weight: 600;
            transition: background 0.3s ease;
        }

        .photo-filters-toggle-header:hover {
            background: linear-gradient(135deg, rgba(76, 29, 149, 0.6), rgba(109, 40, 217, 0.4));
        }

        .toggle-arrow {
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
        }

        .photo-filters-bottom-panel.open .toggle-arrow {
            transform: rotate(180deg);
        }

        .photo-filters-bottom-content {
            overflow-y: auto;
            padding: 12px;
            flex: 1;
        }

        .photo-filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: 12px;
            width: 100%;
        }

        .photo-filter-btn-bottom {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .photo-filter-btn-bottom:hover {
            background: rgba(76, 29, 149, 0.3);
            border-color: rgba(76, 29, 149, 0.5);
            transform: scale(1.05);
        }

        .photo-filter-btn-bottom.active {
            background: linear-gradient(135deg, #4C1D95, #6D28D9);
            border-color: #6D28D9;
            box-shadow: 0 4px 12px rgba(76, 29, 149, 0.4);
        }

        .photo-filters-bottom-content::-webkit-scrollbar {
            width: 4px;
        }

        .photo-filters-bottom-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
        }

        .photo-filters-bottom-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        .photo-filters-bottom-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .photo-filters-grid {
                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
                gap: 10px;
            }

            .photo-filters-toggle-header {
                padding: 10px 12px;
                font-size: 13px;
            }
        }

        .photo-filter-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            background: none;
            border: 1.5px solid transparent;
            cursor: pointer;
            padding: 6px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: #fff;
            font-size: 9px;
            border-radius: 10px;
            flex-shrink: 0;
            min-width: fit-content;
            position: relative;
        }

        .photo-filter-btn:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.08);
        }

        .photo-filter-btn:active {
            transform: scale(0.92);
        }

        .photo-filter-btn.active {
            border-color: #4C1D95;
            background: rgba(76, 29, 149, 0.3);
            box-shadow: 0 0 12px rgba(76, 29, 149, 0.5), inset 0 0 8px rgba(76, 29, 149, 0.2);
        }

        .photo-filter-btn.active .photo-filter-preview {
            border-color: #4C1D95;
            box-shadow: 0 0 15px rgba(76, 29, 149, 0.8);
        }

        .photo-filter-preview {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 1.5px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s;
        }

        /* Mobile Responsive Button Sizes */
        @media (max-width: 768px) {
            .photo-filter-btn {
                padding: 5px;
                gap: 3px;
                font-size: 8px;
                border-radius: 9px;
            }

            .photo-filter-preview {
                width: 48px;
                height: 48px;
                border: 1.3px solid rgba(255, 255, 255, 0.3);
            }
        }

        @media (max-width: 480px) {
            .photo-filter-btn {
                padding: 4px;
                gap: 2px;
                font-size: 7px;
                border-radius: 8px;
            }

            .photo-filter-preview {
                width: 40px;
                height: 40px;
                border: 1px solid rgba(255, 255, 255, 0.3);
            }
        }

        /* Filter Preview Styles */
        .photo-filter-preview.original {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .photo-filter-preview.bw {
            background: linear-gradient(135deg, #333 0%, #666 100%);
            filter: grayscale(100%);
        }

        .photo-filter-preview.sepia {
            background: linear-gradient(135deg, #8b6f47 0%, #a0826d 100%);
            filter: sepia(100%);
        }

        .photo-filter-preview.vintage {
            background: linear-gradient(135deg, #8b7355 0%, #a08575 100%);
            filter: sepia(50%) contrast(90%) brightness(90%);
        }

        .photo-filter-preview.vivid {
            background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 100%);
            filter: saturate(150%) contrast(110%);
        }

        .photo-filter-preview.warm {
            background: linear-gradient(135deg, #ff9a56 0%, #ff6a88 100%);
            filter: brightness(110%) saturate(130%);
        }

        .photo-filter-preview.cool {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            filter: hue-rotate(-20deg) saturate(120%);
        }

        .photo-filter-btn:hover .photo-filter-preview {
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
        }

        /* ====== RECORDING FILTERS PANEL ====== */
        .rec-filters-panel {
            position: absolute;
            bottom: 250px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 420px;
            max-height: 240px;
            border-radius: 25px;
            padding: 0;
            z-index: 99;
            overflow: hidden;
            border: 1.5px solid rgba(138, 43, 226, 0.3);
            background: rgba(15, 15, 20, 0.95);
            backdrop-filter: blur(25px);
            box-shadow: 0 12px 50px rgba(0, 0, 0, 0.7), inset 0 1px 1px rgba(255, 255, 255, 0.1);
            display: none;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .rec-filters-panel.show {
            display: block;
            animation: slideUpFilter 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes slideUpFilter {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .rec-filters-scroll {
            display: flex;
            flex-direction: row;
            gap: 14px;
            width: 100%;
            max-height: 240px;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 18px;
        }

        .rec-filters-scroll::-webkit-scrollbar {
            height: 4px;
        }

        .rec-filters-scroll::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
        }

        .rec-filters-scroll::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        .rec-filters-scroll::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .rec-filter-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            background: rgba(255, 255, 255, 0.06);
            border: 1.5px solid rgba(255, 255, 255, 0.15);
            cursor: pointer;
            padding: 8px;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            color: #fff;
            font-size: 11px;
            border-radius: 14px;
            flex-shrink: 0;
            min-width: fit-content;
            position: relative;
            font-weight: 500;
        }

        .rec-filter-btn:hover {
            border-color: rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-4px);
            box-shadow: 0 8px 20px rgba(138, 43, 226, 0.2);
        }

        .rec-filter-btn:active {
            transform: scale(0.94);
        }

        .rec-filter-btn.active {
            border-color: #8A2BE2;
            background: rgba(138, 43, 226, 0.25);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.6), inset 0 0 12px rgba(138, 43, 226, 0.3);
        }

        .rec-filter-btn.active .rec-filter-preview {
            border-color: #8A2BE2;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
        }

        .rec-filter-preview {
            width: 65px;
            height: 65px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px solid rgba(255, 255, 255, 0.25);
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .rec-filter-btn:hover .rec-filter-preview {
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 6px 25px rgba(138, 43, 226, 0.4);
        }

        /* Filter Preview Styles for Recording */
        .rec-filter-preview.original {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .rec-filter-preview.bw {
            background: linear-gradient(135deg, #333 0%, #666 100%);
            filter: grayscale(100%);
        }

        .rec-filter-preview.sepia {
            background: linear-gradient(135deg, #8b6f47 0%, #a0826d 100%);
            filter: sepia(100%);
        }

        .rec-filter-preview.vintage {
            background: linear-gradient(135deg, #8b7355 0%, #a08575 100%);
            filter: sepia(50%) contrast(90%) brightness(90%);
        }

        .rec-filter-preview.vivid {
            background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 100%);
            filter: saturate(150%) contrast(110%);
        }

        .rec-filter-preview.warm {
            background: linear-gradient(135deg, #ff9a56 0%, #ff6a88 100%);
            filter: brightness(110%) saturate(130%);
        }

        .rec-filter-preview.cool {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            filter: hue-rotate(-20deg) saturate(120%);
        }

        /* ====== RECORDING EFFECTS PANEL ====== */
        .rec-effects-panel {
            position: absolute;
            bottom: 220px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 440px;
            max-height: 550px;
            border-radius: 30px;
            padding: 0;
            z-index: 99;
            overflow: hidden;
            border: 1.5px solid rgba(138, 43, 226, 0.3);
            background: rgba(15, 15, 20, 0.97);
            backdrop-filter: blur(30px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), inset 0 1px 1px rgba(255, 255, 255, 0.12);
            display: none;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .rec-effects-panel.show {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            animation: slideUpEffect 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes slideUpEffect {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .rec-effects-category {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .rec-effects-category:last-child {
            border-bottom: none;
        }

        .rec-category-title {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 600;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .rec-effects-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: rgba(76, 29, 149, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .rec-effects-close {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .rec-effects-close:hover {
            color: #ff6b6b;
            transform: scale(1.15);
        }

        /* Options Panels (Layout, Speed) */
        .rec-options-panel {
            position: absolute;
            bottom: 220px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 380px;
            border-radius: 28px;
            padding: 0;
            z-index: 99;
            overflow: hidden;
            border: 1.5px solid rgba(138, 43, 226, 0.3);
            background: rgba(15, 15, 20, 0.96);
            backdrop-filter: blur(30px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), inset 0 1px 1px rgba(255, 255, 255, 0.12);
            display: none;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .rec-options-panel.show {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            animation: slideUpOption 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes slideUpOption {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(25px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .rec-options-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            background: rgba(138, 43, 226, 0.15);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            flex-shrink: 0;
        }

        .rec-options-close {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .rec-options-close:hover {
            color: #ff6b6b;
            background: rgba(255, 100, 100, 0.15);
            border-color: rgba(255, 100, 100, 0.3);
            transform: scale(1.1);
        }

        .rec-options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(75px, 1fr));
            gap: 14px;
            padding: 18px;
        }

        .rec-option-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 12px 8px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .rec-option-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-3px);
        }

        .rec-option-btn.active {
            background: rgba(138, 43, 226, 0.5);
            border-color: rgba(138, 43, 226, 0.8);
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.6);
        }

        .rec-option-icon {
            font-size: 20px;
        }

        .rec-effects-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 14px;
            width: 100%;
            max-height: 400px;
            overflow-y: auto;
            padding: 16px;
        }

        .rec-effect-circular {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 7px;
            background: rgba(255, 255, 255, 0.08);
            border: 1.5px solid rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            aspect-ratio: 1;
            color: white;
            cursor: pointer;
            padding: 0;
            font-size: 11px;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .rec-effect-circular::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.25) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .rec-effect-circular:hover {
            background: rgba(138, 43, 226, 0.2);
            border-color: rgba(138, 43, 226, 0.4);
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 8px 25px rgba(138, 43, 226, 0.25);
        }

        .rec-effect-circular:hover::before {
            opacity: 1;
        }

        .rec-effect-circular:active {
            transform: scale(0.93);
        }

        .rec-effect-circular.active {
            background: rgba(138, 43, 226, 0.35);
            border-color: #8A2BE2;
            box-shadow: 0 0 25px rgba(138, 43, 226, 0.65), inset 0 0 15px rgba(138, 43, 226, 0.3);
            transform: scale(1);
        }

        .rec-effect-circular.active .rec-effect-circle {
            animation: effectPulse 0.8s ease-in-out infinite;
        }

        @keyframes effectPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }
        }

        .rec-effect-circle {
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .rec-effects-grid::-webkit-scrollbar {
            width: 4px;
        }

        .rec-effects-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
        }

        .rec-effects-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        .rec-effects-grid::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        /* Mobile Responsive */
        @media (max-width: 480px) {
            .rec-effects-panel {
                width: 280px;
            }

            .rec-effects-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                padding: 12px;
            }
        }

        /* ====== RECORDING CONTROLS - SCREEN 2 ====== */
        .rec-recording-controls {
            position: absolute;
            bottom: 40px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0 40px;
        }

        .rec-recording-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rec-recording-btn.stop {
            width: 70px;
            height: 70px;
            border: 6px solid #fff;
            background: #ff0050;
        }

        .rec-recording-btn:active {
            transform: scale(0.9);
        }

        /* ====== EDIT CONTROLS - SCREEN 3 ====== */
        /* ====== VIDEO EDITING SCREEN - RESPONSIVE ====== */

        /* Edit Controls Container */
        .rec-edit-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.98), rgba(0, 0, 0, 0.8));
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 50;
            max-height: 25vh;
            overflow-y: auto;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.5);
        }

        /* Sound Button */
        .rec-add-sound-btn {
            width: 100%;
            padding: 13px 16px;
            background: linear-gradient(135deg, rgba(76, 29, 149, 0.3), rgba(109, 40, 217, 0.3));
            border: 1px solid rgba(76, 29, 149, 0.6);
            border-radius: 10px;
            color: #fff;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .rec-add-sound-btn:hover {
            background: linear-gradient(135deg, rgba(76, 29, 149, 0.5), rgba(109, 40, 217, 0.5));
            border-color: rgba(76, 29, 149, 0.8);
        }

        .rec-add-sound-btn:active {
            transform: scale(0.97);
        }

        /* Action Buttons Wrapper */
        .rec-action-buttons {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        /* Base Action Button */
        .rec-action-btn {
            flex: 1;
            padding: 14px 16px;
            border-radius: 10px;
            border: none;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
        }

        .rec-action-btn:active {
            transform: scale(0.96);
        }

        /* Draft Button */
        .rec-action-btn.draft {
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .rec-action-btn.draft:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.4);
        }

        /* Story Button */
        .rec-action-btn.story {
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .rec-action-btn.story:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.4);
        }

        /* Post Button - Primary CTA */
        .rec-action-btn.post {
            background: linear-gradient(135deg, #ff0050, #ff4081);
            color: #fff;
            border: none;
            box-shadow: 0 4px 15px rgba(255, 0, 80, 0.3);
        }

        .rec-action-btn.post:hover {
            background: linear-gradient(135deg, #ff1a66, #ff5fa0);
            box-shadow: 0 6px 20px rgba(255, 0, 80, 0.5);
        }

        /* ====== RESPONSIVE VIDEO EDIT ====== */

        /* Large Screens */
        @media (min-width: 1024px) {
            .rec-edit-controls {
                padding: 20px;
                gap: 15px;
            }

            .rec-add-sound-btn {
                padding: 16px 20px;
                font-size: 16px;
            }

            .rec-action-btn {
                padding: 16px 20px;
                font-size: 15px;
            }
        }

        /* Tablet */
        @media (max-width: 768px) {
            .rec-edit-controls {
                padding: 12px;
                gap: 10px;
                max-height: 25vh;
            }

            .rec-add-sound-btn {
                padding: 12px 14px;
                font-size: 14px;
            }

            .rec-action-btn {
                padding: 12px 14px;
                font-size: 13px;
            }
        }

        /* Mobile */
        @media (max-width: 480px) {
            .rec-edit-controls {
                padding: 10px;
                gap: 8px;
                max-height: 20vh;
            }

            .rec-add-sound-btn {
                padding: 10px 12px;
                font-size: 13px;
            }

            .rec-action-btn {
                padding: 10px 12px;
                font-size: 12px;
            }

            .rec-action-buttons {
                gap: 8px;
            }
        }

        /* ====== TEXT MODE STYLING ====== */
        /* Color Picker Bar */
        .rec-color-picker-bar {
            position: absolute;
            top: 80px;
            left: 0;
            right: 0;
            display: flex;
            gap: 10px;
            padding: 15px 20px;
            overflow-x: auto;
            z-index: 10;
        }

        /* Text Mode Styles */
        .rec-text-editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .rec-color-option {
            min-width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }

        .rec-color-option:hover {
            transform: scale(1.1);
        }

        .rec-color-option.active {
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .text-canvas {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: background 0.3s;
        }

        .rec-text-input {
            width: 100%;
            max-width: 500px;
            min-height: 200px;
            background: transparent;
            border: none;
            color: #fff;
            font-size: 32px;
            font-weight: 600;
            text-align: center;
            resize: none;
            outline: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .rec-text-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .char-count {
            position: absolute;
            bottom: 120px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 10;
        }

        .rec-text-tools {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 10;
        }


        .rec-text-tool-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border: none;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .rec-text-tool-btn:active {
            transform: scale(0.9);
        }

        .rec-text-tool-btn.active {
            background: #ff0050;
        }

        .rec-text-bottom-action {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 10;
        }

        .rec-text-next-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #ff0050;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(255, 0, 80, 0.4);
        }

        .rec-text-next-btn:active {
            transform: scale(0.9);
        }

        /* ====== TOGGLE SWITCH ====== */
        .rec-toggle-switch {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .rec-toggle-switch input {
            display: none;
        }

        .rec-toggle-slider {
            position: relative;
            width: 50px;
            height: 28px;
            background: #444;
            border-radius: 20px;
            transition: background 0.3s;
        }

        .rec-toggle-slider::before {
            content: '';
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
        }

        .rec-toggle-switch input:checked+.rec-toggle-slider {
            background: #ff0050;
        }

        .rec-toggle-switch input:checked+.rec-toggle-slider::before {
            left: 24px;
        }

        /* Text Preview Thumbnail */
        .rec-text-preview-thumbnail {
            width: 100px;
            height: 150px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            padding: 10px;
            text-align: center;
            word-break: break-word;
        }

        /* ====== POPUPS ====== */
        .rec-popup {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #1a1a1a;
            border-radius: 20px 20px 0 0;
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
            z-index: 2100;
            display: none;
            flex-direction: column;
            animation: slideUpPopup 0.3s ease;
        }

        .rec-popup.active {
            display: flex;
        }

        @keyframes slideUpPopup {
            from {
                transform: translateY(100%);
            }

            to {
                transform: translateY(0);
            }
        }

        .rec-popup-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rec-popup-header {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }

        .rec-popup-tab {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 14px;
            padding: 8px 12px;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
        }

        .rec-popup-tab.active {
            color: #ff0050;
            border-bottom-color: #ff0050;
        }

        .rec-popup-content {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }

        .rec-popup-item {
            aspect-ratio: 1;
            background: #222;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .rec-popup-item:active {
            transform: scale(0.95);
            background: #333;
            border-color: #ff0050;
        }

        /* ====== POST SETTINGS SECTIONS ====== */
        /* Toggle Section */
        .toggle-section {
            display: flex;
            justify-content: space-between !important;
            align-items: center !important;
        }

        .rec-post-section.toggle-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .rec-action-btn:active {
            transform: scale(0.98);
        }

        /* ====== POST SETTINGS SCREEN ====== */
        .rec-post-header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #000;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .rec-post-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: 100px;
        }

        .rec-post-section {
            margin-bottom: 20px;
            padding: 15px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .rec-section-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
            font-size: 15px;
            font-weight: 500;
            color: #fff;
        }

        .rec-caption-input {
            width: 100%;
            min-height: 80px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px;
            color: #fff;
            font-size: 15px;
            font-family: inherit;
            resize: vertical;
        }

        .rec-caption-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .rec-input-field {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px;
            color: #fff;
            font-size: 14px;
        }

        .rec-input-field::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        /* ====== PHOTO PREVIEW IN POST SCREEN ====== */
        .photo-post-preview-section {
            padding: 10px;
            background: linear-gradient(135deg, rgba(76, 29, 149, 0.15), rgba(109, 40, 217, 0.15));
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 10px;
            margin: 0 0 10px 0;
        }

        .photo-post-preview-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 11px;
        }

        .photo-post-preview-container {
            width: 100%;
            max-height: 280px;
            height: auto;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(100, 200, 255, 0.2);
        }

        .photo-post-preview-img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        .photo-post-edits-info {
            background: rgba(0, 0, 0, 0.2);
            padding: 6px 8px;
            border-radius: 6px;
            border-left: 2px solid #64c8ff;
            font-size: 10px;
        }

        .photo-edit-badge {
            display: inline-block;
            background: rgba(100, 200, 255, 0.15);
            border: 1px solid rgba(100, 200, 255, 0.4);
            color: #64c8ff;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }

        /* Mobile Responsiveness */
        @media (max-width: 480px) {
            .photo-post-preview-section {
                padding: 8px;
                margin: 0 0 8px 0;
            }

            .photo-post-preview-container {
                max-height: 220px;
                margin-bottom: 6px;
            }

            .photo-post-preview-header {
                font-size: 10px;
                margin-bottom: 6px;
            }
        }

        @media (max-width: 360px) {
            .photo-post-preview-section {
                padding: 10px;
            }
        }

        .rec-post-actions {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        /* ====== RECORDING INDICATOR - SCREEN 2 ====== */
        .rec-recording-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            background: rgba(255, 0, 80, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 25px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 11;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(255, 0, 80, 0.4);
        }

        .rec-timer-text {
            color: #fff;
            font-family: 'Monaco', 'Courier New', monospace;
            letter-spacing: 1px;
            min-width: 50px;
        }

        .rec-space-warning {
            color: #fff;
            animation: recWarningPulse 1s infinite;
        }

        .rec-rec-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #fff;
            animation: recPulse 1s infinite;
        }

        @keyframes recPulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        @keyframes recWarningPulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* ====== RECORDING UI TOAST ====== */
        .recording-toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(20px);
            padding: 15px 25px;
            border-radius: 25px;
            color: #fff;
            font-size: 14px;
            z-index: 2001;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .recording-toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .recording-toast-icon {
            font-size: 16px;
        }

        .recording-toast.success {
            background: rgba(67, 233, 123, 0.95);
        }

        .recording-toast.error {
            background: rgba(255, 0, 80, 0.95);
        }

        .recording-toast.info {
            background: rgba(79, 172, 254, 0.95);
        }

        /* ====== TIKTOK-STYLE COUNTDOWN MODAL ====== */
        .tiktok-countdown-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3500;
        }

        .tiktok-countdown-modal.active {
            display: flex;
        }

        .tiktok-countdown-content {
            text-align: center;
        }

        .tiktok-countdown-number {
            font-size: 180px;
            font-weight: 900;
            color: white;
            line-height: 1;
            text-shadow: 0 10px 30px rgba(76, 29, 149, 0.5);
            animation: countdownScale 1s ease-in forwards;
        }

        @keyframes countdownScale {
            0% {
                transform: scale(1.5);
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* ====== PRICE OPTIONS ====== */
        .price-options-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        .price-options {
            display: flex;
            gap: 8px;
            flex: 1;
        }

        .price-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #333;
            background: #222;
            color: #aaa;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s;
        }

        .price-btn:hover {
            border-color: #4C1D95;
            color: white;
        }

        .price-btn.active {
            border-color: #4C1D95;
            background: #4C1D95;
            color: white;
        }

        .price-info-icon {
            background: none;
            border: none;
            color: #4C1D95;
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: color 0.3s;
        }

        .price-info-icon:hover {
            color: #6D28D9;
        }

        /* Tooltip */
        .price-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            white-space: nowrap;
            margin-bottom: 8px;
            border: 1px solid #4C1D95;
            display: none;
            z-index: 1000;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        .price-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #4C1D95;
        }

        .price-info-icon:hover .price-tooltip {
            display: block;
        }

        /* Profile Page Styles */
        .profile-page {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            z-index: 1500;
            overflow-y: auto;
        }

        .profile-page.active {
            display: block;
        }

        .profile-header {
            position: relative;
            height: 200px;
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary-dark) 100%);
        }

        .profile-back-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
        }

        .profile-settings-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
        }

        .profile-info-section {
            position: relative;
            margin-top: -50px;
            padding: 0 20px;
        }

        .profile-pic-large {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 4px solid #000;
            background: #333;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            color: white;
            font-weight: bold;
        }

        .profile-name {
            text-align: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            margin-top: 15px;
        }

        .profile-username {
            text-align: center;
            color: #888;
            font-size: 16px;
            margin-top: 5px;
        }

        .profile-bio {
            text-align: center;
            color: #aaa;
            font-size: 14px;
            margin-top: 15px;
            line-height: 1.4;
        }

        .profile-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding: 20px 0;
            border-top: 1px solid #222;
            border-bottom: 1px solid #222;
        }

        .stat {
            text-align: center;
            color: white;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        .profile-tabs {
            display: flex;
            justify-content: space-around;
            padding: 15px 0;
            background: #111;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .profile-tab {
            color: #888;
            font-size: 14px;
            cursor: pointer;
            padding: 8px 12px;
            border-radius: var(--radius-sm);
        }

        .profile-tab.active {
            color: white;
            background: #222;
        }

        .profile-content {
            padding: 20px;
            min-height: 400px;
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
        }

        .video-item {
            aspect-ratio: 9/16;
            background: #222;
            position: relative;
            cursor: pointer;
        }

        .video-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-stats {
            position: absolute;
            bottom: 5px;
            left: 5px;
            right: 5px;
            color: white;
            font-size: 11px;
            display: flex;
            gap: 8px;
        }

        .post-section {
            background: #111;
            border-radius: var(--radius-md);
            padding: 20px;
            margin-bottom: 20px;
        }

        .post-input {
            width: 100%;
            min-height: 100px;
            background: #222;
            border: 1px solid #333;
            border-radius: var(--radius-sm);
            color: white;
            padding: 12px;
            font-size: 14px;
            resize: vertical;
        }

        .post-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .post-btn {
            flex: 1;
            padding: 10px;
            background: var(--primary);
            border: none;
            border-radius: var(--radius-sm);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
        }

        .post-btn:hover {
            background: var(--primary-light);
        }

        .feed-post {
            background: #111;
            border-radius: var(--radius-md);
            padding: 15px;
            margin-bottom: 15px;
        }

        .post-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .post-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #333;
        }

        .post-author {
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .post-text {
            color: #ddd;
            font-size: 14px;
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .post-stats {
            display: flex;
            gap: 20px;
            color: #888;
            font-size: 13px;
        }

        /* Original Feed Styles */
        .video-feed {
            height: 100%;
            width: 100%;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
        }

        .video-post {
            position: relative;
            height: 100vh;
            width: 100%;
            scroll-snap-align: start;
            overflow: hidden;
            background: #111;
            cursor: pointer;
        }

        .video-post video {
            height: 100%;
            width: 100%;
            object-fit: cover;
        }

        .play-pause-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 100;
        }

        .play-pause-overlay.show {
            opacity: 1;
        }

        .play-pause-overlay svg {
            width: 40px;
            height: 40px;
            fill: white;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            color: white;
        }

        .navbar {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px 20px;
            background: #0a0a0a;
            position: sticky;
            top: 0;
            z-index: 1000;
            border-bottom: 1px solid #222;
        }

        .profile-icon {
            position: absolute;
            left: 20px;
            font-size: 22px;
            background: rgba(76, 29, 149, 0.8);
            border-radius: 50%;
            padding: 8px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            border: 2px solid var(--primary-light);
            flex-shrink: 0;
        }

        .profile-icon:hover {
            background: rgba(76, 29, 149, 1);
            transform: scale(1.1);
        }

        .profile-icon img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        .tabs {
            display: flex;
            gap: 15px;
            font-size: 18px;
            font-weight: 500;
        }

        .tabs span {
            cursor: pointer;
            position: relative;
            color: white;
        }

        .tabs .active::after {
            content: "";
            position: absolute;
            bottom: -5px;
            left: 0;
            right: 0;
            margin: auto;
            width: 60%;
            height: 2px;
            background: white;
        }

        .search-icon {
            position: absolute;
            right: 20px;
            background: white;
            border-radius: 50%;
            padding: 8px;
            font-size: 18px;
            color: black;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
        }

        .sidebar {
            position: absolute;
            right: 10px;
            top: 30%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            font-size: 14px;
        }

        .sidebar div {
            text-align: center;
        }

        .sidebar i {
            font-size: 26px;
            display: block;
            margin-bottom: 5px;
        }

        .profile-section {
            position: absolute;
            bottom: 280px;
            left: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
            right: 80px;
            transition: bottom 0.3s ease;
        }

        .profile-section.ad-closed {
            bottom: 150px;
        }

        .profile-pic {
            position: relative;
            width: 50px;
            height: 50px;
            flex-shrink: 0;
        }

        .profile-pic img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }

        .infinity-badge {
            position: absolute;
            bottom: -5px;
            right: -5px;
            background: black;
            border: 2px solid white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .profile-info {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }

        .profile-info .name {
            font-weight: bold;
            font-size: 16px;
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .profile-info .followers {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.6);
        }

        .follow-btn {
            background: linear-gradient(45deg, var(--primary), var(--primary-light));
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            border: none;
            outline: none;
            transition: var(--transition);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(76, 29, 149, 0.3);
            flex-shrink: 0;
        }

        .ad-caption {
            position: absolute;
            bottom: 210px;
            left: 10px;
            font-size: 13px;
            max-width: 280px;
            line-height: 1.4em;
            transition: bottom 0.3s ease;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .ad-caption.ad-closed {
            bottom: 80px;
        }

        .banner-ad {
            position: absolute;
            bottom: 100px;
            left: 10px;
            width: 250px;
            height: 130px;
            border-radius: var(--radius-sm);
            overflow: hidden;
            background: var(--bg-card);
            transition: var(--transition);
            box-shadow: var(--shadow-md);
        }

        .banner-ad.hidden {
            opacity: 0;
            transform: translateX(-100%);
            pointer-events: none;
        }

        .banner-ad img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: red;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            text-align: center;
            line-height: 20px;
            font-size: 14px;
            cursor: pointer;
        }

        .bottom-nav {
            position: fixed;
            bottom: 10px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
            font-size: 14px;
            z-index: 1000;
            color: white;
        }

        .bottom-nav div {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }

        .bottom-nav i {
            font-size: 24px;
            margin-bottom: 3px;
        }

        /* Edit Profile Styles */
        .edit-profile-btn {
            position: absolute;
            top: 15px;
            right: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }

        .profile-pic-upload {
            position: relative;
            display: inline-block;
        }

        .profile-pic-large {
            background-size: cover;
            background-position: center;
        }

        .upload-overlay {
            position: absolute;
            bottom: 0;
            right: 0;
            background: var(--primary);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 3px solid #000;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* ========== VIDEO GRID PAGE ========== */
        .video-grid-page {
            background: #000;
            min-height: 100vh;
            padding: 70px 0 90px 0;
        }

        .grid-page-header {
            padding: 20px;
            border-bottom: 1px solid #222;
            background: #0a0a0a;
        }

        .grid-page-header h1 {
            color: white;
            font-size: 24px;
            font-weight: 700;
            margin: 0;
        }

        .video-grid-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            padding: 15px;
        }

        .grid-video-card {
            background: #111;
            border-radius: var(--radius-sm);
            overflow: hidden;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: var(--shadow-sm);
        }

        .grid-video-card:hover {
            transform: scale(1.02);
            box-shadow: var(--shadow-md);
        }

        .grid-thumbnail {
            width: 100%;
            aspect-ratio: 9/16;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-overlay {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
        }

        .grid-video-info {
            padding: 10px;
            background: #0a0a0a;
        }

        .grid-video-title {
            color: white;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .grid-video-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .grid-video-stats .views,
        .grid-video-stats .earnings {
            color: #888;
            font-size: 11px;
            font-weight: 500;
        }

        .grid-video-stats .earnings {
            color: #4ecdc4;
            font-weight: 600;
        }

        /* ========== TWEET FEED PAGE ========== */
        .tweet-feed-page {
            background: #000;
            min-height: 100vh;
            padding: 70px 0 90px 0;
        }

        .create-post-card {
            background: #0a0a0a;
            border-bottom: 1px solid #222;
            padding: 20px;
            margin-bottom: 10px;
        }

        .create-post-header {
            display: flex;
            gap: 12px;
            margin-bottom: 15px;
        }

        .user-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary-dark) 100%);
            flex-shrink: 0;
        }

        .create-post-input {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            font-size: 16px;
            font-family: Arial, sans-serif;
            resize: none;
            min-height: 60px;
            line-height: 1.5;
        }

        .create-post-input:focus {
            outline: none;
        }

        .create-post-input::placeholder {
            color: #555;
        }

        .create-post-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-left: 57px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
        }

        .action-icon-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            transition: var(--transition);
        }

        .action-icon-btn:hover {
            border-color: var(--text-secondary);
            color: var(--text-secondary);
        }

        .post-submit-btn {
            background: linear-gradient(45deg, var(--primary), var(--primary-light));
            border: none;
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: var(--shadow-sm);
        }

        .post-submit-btn:hover {
            opacity: 0.9;
            box-shadow: var(--shadow-md);
        }

        /* Timeline Posts */
        .feed-timeline {
            padding: 0;
        }

        .timeline-post {
            background: #0a0a0a;
            border-bottom: 1px solid #222;
            padding: 20px;
        }

        .post-user-info {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }

        .user-details {
            flex: 1;
        }

        .user-name {
            color: white;
            font-size: 15px;
            font-weight: 700;
            margin-bottom: 2px;
        }

        .verified {
            color: #1da1f2;
            font-size: 14px;
        }

        .user-handle {
            color: #666;
            font-size: 13px;
        }

        .post-content {
            margin-bottom: 12px;
        }

        .post-text {
            color: #e0e0e0;
            font-size: 15px;
            line-height: 1.5;
            margin: 0 0 12px 0;
        }

        .post-media {
            margin-top: 10px;
        }

        .media-thumbnail {
            width: 100%;
            border-radius: var(--radius-md);
        }

        .post-interactions {
            display: flex;
            gap: 20px;
            padding-top: 12px;
            border-top: 1px solid #1a1a1a;
        }

        .interaction-btn {
            color: #666;
            font-size: 13px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .interaction-btn:hover {
            color: #888;
        }

        .tip-btn {
            color: #4ecdc4;
            font-weight: 600;
        }

        .tip-btn:hover {
            color: #6ee7df;
        }

        /* Load More Section */
        .load-more-section {
            text-align: center;
            padding: 30px 20px;
        }

        .load-more-btn {
            background: #1a1a1a;
            border: 1px solid #333;
            color: white;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            margin-bottom: 10px;
        }

        .load-more-btn:hover {
            background: #222;
            border-color: #444;
        }

        .load-more-text {
            color: #666;
            font-size: 12px;
            margin: 10px 0 0 0;
        }

        /* Mobile Responsive */
        @media (max-width: 480px) {
            .video-grid-container {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
                padding: 10px;
            }

            .grid-video-title {
                font-size: 11px;
            }

            .grid-video-stats {
                font-size: 10px;
            }

            .action-buttons {
                flex-wrap: wrap;
            }

            .action-icon-btn {
                font-size: 11px;
                padding: 5px 10px;
            }
        }

        /* Improve touch scrolling on mobile */
        body {
            overscroll-behavior-y: contain;
        }

        /* Prevent body scroll when tabs are active */
        body.tab-active {
            overflow: hidden;
        }

        /* Tab Content Scrolling */
        .tab-content {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow-y: scroll;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            z-index: 100;
        }

        .tab-content.active {
            display: block;
        }

        /* Video Grid Page Scrollable */
        .video-grid-page {
            background: #000;
            min-height: 100vh;
            padding: 70px 0 90px 0;
            overflow-y: auto;
        }

        /* Tweet Feed Page Scrollable */
        .tweet-feed-page {
            background: #000;
            min-height: 100vh;
            padding: 70px 0 90px 0;
            overflow-y: auto;
        }

        /* Ensure video feed is also scrollable */
        .video-feed {
            height: 100vh;
            width: 100%;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            -webkit-overflow-scrolling: touch;
        }

        /* Hide scrollbar but keep functionality */
        .tab-content::-webkit-scrollbar,
        .video-grid-page::-webkit-scrollbar,
        .tweet-feed-page::-webkit-scrollbar,
        .video-feed::-webkit-scrollbar {
            width: 0px;
            display: none;
        }

        /* For Firefox */
        .tab-content,
        .video-grid-page,
        .tweet-feed-page,
        .video-feed {
            scrollbar-width: none;
        }

        /* Smooth scrolling */
        .tab-content {
            scroll-behavior: smooth;
        }

        /* Make sure content doesn't hide behind fixed elements */
        #poseTab .video-grid-page,
        #friendTab .tweet-feed-page {
            padding-top: 80px;
            padding-bottom: 100px;
        }

        /* Welcome Popup Overlay */
        .welcome-overlay {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            z-index: 3000;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .welcome-overlay.hidden {
            display: none;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }


        .welcome-modal {
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);

            border-radius: 20px;
            padding: 40px 30px;
            width: 90%;
            max-width: 450px;
            text-align: center;
            border: 1px solid #333;
            box-shadow: 0 20px 60px rgba(255, 0, 80, 0.3);
            animation: slideUp 0.4s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Logo Section */
        .welcome-logo {
            margin-bottom: 25px;
        }

        .logo-icon {
            margin: 0 auto 15px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, rgba(255, 0, 80, 0.2) 0%, transparent 70%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .logo-text {
            font-size: 42px;
            font-weight: 900;
            background: linear-gradient(45deg, #ff0050, #ff4081, #ff0050);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            letter-spacing: 3px;
            animation: gradientShift 3s ease infinite;
        }

        @keyframes gradientShift {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        /* Welcome Message */
        .welcome-message {
            margin-bottom: 30px;
        }

        .welcome-message h2 {
            color: white;
            font-size: 26px;
            font-weight: 700;
            margin: 0 0 15px 0;
        }

        .welcome-message p {
            color: #bbb;
            font-size: 16px;
            line-height: 1.6;
            margin: 0 0 20px 0;
        }

        .welcome-message strong {
            color: #ff4081;
            font-weight: 700;
        }

        /* Features List */
        .features-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            text-align: left;
            margin-top: 20px;
        }

        .feature-item {
            color: #ddd;
            font-size: 14px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #ff0050;
        }

        /* Action Buttons */
        .welcome-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .welcome-btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .signup-btn {
            background: linear-gradient(45deg, #ff0050, #ff4081);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 0, 80, 0.4);
        }

        .signup-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 0, 80, 0.6);
        }

        .login-btn {
            background: transparent;
            color: white;
            border: 2px solid #ff0050;
        }

        .login-btn:hover {
            background: rgba(255, 0, 80, 0.1);
            transform: translateY(-2px);
        }

        .skip-btn {
            background: transparent;
            border: none;
            color: #666;
            font-size: 14px;
            cursor: pointer;
            padding: 10px;
            transition: color 0.2s;
        }

        .skip-btn:hover {
            color: #888;
            text-decoration: underline;
        }

        /* Footer */
        .welcome-footer {
            padding-top: 20px;
            border-top: 1px solid #222;
        }

        .welcome-footer p {
            color: #777;
            font-size: 13px;
            margin: 0;
        }

        /* Mobile Responsive */
        @media (max-width: 480px) {
            .welcome-modal {
                padding: 30px 20px;
                width: 95%;
            }

            .logo-text {
                font-size: 36px;
            }

            .welcome-message h2 {
                font-size: 22px;
            }

            .welcome-message p {
                font-size: 15px;
            }

            .feature-item {
                font-size: 13px;
            }

            .welcome-btn {
                padding: 13px;
                font-size: 15px;
            }
        }

        .logo-img {
            width: 80px;
            /* adjust size as needed */
            height: auto;
            border-radius: 12px;
            /* optional rounded corners */
        }


        /* Upload Page Styles */
        .upload-page {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0a0a0a;
            z-index: 2000;
            overflow-y: auto;
        }

        .upload-page.active {
            display: block;
        }

        .upload-header {
            position: sticky;
            top: 0;
            background: #1a1a1a;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #333;
            z-index: 100;
        }

        .back-btn {
            background: transparent;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px 10px;
        }

        .upload-header h1 {
            font-size: 20px;
            font-weight: 700;
            color: white;
        }

        .header-spacer {
            width: 44px;
        }

        .upload-tabs {
            display: flex;
            justify-content: space-around;
            background: #1a1a1a;
            padding: 15px 0;
            border-bottom: 1px solid #333;
            position: sticky;
            top: 61px;
            z-index: 99;
        }

        .upload-tab {
            padding: 10px 20px;
            cursor: pointer;
            color: #888;
            font-weight: 600;
            border-radius: 20px;
            transition: all 0.3s;
        }

        .upload-tab.active {
            color: white;
            background: linear-gradient(45deg, #4C1D95, #6D28D9);
        }

        .tab-content-upload {
            display: none;
            padding: 20px;
        }

        .tab-content-upload.active {
            display: block;
        }

        .upload-form {
            max-width: 600px;
            margin: 0 auto;
        }

        .upload-textarea {
            width: 100%;
            min-height: 150px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            color: white;
            padding: 15px;
            font-size: 16px;
            resize: vertical;
            margin-bottom: 20px;
            font-family: Arial, sans-serif;
        }

        .upload-textarea:focus {
            outline: none;
            border-color: #4C1D95;
        }

        .media-upload-section {
            margin-bottom: 20px;
        }

        .media-label {
            display: block;
            color: #aaa;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .media-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .media-btn {
            flex: 1;
            padding: 12px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .media-btn:hover {
            background: #222;
            border-color: #4C1D95;
        }

        .media-preview {
            min-height: 100px;
            background: #1a1a1a;
            border: 2px dashed #333;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
        }

        .media-preview img,
        .media-preview video {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            color: #aaa;
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .text-input {
            width: 100%;
            padding: 12px 15px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            color: white;
            font-size: 14px;
        }

        .text-input:focus {
            outline: none;
            border-color: #4C1D95;
        }

        .file-input {
            width: 100%;
            padding: 12px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            cursor: pointer;
        }

        .monetization-options {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #aaa;
            font-size: 14px;
            cursor: pointer;
        }

        .toggle-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .done-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(45deg, #4C1D95, #6D28D9);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
        }

        .done-btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        /* Preview Popup */
        .preview-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            padding: 20px;
        }

        .preview-popup.active {
            display: flex;
        }

        .preview-modal {
            background: #1a1a1a;
            border-radius: 16px;
            padding: 30px;
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        .preview-modal h2 {
            color: white;
            font-size: 22px;
            margin-bottom: 20px;
        }

        .preview-content {
            color: white;
        }

        .preview-media {
            width: 100%;
            min-height: 200px;
            background: #0a0a0a;
            border-radius: 12px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .preview-media img,
        .preview-media video {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
        }

        /* ====== RECORD TAB STYLES ====== */

        /* Recording Interface */
        .record-interface {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: #000;
            color: white;
        }

        .record-interface.active {
            display: flex;
        }

        .record-container {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%;
            background: #000;
            overflow: hidden;
            flex: 1;
        }

        .camera-preview {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .effects-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .grid-line {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
        }

        .grid-line.horizontal {
            width: 100%;
            height: 1px;
        }

        .grid-line.horizontal.top {
            top: 33.33%;
        }

        .grid-line.horizontal.middle {
            top: 50%;
        }

        .grid-line.horizontal.bottom {
            top: 66.67%;
        }

        .grid-line.vertical {
            height: 100%;
            width: 1px;
        }

        .grid-line.vertical.left {
            left: 33.33%;
        }

        .grid-line.vertical.middle {
            left: 50%;
        }

        .grid-line.vertical.right {
            left: 66.67%;
        }

        .timer-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #ff0000;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            font-family: monospace;
            z-index: 100;
        }

        .clips-preview {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .clip-thumbnail {
            width: 60px;
            height: 80px;
            background: #222;
            border-radius: 6px;
            border: 2px solid #4C1D95;
            overflow: hidden;
        }

        .clip-thumbnail video,
        .clip-thumbnail canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .record-top-controls {
            display: flex;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
        }

        .control-btn {
            background: #4C1D95;
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: #6D28D9;
            transform: scale(1.05);
        }

        .beauty-panel {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-top: 1px solid #4C1D95;
        }

        .beauty-panel label {
            display: block;
            margin: 10px 0 5px;
            color: #aaa;
            font-size: 12px;
        }

        .beauty-panel input[type="range"] {
            width: 100%;
            margin-bottom: 15px;
        }

        .record-middle-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            border-top: 1px solid #333;
        }

        .speed-control,
        .mode-control,
        .duration-control,
        .aspect-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .speed-control label,
        .mode-control label,
        .duration-control label,
        .aspect-control label {
            font-size: 12px;
            color: #aaa;
            font-weight: 600;
        }

        .speed-buttons,
        .mode-buttons,
        .aspect-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .speed-btn,
        .mode-btn,
        .aspect-btn {
            flex: 1;
            min-width: 40px;
            padding: 6px;
            background: #333;
            border: 1px solid #555;
            color: #aaa;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .speed-btn:hover,
        .mode-btn:hover,
        .aspect-btn:hover {
            border-color: #4C1D95;
            color: white;
        }

        .speed-btn.active,
        .mode-btn.active,
        .aspect-btn.active {
            background: #4C1D95;
            border-color: #4C1D95;
            color: white;
        }

        .duration-select {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
        }

        .record-bottom-controls {
            display: flex;
            gap: 15px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
            border-top: 1px solid #333;
        }

        .action-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }

        .record-btn {
            background: #ff0000;
            color: white;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            padding: 0;
            font-size: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .record-btn:hover {
            background: #cc0000;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }

        .record-btn.stop-btn {
            background: #ff6600;
        }

        .delete-btn {
            background: #ff4444;
            color: white;
        }

        .delete-btn:hover {
            background: #cc0000;
        }

        .next-btn {
            background: linear-gradient(135deg, #4C1D95, #6D28D9);
            color: white;
        }

        .next-btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        .countdown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .countdown-number {
            font-size: 120px;
            color: white;
            font-weight: bold;
            text-shadow: 0 10px 30px rgba(76, 29, 149, 0.5);
            animation: countdownScale 1s ease-in forwards;
        }

        /* Editor Interface */
        .editor-interface {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: #0a0a0a;
            color: white;
            overflow-y: auto;
        }

        .editor-interface.active {
            display: flex;
        }

        .editor-header {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .back-btn {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 8px;
        }

        .back-btn:hover {
            color: #4C1D95;
        }

        .editor-header h3 {
            flex: 1;
            margin: 0;
            font-size: 18px;
        }

        .editor-preview {
            padding: 15px;
            background: #111;
            border-bottom: 1px solid #333;
        }

        .editor-video {
            width: 100%;
            max-height: 300px;
            border-radius: 8px;
            background: #000;
        }

        .clips-timeline {
            padding: 15px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .clips-timeline h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }

        .timeline-tracks {
            display: flex;
            gap: 8px;
            overflow-x: auto;
        }

        .timeline-clip {
            min-width: 80px;
            height: 60px;
            background: #333;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .timeline-clip:hover {
            border-color: #4C1D95;
        }

        .timeline-clip.selected {
            border-color: #6D28D9;
        }

        .editor-tabs {
            display: flex;
            gap: 8px;
            padding: 12px 15px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            overflow-x: auto;
        }

        .editor-tab-btn {
            background: #333;
            border: none;
            color: #aaa;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            white-space: nowrap;
            transition: all 0.3s;
        }

        .editor-tab-btn:hover {
            color: white;
            border-bottom: 2px solid #4C1D95;
        }

        .editor-tab-btn.active {
            background: #4C1D95;
            color: white;
        }

        .editor-tab-content {
            padding: 15px;
            display: none;
        }

        .editor-tab-content.active {
            display: block;
        }

        .filters-grid,
        .effects-grid,
        .stickers-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .filter-btn,
        .effect-btn,
        .sticker-btn {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .filter-btn:hover,
        .effect-btn:hover,
        .sticker-btn:hover {
            background: #4C1D95;
            border-color: #4C1D95;
            transform: scale(1.05);
        }

        .effect-category {
            margin-bottom: 20px;
        }

        .effect-category h5 {
            margin: 0 0 10px 0;
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
        }

        .text-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .text-controls input[type="text"],
        .text-controls input[type="color"],
        .text-controls select {
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 6px;
            font-size: 12px;
        }

        .text-controls input[type="color"] {
            width: 100%;
            height: 40px;
            cursor: pointer;
        }

        .trim-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .trim-item {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .trim-item h5 {
            margin: 0 0 10px 0;
            font-size: 13px;
        }

        .trim-item input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }

        .audio-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .editor-actions {
            display: flex;
            gap: 10px;
            padding: 15px;
            border-top: 1px solid #333;
            background: #1a1a1a;
        }

        .editor-actions .action-btn {
            flex: 1;
        }

        /* Pre-Posting Interface */
        .pre-posting-interface {
            display: flex;
            flex-direction: column;
            height: 100%;
            background: #0a0a0a;
            color: white;
            overflow-y: auto;
        }

        .posting-header {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .posting-preview {
            padding: 15px;
            background: #111;
            text-align: center;
        }

        .posting-video {
            width: 100%;
            max-width: 400px;
            max-height: 600px;
            border-radius: 12px;
            background: #000;
        }

        .posting-form {
            flex: 1;
            padding: 15px;
        }

        .posting-form .form-group {
            margin-bottom: 20px;
        }

        .posting-form label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #aaa;
        }

        .posting-form textarea,
        .posting-form select,
        .posting-form input[type="text"] {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            color: white;
            border-radius: 6px;
            font-size: 13px;
            font-family: inherit;
        }

        .posting-form textarea:focus,
        .posting-form input:focus,
        .posting-form select:focus {
            outline: none;
            border-color: #4C1D95;
            box-shadow: 0 0 10px rgba(76, 29, 149, 0.3);
        }

        .caption-suggestions {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .caption-suggestions button {
            background: #333;
            border: 1px solid #555;
            color: #aaa;
            padding: 6px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s;
        }

        .caption-suggestions button:hover {
            background: #4C1D95;
            border-color: #4C1D95;
            color: white;
        }

        .post-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 15px 0;
        }

        .option-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 13px;
        }

        .option-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .cover-selector {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }

        .cover-preview {
            width: 100%;
            height: 200px;
            background: #111;
            display: block;
        }

        .cover-controls {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .posting-actions {
            display: flex;
            gap: 10px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }

        .draft-btn {
            background: #666;
            color: white;
        }

        .draft-btn:hover {
            background: #777;
        }

        .post-btn {
            background: linear-gradient(135deg, #4C1D95, #6D28D9);
            color: white;
        }

        .post-btn:hover {
            opacity: 0.9;
        }

        /* Mobile Responsive */
        @media (max-width: 480px) {
            .upload-tabs {
                top: 56px;
            }

            .upload-tab {
                padding: 8px 15px;
                font-size: 14px;
            }

            .monetization-options {
                flex-direction: column;
                align-items: stretch;
            }

            .record-middle-controls {
                grid-template-columns: 1fr;
            }

            .post-options {
                grid-template-columns: 1fr;
            }

            .filters-grid,
            .effects-grid,
            .stickers-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }


        /* ====== SOUND LIBRARY MODAL ====== */
        .sound-library-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 3500;
            animation: fadeIn 0.3s ease;
            flex-direction: column;
        }

        .sound-library-modal.active {
            display: flex;
        }

        .sound-library-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .sound-library-header h2 {
            font-size: 20px;
            font-weight: 700;
            color: white;
            margin: 0;
        }

        .sound-library-close {
            background: transparent;
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .sound-library-close:hover {
            color: #ff0050;
            transform: scale(1.1);
        }

        /* Banner Ads Section */
        .sound-banner-ads {
            width: 100%;
            height: 180px;
            background: #0a0a0a;
            position: relative;
            overflow: hidden;
            border-bottom: 1px solid #333;
        }

        .banner-ads-slider {
            display: flex;
            height: 100%;
            transition: transform 0.5s ease;
        }

        .banner-ad-item {
            min-width: 100%;
            height: 100%;
            position: relative;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .banner-ad-item img,
        .banner-ad-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .banner-ad-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            color: white;
        }

        .banner-ad-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .banner-ad-subtitle {
            font-size: 12px;
            opacity: 0.8;
        }

        .banner-indicators {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            z-index: 10;
        }

        .banner-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: var(--transition);
        }

        .banner-indicator.active {
            background: white;
            width: 24px;
            border-radius: 4px;
        }

        /* Sound Tabs */
        .sound-tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            overflow-x: auto;
            scrollbar-width: none;
        }

        .sound-tabs::-webkit-scrollbar {
            display: none;
        }

        .sound-tab {
            flex: 1;
            min-width: 100px;
            padding: 15px 10px;
            background: transparent;
            border: none;
            color: #888;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            position: relative;
            transition: var(--transition);
            white-space: nowrap;
        }

        .sound-tab:hover {
            color: #aaa;
        }

        .sound-tab.active {
            color: white;
        }

        .sound-tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(45deg, #ff0050, #ff4081);
            border-radius: 2px 2px 0 0;
        }

        /* Tab Content */
        .sound-tab-content {
            display: none;
            flex: 1;
            overflow-y: auto;
            background: #0a0a0a;
        }

        .sound-tab-content.active {
            display: block;
        }

        /* Search Bar */
        .sound-search {
            padding: 15px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .sound-search-input {
            width: 100%;
            padding: 12px 45px 12px 15px;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 25px;
            color: white;
            font-size: 14px;
        }

        .sound-search-input:focus {
            outline: none;
            border-color: #ff0050;
        }

        .sound-search-input::placeholder {
            color: #666;
        }

        .search-icon {
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
            font-size: 16px;
        }

        /* Sound List */
        .sound-list {
            padding: 10px;
        }

        .sound-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #1a1a1a;
            border-radius: var(--radius-sm);
            margin-bottom: 8px;
            cursor: pointer;
            transition: var(--transition);
            border: 1px solid transparent;
        }

        .sound-item:hover {
            background: #222;
            border-color: #333;
        }

        .sound-item.active,
        .sound-item.playing {
            border-color: #ff0050;
            background: rgba(255, 0, 80, 0.1);
        }

        .sound-thumbnail {
            width: 50px;
            height: 50px;
            border-radius: var(--radius-sm);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
        }

        .sound-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .sound-play-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 32px;
            height: 32px;
            background: rgba(255, 0, 80, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            opacity: 1;
            transition: var(--transition);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(255, 0, 80, 0.5);
        }

        .sound-item:hover .sound-play-icon {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.15);
            background: rgba(255, 0, 80, 1);
        }

        /* Trending Badge */
        .trending-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            background: linear-gradient(135deg, #ff0050 0%, #ff6b7a 100%);
            border-radius: 12px;
            padding: 4px 8px;
            box-shadow: 0 2px 8px rgba(255, 0, 80, 0.4);
            animation: trendingPulse 2s ease-in-out infinite;
        }

        .trending-text {
            font-size: 10px;
            font-weight: 700;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 2px;
        }

        @keyframes trendingPulse {

            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(255, 0, 80, 0.4);
            }

            50% {
                transform: scale(1.05);
                box-shadow: 0 4px 15px rgba(255, 0, 80, 0.6);
            }
        }

        .sound-info {
            flex: 1;
            min-width: 0;
        }

        .sound-title {
            font-size: 14px;
            font-weight: 600;
            color: white;
            margin-bottom: 3px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .sound-artist {
            font-size: 12px;
            color: #888;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .sound-meta {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 11px;
            color: #666;
        }

        .sound-duration {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .sound-uses {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .sound-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
            align-items: center;
        }

        .sound-favorite-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .sound-favorite-btn:hover {
            background: rgba(255, 0, 80, 0.2);
            border-color: #ff0050;
            color: #ff0050;
            transform: scale(1.1);
        }

        .sound-favorite-btn.active {
            background: #ff0050;
            border-color: #ff0050;
            color: white;
        }

        .sound-action {
            background: transparent;
            border: 1px solid #333;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            flex-shrink: 0;
        }

        .sound-action:hover {
            background: #ff0050;
            border-color: #ff0050;
        }

        .sound-item.active .sound-action {
            background: #ff0050;
            border-color: #ff0050;
        }

        /* Empty State */
        .sound-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: #666;
            text-align: center;
        }

        .sound-empty-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .sound-empty-title {
            font-size: 18px;
            font-weight: 600;
            color: #888;
            margin-bottom: 10px;
        }

        .sound-empty-text {
            font-size: 14px;
            color: #666;
        }

        /* Voice Recording Interface */
        .voice-recorder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            min-height: 400px;
        }

        .voice-visualizer {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff0050, #ff4081);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 30px;
            box-shadow: 0 0 0 0 rgba(255, 0, 80, 0.7);
        }

        .voice-visualizer.recording {
            animation: voicePulse 1.5s infinite;
        }

        @keyframes voicePulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 0, 80, 0.7);
            }

            50% {
                box-shadow: 0 0 0 30px rgba(255, 0, 80, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 0, 80, 0.7);
            }
        }

        .voice-icon {
            font-size: 64px;
            color: white;
        }

        .voice-timer {
            font-size: 32px;
            font-weight: bold;
            color: white;
            margin-bottom: 30px;
            font-family: monospace;
        }

        .voice-controls {
            display: flex;
            gap: 20px;
        }

        .voice-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: var(--transition);
        }

        .voice-btn.record {
            background: #ff0050;
            color: white;
        }

        .voice-btn.record:hover {
            background: #cc0040;
            transform: scale(1.1);
        }

        .voice-btn.stop {
            background: #333;
            color: white;
        }

        .voice-btn.stop:hover {
            background: #444;
        }

        .voice-btn.save {
            background: #22c55e;
            color: white;
        }

        .voice-btn.save:hover {
            background: #16a34a;
        }

        /* Loading State */
        .sound-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: #888;
        }

        .sound-loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #333;
            border-top-color: #ff0050;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Mobile Responsive */
        @media (max-width: 480px) {
            .sound-banner-ads {
                height: 140px;
            }

            .sound-tab {
                min-width: 80px;
                font-size: 13px;
                padding: 12px 8px;
            }

            .sound-item {
                gap: 10px;
                padding: 10px;
            }

            .sound-thumbnail {
                width: 45px;
                height: 45px;
            }

            .sound-title {
                font-size: 13px;
            }

            .sound-artist {
                font-size: 11px;
            }
        }

        /* ====== SELECTED SOUND DISPLAY - SCREEN 6 ====== */
        .selected-sound-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 12px 20px;
            z-index: 15;
            display: none;
            align-items: center;
            gap: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            animation: slideDown 0.3s ease;
            max-width: calc(100% - 40px);
        }

        .selected-sound-container.show {
            display: flex;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .sound-display-thumbnail {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            flex-shrink: 0;
            overflow: hidden;
        }

        .sound-display-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .sound-display-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0;
        }

        .sound-display-title {
            font-size: 14px;
            font-weight: 600;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sound-display-artist {
            font-size: 12px;
            color: #aaa;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sound-display-controls {
            display: flex;
            gap: 8px;
            margin-left: auto;
            flex-shrink: 0;
        }

        .sound-play-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #ff0050;
            border: none;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .sound-play-btn:hover {
            background: #cc0040;
            transform: scale(1.05);
        }

        .sound-play-btn:active {
            transform: scale(0.95);
        }

        .sound-play-btn.playing {
            background: #22c55e;
        }

        .sound-trim-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #6366f1;
            border: none;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .sound-trim-btn:hover {
            background: #4f46e5;
            transform: scale(1.05);
        }

        .sound-trim-btn:active {
            transform: scale(0.95);
        }

        .sound-remove-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .sound-remove-btn:hover {
            background: #ff0050;
            border-color: #ff0050;
        }

        .sound-remove-btn:active {
            transform: scale(0.95);
        }

        /* Mobile Responsive */
        @media (max-width: 480px) {
            .selected-sound-container {
                top: 15px;
                padding: 10px 15px;
                border-radius: 15px;
            }

            .sound-display-thumbnail {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }

            .sound-display-title {
                font-size: 13px;
            }

            .sound-display-artist {
                font-size: 11px;
            }

            .sound-play-btn,
            .sound-remove-btn {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }
        }
    </style>
</head>

<body>
    <!-- Upload Progress Container -->
    <div class="upload-progress-container" id="uploadProgressContainer">
        <div class="upload-progress-header">
            <h3> <span id="uploadProgressTitle">Uploading</span></h3>
        </div>
        <div class="upload-progress-body">
            <!-- Step 1: Analyze -->
            <div class="upload-step">
                <div class="step-icon pending" id="step1Icon">1</div>
                <div class="step-content">
                    <div class="step-label">Analyzing Video</div>
                    <div class="step-progress" id="step1Progress">Checking size & format...</div>
                    <div class="step-bar" id="step1Bar">
                        <div class="step-bar-fill"></div>
                    </div>
                </div>
            </div>

            <!-- Step 2: Compress -->
            <div class="upload-step">
                <div class="step-icon pending" id="step2Icon">2</div>
                <div class="step-content">
                    <div class="step-label">Optimizing</div>
                    <div class="step-progress" id="step2Progress">Ready when needed</div>
                    <div class="step-bar" id="step2Bar">
                        <div class="step-bar-fill"></div>
                    </div>
                </div>
            </div>

            <!-- Step 3: Upload -->
            <div class="upload-step">
                <div class="step-icon pending" id="step3Icon">3</div>
                <div class="step-content">
                    <div class="step-label">Uploading to Cloud</div>
                    <div class="step-progress" id="step3Progress">Waiting...</div>
                    <div class="step-bar" id="step3Bar">
                        <div class="step-bar-fill"></div>
                    </div>
                </div>
            </div>

            <!-- Overall Progress -->
            <div class="overall-progress">
                <div class="overall-bar">
                    <div class="overall-bar-fill" id="overallBarFill"></div>
                </div>
                <div class="overall-stats">
                    <span id="uploadElapsedTime">0s</span>
                    <span id="uploadStats">0 MB / 0 MB</span>
                    <span id="uploadSpeed">0 MB/s</span>
                </div>
            </div>
        </div>
    </div>

    <!-- TikTok-Style Countdown Modal -->
    <div class="tiktok-countdown-modal" id="tiktokCountdownModal">
        <div class="tiktok-countdown-content">
            <div class="tiktok-countdown-number" id="countdownNumberDisplay">5</div>
        </div>
    </div>

    <!-- Upload Result Modal (Success/Error) -->
    <div class="upload-result-modal" id="uploadResultModal">
        <div class="upload-result-content">
            <div class="upload-result-thumbnail" id="uploadResultThumbnail">
                
            </div>
            <div class="upload-result-title" id="uploadResultTitle">Success!</div>
            <div class="upload-result-message" id="uploadResultMessage">Your video has been uploaded successfully!</div>

            <!-- Countdown Progress -->
            <div class="upload-result-countdown" id="uploadResultCountdown" style="display: none;">
                <div class="upload-result-countdown-text">Closing in...</div>
                <div class="countdown-bar">
                    <div class="countdown-bar-fill" id="countdownBarFill"></div>
                </div>
                <div class="countdown-time" id="countdownNumber">5</div>
            </div>

            <button class="upload-result-btn" onclick="closeUploadResultModal()">Continue</button>
        </div>
    </div>

    <!-- Upload Progress Modal (Professional) -->
    <div class="upload-progress-modal" id="uploadProgressModal">
        <div class="upload-progress-content">
            <div class="upload-progress-icon uploading" id="uploadProgressIcon"></div>
            <div class="upload-progress-title" id="uploadProgressTitle">Uploading Video</div>
            <div class="upload-progress-subtitle" id="uploadProgressSubtitle">Processing with effects...</div>

            <div class="upload-progress-bar-container">
                <div class="upload-progress-bar-fill" id="uploadProgressBarFill" style="width: 0%;"></div>
            </div>

            <div class="upload-progress-stats">
                <div class="upload-stat">
                    <div class="upload-stat-label">Progress</div>
                    <div class="upload-stat-value" id="uploadProgressPercent">0%</div>
                </div>
                <div class="upload-stat">
                    <div class="upload-stat-label">Speed</div>
                    <div class="upload-stat-value" id="uploadProgressSpeed">0 MB/s</div>
                </div>
                <div class="upload-stat">
                    <div class="upload-stat-label">Size</div>
                    <div class="upload-stat-value" id="uploadProgressSize">0 MB</div>
                </div>
                <div class="upload-stat">
                    <div class="upload-stat-label">ETA</div>
                    <div class="upload-stat-value" id="uploadProgressETA">--</div>
                </div>
            </div>

            <div class="upload-progress-text" id="uploadProgressText">Uploading to Cloudinary...</div>
        </div>
    </div>

    <!-- Auth Modals -->
    <div class="modal-overlay" id="authModal">
        <div class="modal">
            <button class="modal-close" onclick="closeAuthModal()"></button>
            <div id="signupForm">
                <h2>Join Pose</h2>
                <div id="authError" class="error-msg" style="display:none;"></div>
                <input type="text" id="signupName" placeholder="Full Name" required>
                <input type="text" id="signupUsername" placeholder="Username" required>
                <input type="email" id="signupEmail" placeholder="Email" required>
                <input type="password" id="signupPassword" placeholder="Password (min 6 characters)" required>
                <button class="modal-btn" onclick="handleSignup()">Sign Up</button>
                <div class="modal-switch">
                    Already have an account? <a onclick="switchToLogin()">Log In</a>
                </div>
            </div>
            <div id="loginForm" style="display:none;">
                <h2>Welcome Back</h2>
                <div id="loginError" class="error-msg" style="display:none;"></div>
                <input type="email" id="loginEmail" placeholder="Email" required>
                <input type="password" id="loginPassword" placeholder="Password" required>
                <button class="modal-btn" onclick="handleLogin()">Log In</button>
                <div class="modal-switch">
                    Don't have an account? <a onclick="switchToSignup()">Sign Up</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile Page -->
    <div class="profile-page" id="profilePage">
        <div class="profile-header">
            <button class="profile-back-btn" onclick="closeProfile()"></button>
            <button class="edit-profile-btn" onclick="openSettings()">Edit Profile</button>
            <button class="profile-settings-btn" onclick="logout()"></button>
        </div>
        <div class="profile-info-section">
            <div class="profile-pic-large" id="profilePicLarge">U</div>
            <div class="profile-name" id="profileDisplayName">User Name</div>
            <div class="profile-username" id="profileUsernameDisplay">@username</div>
            <div class="profile-bio">African Creator | Skits | Exclusive Content <br> Lagos, Nigeria</div>
            <div class="profile-stats">
                <div class="stat">
                    <div class="stat-value">12.5K</div>
                    <div class="stat-label">Followers</div>
                </div>
                <div class="stat">
                    <div class="stat-value">804</div>
                    <div class="stat-label">Following</div>
                </div>
                <div class="stat">
                    <div class="stat-value">108K</div>
                    <div class="stat-label">Likes</div>
                </div>
            </div>
            <div class="profile-stats">
                <div class="stat">
                    <div class="stat-value">550K</div>
                    <div class="stat-label">Total Views</div>
                </div>
                <div class="stat">
                    <div class="stat-value">82,400</div>
                    <div class="stat-label">Earnings</div>
                </div>
            </div>
        </div>
        <script type="text/javascript">
            atOptions = {
                'key': '9083b3df681674ed652cf9dd44c090a3',
                'format': 'iframe',
                'height': 50,
                'width': 320,
                'params': {}
            };
        </script>
        <script type="text/javascript"
            src="https://www.highperformanceformat.com/9083b3df681674ed652cf9dd44c090a3/invoke.js"></script>
        <!-- Settings Modal (Add right after profile-info-section closing div) -->
        <div class="modal-overlay" id="settingsModal">
            <div class="modal">
                <button class="modal-close" onclick="closeSettings()"></button>
                <h2>Edit Profile</h2>
                <div id="settingsError" class="error-msg" style="display:none;"></div>

                <!-- Profile Picture Upload -->
                <div style="text-align: center; margin-bottom: 20px;">
                    <div class="profile-pic-large" id="previewPic" style="margin: 0 auto 15px;">U</div>
                    <input type="file" id="profilePicInput" accept="image/*" style="display: none;">
                    <button class="modal-btn" onclick="document.getElementById('profilePicInput').click()"
                        style="background: #333;">
                         Change Photo
                    </button>
                </div>

                <input type="text" id="editName" placeholder="Full Name">
                <input type="text" id="editUsername" placeholder="Username">
                <textarea id="editBio" placeholder="Bio"
                    style="width: 100%; min-height: 80px; background: #2a2a2a; border: 1px solid #444; border-radius: 8px; color: white; padding: 12px; font-size: 14px; margin-bottom: 15px; resize: vertical; font-family: Arial, sans-serif;"></textarea>
                <input type="text" id="editLocation" placeholder="Location (e.g., Lagos, Nigeria)">

                <button class="modal-btn" onclick="saveProfile()">Save Changes</button>
                <button class="modal-btn" onclick="closeSettings()"
                    style="background: #333; margin-top: 10px;">Cancel</button>
            </div>
        </div>
        <div class="profile-tabs">
            <div class="profile-tab active" onclick="switchProfileTab('feed')"> Feed</div>
            <div class="profile-tab" onclick="switchProfileTab('exclusive')"> Exclusive</div>
            <div class="profile-tab" onclick="switchProfileTab('shorts')"> Shorts</div>
            <div class="profile-tab" onclick="switchProfileTab('tweets')"> Tweets</div>
            <div class="profile-tab" onclick="switchProfileTab('liked')"> Liked</div>
            <div class="profile-tab" onclick="switchProfileTab('stories')"> Stories</div>
        </div>
        <div class="profile-content" id="profileContent">
            <!-- Feed Videos Tab -->
            <div id="feedTab" class="profile-tab-content active">
                <div class="video-grid" id="feedGrid"></div>
            </div>
            <!-- Exclusive Tab (Paid Videos) -->
            <div id="exclusiveTab" class="profile-tab-content" style="display:none;">
                <div class="video-grid" id="exclusiveGrid"></div>
            </div>
            <!-- Shorts Tab (5-15 sec videos) -->
            <div id="shortsTab" class="profile-tab-content" style="display:none;">
                <div class="video-grid" id="shortsGrid"></div>
            </div>
            <!-- Tweets Tab -->
            <div id="tweetsTab" class="profile-tab-content" style="display:none;">
                <div class="post-compose-section">
                    <textarea class="post-input" placeholder="What's on your mind?" id="profileTweetInput"></textarea>
                    <div class="post-actions">
                        <button class="post-btn" onclick="attachMediaToTweet()"> Media</button>
                        <button class="post-btn" onclick="postNewTweet()">Post</button>
                    </div>
                </div>
                <div id="tweetsContainer"></div>
            </div>
            <!-- Liked Tab -->
            <div id="likedTab" class="profile-tab-content" style="display:none;">
                <div class="video-grid" id="likedGrid"></div>
            </div>
            <!-- Stories Tab -->
            <div id="storiesTab" class="profile-tab-content" style="display:none;">
                <div class="stories-container" id="storiesContainer"></div>
            </div>
        </div>
    </div>

    <!-- Original Feed UI (Keep these as is) -->
    <div class="navbar">
        <div class="profile-icon" onclick="handleProfileClick()">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="white">
                <path
                    d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z" />
            </svg>
        </div>
        <div class="tabs">
            <span class="tab active">For You</span>
            <span class="tab">tweet</span>
            <span class="tab">Pose</span>
        </div>
        <div class="search-icon">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="black">
                <path
                    d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
            </svg>
        </div>
    </div>
    <div class="bottom-nav">
        <div>
            <i><svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" />
                </svg></i>
            <span>Home</span>
        </div>
        <div onclick="openNotifications()">
            <i><svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                    <path
                        d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z" />
                </svg></i>
            <span>Alert</span>
        </div>
        <div onclick="openRecordingUI()">
            <i><svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                    <path
                        d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5h3V9h4v3h3l-5 5z" />
                </svg></i>
            <span>Create</span>
        </div>
        <div onclick="openUploadPage()">
            <i><svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                    <path
                        d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z" />
                </svg></i>
        </div>
        <div>
            <i><svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                    <path
                        d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4zM14 13h-3v3H9v-3H6v-2h3V8h2v3h3v2z" />
                </svg></i>
            <span>Live</span>
        </div>
        <div>
            <i><svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                    <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z" />
                </svg></i>
            <span>Music</span>
        </div>
    </div>

    <!-- RECORDING TOAST -->
    <div class="recording-toast" id="recordingToast">
        <span class="recording-toast-icon" id="recordingToastIcon"></span>
        <span id="recordingToastMessage">Message</span>
    </div>

    <!-- RECORDING UI OVERLAY -->
    <div id="recordingUIOverlay" class="recording-ui-overlay">
        <!-- SCREEN 1: VIDEO SETUP -->
        <div id="screen1" class="recording-screen active">
            <video id="videoPreview" class="camera-preview" playsinline autoplay muted webkit-playsinline></video>
            <div id="videoCameraInitError" class="camera-error-overlay" style="display: none;">
                <div style="text-align: center; color: #fff;">
                    <div style="font-size: 48px; margin-bottom: 15px;"></div>
                    <div style="font-size: 14px; margin-bottom: 10px;">Camera not available</div>
                    <div style="font-size: 12px; color: #aaa; line-height: 1.6;">
                        Please check:\n1. Camera permissions\n2. Camera not in use\n3. Browser support
                    </div>
                </div>
            </div>

            <!-- Selected Sound Display (Top Center) -->
            <div class="rec-sound-display" id="recSoundDisplay" style="display: none;">
                <div class="rec-sound-display-content">
                    <div class="rec-sound-thumbnail" id="recSoundThumbnail">
                        <i class="fas fa-music"></i>
                    </div>
                    <div class="rec-sound-info">
                        <div class="rec-sound-title" id="recSoundTitle">Sound Selected</div>
                        <div class="rec-sound-artist" id="recSoundArtist">Artist Name</div>
                    </div>
                    <button class="rec-sound-remove" onclick="removeRecordingSound()" title="Remove Sound">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>

            <!-- Top Bar -->
            <div class="rec-top-bar">
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <button class="rec-icon-btn" onclick="closeRecordingUI()"><i
                            class="fa-solid fa-arrow-left"></i></button>
                    <button class="rec-icon-btn" onclick="toggleRecLeftMenu()"><i
                            class="fa-solid fa-caret-down"></i></button>
                </div>
                <button class="rec-icon-btn" onclick="toggleVideoCameraFacing()"><i
                        class="fa-solid fa-rotate"></i></button>
            </div>

            <!-- Left Menu -->
            <div class="rec-left-menu" id="recLeftMenu">
                <div class="rec-menu-item" onclick="switchRecordingMode('photo')"> Photo</div>
                <div class="rec-menu-item" onclick="openLayoutOptions()"> Layout</div>
                <div class="rec-menu-item" onclick="openTimerOptions()"> Timer</div>
                <div class="rec-menu-item" onclick="openFilterOptions()"> Filters</div>
                <div class="rec-menu-item" onclick="openSpeedOptions()"> Speed</div>
            </div>

            <!-- Recording Status Bar -->
            <div class="rec-recording-status" id="recRecordingStatus" style="display: none;">
                <div class="rec-status-content">
                    <div class="rec-status-indicator"></div>
                    <div class="rec-status-text">Recording</div>
                    <div class="rec-timer-display" id="recTimerDisplay">0:00</div>
                </div>
            </div>

            <!-- Right Effects -->
            <div class="rec-effects-bar">
                <div class="rec-effect-icon" onclick="toggleEffect('sparkle')" title="Sparkle"></div>
                <div class="rec-effect-icon" onclick="toggleEffect('mask')" title="Mask"></div>
                <div class="rec-effect-icon" onclick="toggleEffect('ghost')" title="Ghost"></div>
                <div class="rec-effect-icon" onclick="toggleEffect('star')" title="Star"></div>
            </div>

            <!-- Filters Panel for Recording -->
            <div class="rec-filters-panel" id="recFiltersPanel">
                <div class="rec-filters-scroll" id="recFiltersScroll">
                    <button class="rec-filter-btn active" onclick="applyRecordingFilter('none')" title="Original">
                        <div class="rec-filter-preview original"></div>
                        <span>Original</span>
                    </button>
                    <button class="rec-filter-btn" onclick="applyRecordingFilter('bw')" title="Black & White">
                        <div class="rec-filter-preview bw"></div>
                        <span>B&W</span>
                    </button>
                    <button class="rec-filter-btn" onclick="applyRecordingFilter('sepia')" title="Sepia">
                        <div class="rec-filter-preview sepia"></div>
                        <span>Sepia</span>
                    </button>
                    <button class="rec-filter-btn" onclick="applyRecordingFilter('vintage')" title="Vintage">
                        <div class="rec-filter-preview vintage"></div>
                        <span>Vintage</span>
                    </button>
                    <button class="rec-filter-btn" onclick="applyRecordingFilter('vivid')" title="Vivid">
                        <div class="rec-filter-preview vivid"></div>
                        <span>Vivid</span>
                    </button>
                    <button class="rec-filter-btn" onclick="applyRecordingFilter('warm')" title="Warm">
                        <div class="rec-filter-preview warm"></div>
                        <span>Warm</span>
                    </button>
                    <button class="rec-filter-btn" onclick="applyRecordingFilter('cool')" title="Cool">
                        <div class="rec-filter-preview cool"></div>
                        <span>Cool</span>
                    </button>
                </div>
            </div>

            <!-- Effects Panel for Recording -->
            <div class="rec-effects-panel" id="recEffectsPanel">
                <div class="rec-effects-header">
                    <span style="flex: 1; text-align: center; color: white; font-weight: 600;">Effects</span>
                    <button class="rec-effects-close" onclick="toggleRecordingEffects()"></button>
                </div>
                <div style="overflow-y: auto; max-height: 600px;">
                    <!-- PARTICLE EFFECTS -->
                    <div class="rec-effects-category">
                        <div class="rec-category-title"> Particle Effects</div>
                        <div class="rec-effects-grid">
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('sparkle')"
                                title="Sparkle">
                                <div class="rec-effect-circle"></div>
                                <span>Sparkle</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('star')" title="Star">
                                <div class="rec-effect-circle"></div>
                                <span>Star</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('hearts')"
                                title="Hearts">
                                <div class="rec-effect-circle"></div>
                                <span>Hearts</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('confetti')"
                                title="Confetti">
                                <div class="rec-effect-circle"></div>
                                <span>Confetti</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('flowers')"
                                title="Flowers">
                                <div class="rec-effect-circle"></div>
                                <span>Flowers</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('snow')" title="Snow">
                                <div class="rec-effect-circle"></div>
                                <span>Snow</span>
                            </button>
                        </div>
                    </div>

                    <!-- LIGHT & GLOW EFFECTS -->
                    <div class="rec-effects-category">
                        <div class="rec-category-title"> Light & Glow</div>
                        <div class="rec-effects-grid">
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('glow')" title="Glow">
                                <div class="rec-effect-circle"></div>
                                <span>Glow</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('bokeh')" title="Bokeh">
                                <div class="rec-effect-circle"></div>
                                <span>Bokeh</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('rainbow')"
                                title="Rainbow">
                                <div class="rec-effect-circle"></div>
                                <span>Rainbow</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('sunbeam')"
                                title="Sunbeam">
                                <div class="rec-effect-circle"></div>
                                <span>Sunbeam</span>
                            </button>
                        </div>
                    </div>

                    <!-- DYNAMIC/DISTORTION EFFECTS -->
                    <div class="rec-effects-category">
                        <div class="rec-category-title"> Distortion</div>
                        <div class="rec-effects-grid">
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('kaleidoscope')"
                                title="Kaleidoscope">
                                <div class="rec-effect-circle"></div>
                                <span>Kaleido</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('pixelate')"
                                title="Pixelate">
                                <div class="rec-effect-circle"></div>
                                <span>Pixel</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('wave')" title="Wave">
                                <div class="rec-effect-circle"></div>
                                <span>Wave</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('fisheye')"
                                title="Fisheye">
                                <div class="rec-effect-circle"></div>
                                <span>Fisheye</span>
                            </button>
                        </div>
                    </div>

                    <!-- RETRO/FILM EFFECTS -->
                    <div class="rec-effects-category">
                        <div class="rec-category-title"> Retro</div>
                        <div class="rec-effects-grid">
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('vhs')" title="VHS">
                                <div class="rec-effect-circle"></div>
                                <span>VHS</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('glitch')"
                                title="Glitch">
                                <div class="rec-effect-circle"></div>
                                <span>Glitch</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('filmburn')"
                                title="Film Burn">
                                <div class="rec-effect-circle"></div>
                                <span>Film Burn</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('scanlines')"
                                title="Scanlines">
                                <div class="rec-effect-circle"></div>
                                <span>Scanlines</span>
                            </button>
                        </div>
                    </div>

                    <!-- NEON/VIBRANT EFFECTS -->
                    <div class="rec-effects-category">
                        <div class="rec-category-title"> Neon & Vibrant</div>
                        <div class="rec-effects-grid">
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('neon')" title="Neon">
                                <div class="rec-effect-circle"></div>
                                <span>Neon</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('cyberpunk')"
                                title="Cyberpunk">
                                <div class="rec-effect-circle"></div>
                                <span>Cyber</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('vaporwave')"
                                title="Vaporwave">
                                <div class="rec-effect-circle"></div>
                                <span>Vaporwave</span>
                            </button>
                        </div>
                    </div>

                    <!-- MOOD/THEMATIC EFFECTS -->
                    <div class="rec-effects-category">
                        <div class="rec-category-title"> Mood</div>
                        <div class="rec-effects-grid">
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('ghost')" title="Ghost">
                                <div class="rec-effect-circle"></div>
                                <span>Ghost</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('mask')" title="Mask">
                                <div class="rec-effect-circle"></div>
                                <span>Mask</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('dreamy')"
                                title="Dreamy">
                                <div class="rec-effect-circle"></div>
                                <span>Dreamy</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('noir')" title="Noir">
                                <div class="rec-effect-circle"></div>
                                <span>Noir</span>
                            </button>
                        </div>
                    </div>

                    <!-- MIRROR & CLONE EFFECTS -->
                    <div class="rec-effects-category">
                        <div class="rec-category-title"> Clone & Mirror</div>
                        <div class="rec-effects-grid">
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('mirror')"
                                title="Mirror">
                                <div class="rec-effect-circle"></div>
                                <span>Mirror</span>
                            </button>
                            <button class="rec-effect-circular" onclick="toggleRecordingEffect('clone')" title="Clone">
                                <div class="rec-effect-circle"></div>
                                <span>Clone</span>
                            </button>
                        </div>
                    </div>


                </div>
            </div>

            <!-- Layout Options Panel -->
            <div class="rec-options-panel" id="recLayoutPanel">
                <div class="rec-options-header">
                    <span style="flex: 1; text-align: center; color: white; font-weight: 600;">Recording Layout</span>
                    <button class="rec-options-close" onclick="closeLayoutPanel()"></button>
                </div>
                <div class="rec-options-grid">
                    <button class="rec-option-btn active" onclick="setRecordingLayout('full')" title="Full Screen">
                        <div class="rec-option-icon"></div>
                        <span>Full</span>
                    </button>
                    <button class="rec-option-btn" onclick="setRecordingLayout('16:9')" title="16:9">
                        <div class="rec-option-icon"></div>
                        <span>16:9</span>
                    </button>
                    <button class="rec-option-btn" onclick="setRecordingLayout('1:1')" title="Square">
                        <div class="rec-option-icon"></div>
                        <span>1:1</span>
                    </button>
                </div>
            </div>

            <!-- Speed Options Panel -->
            <div class="rec-options-panel" id="recSpeedPanel">
                <div class="rec-options-header">
                    <span style="flex: 1; text-align: center; color: white; font-weight: 600;">Recording Speed</span>
                    <button class="rec-options-close" onclick="closeSpeedPanel()"></button>
                </div>
                <div class="rec-options-grid">
                    <button class="rec-option-btn" onclick="setRecordingSpeed(0.5)" title="0.5x">
                        <div class="rec-option-icon"></div>
                        <span>0.5x</span>
                    </button>
                    <button class="rec-option-btn active" onclick="setRecordingSpeed(1)" title="1x">
                        <div class="rec-option-icon"></div>
                        <span>1x</span>
                    </button>
                    <button class="rec-option-btn" onclick="setRecordingSpeed(1.5)" title="1.5x">
                        <div class="rec-option-icon"></div>
                        <span>1.5x</span>
                    </button>
                    <button class="rec-option-btn" onclick="setRecordingSpeed(2)" title="2x">
                        <div class="rec-option-icon"></div>
                        <span>2x</span>
                    </button>
                </div>
            </div>



            <!-- Duration Options Panel -->
            <div class="rec-options-panel" id="recDurationPanel">
                <div class="rec-options-header">
                    <span style="flex: 1; text-align: center; color: white; font-weight: 600;">Recording Duration</span>
                    <button class="rec-options-close" onclick="closeDurationPanel()"></button>
                </div>
                <div class="rec-options-grid">
                    <button class="rec-option-btn" onclick="setRecordingDuration(5)" title="5 seconds">
                        <div class="rec-option-icon">5</div>
                        <span>5 sec</span>
                    </button>
                    <button class="rec-option-btn" onclick="setRecordingDuration(15)" title="15 seconds">
                        <div class="rec-option-icon">15</div>
                        <span>15 sec</span>
                    </button>
                    <button class="rec-option-btn active" onclick="setRecordingDuration(30)" title="30 seconds">
                        <div class="rec-option-icon">30</div>
                        <span>30 sec</span>
                    </button>
                    <button class="rec-option-btn" onclick="setRecordingDuration(60)" title="60 seconds">
                        <div class="rec-option-icon">60</div>
                        <span>60 sec</span>
                    </button>
                </div>
                <div style="padding: 15px; border-top: 1px solid #333;">
                    <label style="display: block; color: white; font-size: 12px; margin-bottom: 8px;">Custom Duration
                        (seconds):</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="number" id="customDurationInput" min="1" max="600" value="30"
                            style="flex: 1; padding: 10px; background: #2a2a2a; border: 1px solid #444; border-radius: 6px; color: white; font-size: 14px;">
                        <button onclick="setCustomRecordingDuration()"
                            style="padding: 10px 15px; background: linear-gradient(135deg, #4C1D95, #6D28D9); border: none; border-radius: 6px; color: white; font-weight: bold; cursor: pointer;">Set</button>
                    </div>
                </div>
            </div>

            <!-- Bottom Controls -->
            <div class="rec-bottom-controls">
                <div class="rec-control-row" id="recControlRow">
                    <button class="rec-control-btn" onclick="toggleRecordingDuration()">
                        <div class="rec-control-icon"></div>
                        <div class="rec-control-label" id="recDurationLabel">30s</div>
                    </button>
                    <button class="rec-control-btn" onclick="toggleRecordingFilters()">
                        <div class="rec-control-icon"></div>
                        <div class="rec-control-label" id="recFiltersLabel">Filters</div>
                    </button>
                    <button class="rec-control-btn" onclick="toggleRecordingEffects()">
                        <div class="rec-control-icon"></div>
                        <div class="rec-control-label">Effects</div>
                    </button>
                    <button class="rec-control-btn" onclick="openRecordingSoundLibrary()">
                        <div class="rec-control-icon"></div>
                        <div class="rec-control-label">Sound</div>
                    </button>
                    <button class="rec-control-btn rec-timer-btn" onclick="toggleRecordingTimer()">
                        <div class="rec-control-icon"></div>
                        <div class="rec-control-label" id="recTimerLabel">Off</div>
                    </button>
                </div>

                <div class="rec-record-btn-wrapper">


                    <!-- Main Record Button -->
                    <div class="rec-btn-container">
                        <button class="rec-record-btn" id="recMainBtn"
                            onclick="recordingState.isRecording ? stopRecording() : recordVideo()" title="Record video">
                            <div class="rec-btn-inner">
                                <div class="rec-btn-circle"></div>
                            </div>
                        </button>
                        <div class="rec-btn-label" id="recBtnLabel">Start</div>
                    </div>

                    <!-- Recording Controls (visible during recording) -->
                    <div class="rec-recording-controls" id="recRecordingControls" style="display: none;">
                        <button class="rec-control-action-btn rec-control-pause-btn" onclick="toggleRecordingPause()"
                            title="Pause/Resume" id="recPauseBtn">
                            <i class="fas fa-pause"></i>
                        </button>
                        <button class="rec-control-action-btn rec-control-stop-btn" onclick="stopRecording()"
                            title="Stop Recording">
                            <i class="fas fa-stop"></i>
                        </button>
                    </div>

                    <!-- Quality Badge -->
                    <div class="rec-quality-badge" id="recQualityBadge">
                        <span class="rec-quality-icon"></span>
                        <span class="rec-quality-text">4K</span>
                    </div>
                </div>

                <div class="rec-mode-tabs">
                    <button class="rec-mode-tab active" onclick="switchRecMode('video'); return false;">Video</button>
                    <button class="rec-mode-tab" onclick="switchRecMode('photo'); return false;">Photo</button>
                    <button class="rec-mode-tab" onclick="switchRecMode('text'); return false;">Text</button>
                </div>
            </div>

            <!-- AFCON Face Detection Canvas & Overlays -->
            <canvas id="afconFaceCanvas" style="position: absolute; top: 0; left: 0; display: none;"></canvas>
            <div id="afconOverlay"
                style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none;">
                <!-- Face paint left cheek -->
                <div id="afconLeftCheek"
                    style="position: absolute; width: 60px; height: 60px; background-size: contain; background-repeat: no-repeat; background-position: center; opacity: 0.8; display: none;">
                </div>
                <!-- Face paint right cheek -->
                <div id="afconRightCheek"
                    style="position: absolute; width: 60px; height: 60px; background-size: contain; background-repeat: no-repeat; background-position: center; opacity: 0.8; display: none;">
                </div>
                <!-- Flag/badge forehead -->
                <div id="afconBadge"
                    style="position: absolute; width: 50px; height: 50px; background-size: contain; background-repeat: no-repeat; background-position: center; display: none;">
                </div>
                <!-- Text overlay -->
                <div id="afconText"
                    style="position: absolute; color: white; font-weight: bold; font-size: 14px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); text-align: center; white-space: nowrap; display: none;">
                </div>
            </div>
        </div>




        <!-- SCREEN 3: VIDEO EDIT -->
        <div id="screen3" class="recording-screen">
            <div class="edit-video-container">
                <div class="edit-video-wrapper">
                    <video id="editVideoPreview" class="camera-preview" playsinline></video>

                    <!-- Hidden Audio Element for Sound Playback -->
                    <audio id="editVideoSoundAudio" style="display: none;"></audio>

                    <!-- Center Play Button (TikTok style) -->
                    <button class="video-center-play" id="videoCenterPlay" onclick="toggleEditVideoPlayPause()"
                        title="Play/Pause">
                        <i class="fas fa-play"></i>
                    </button>

                    <!-- Video Controls Overlay -->
                    <div class="edit-video-controls">
                        <div class="video-progress-bar">
                            <div class="video-progress-fill" id="videoProgressFill"></div>
                            <input type="range" id="videoProgressSlider" class="video-progress-slider" min="0" max="100"
                                value="0">
                        </div>
                        <div class="video-controls-bottom">
                            <button class="video-play-btn" id="editVideoPausePlay" onclick="toggleEditVideoPlayPause()"
                                title="Play/Pause">
                                <i class="fas fa-play"></i>
                            </button>
                            <div class="video-time-display">
                                <span id="videoCurrentTime">0:00</span>
                                <span class="time-separator">/</span>
                                <span id="videoDuration">0:00</span>
                            </div>
                            <button class="video-fullscreen-btn" id="editVideoFullscreen"
                                onclick="toggleEditVideoFullscreen()" title="Fullscreen">
                                <i class="fas fa-expand"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="edit-loading-overlay" id="editLoadingOverlay" style="display: none;">
                <div style="text-align: center; color: #fff;">
                    <div style="font-size: 32px; margin-bottom: 10px;"></div>
                    <div style="font-size: 14px;">Loading video...</div>
                </div>
            </div>

            <!-- Top Bar -->
            <div class="rec-top-bar">
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <button class="rec-icon-btn" onclick="backToScreen2()"><i
                            class="fa-solid fa-arrow-left"></i></button>
                    <button class="rec-icon-btn" onclick="toggleRecEditMenu()"><i
                            class="fa-solid fa-caret-down"></i></button>
                </div>
            </div>

            <!-- Left Menu -->
            <div class="rec-left-menu" id="recEditMenu">
                <div class="rec-menu-item" onclick="openVideoTextEditor()"> Text</div>
                <div class="rec-menu-item" onclick="openVideoTrimEditor()"> Trim</div>
                <div class="rec-menu-item" onclick="openVideoEffectsEditor()"> Effects</div>
                <div class="rec-menu-item" onclick="openVideoTemplates()"> Templates</div>
                <div class="rec-menu-item" onclick="toggleRecEditMenu()"> Close</div>
            </div>

            <!-- Edit Controls -->
            <div class="rec-edit-controls">
                <button class="rec-add-sound-btn" onclick="openVideoSoundLibrary()">
                     Add Sound
                </button>
                <div style="display: flex; gap: 10px;">
                    <button class="rec-action-btn draft" style="flex: 1;" onclick="saveVideoAsDraft()"> Draft</button>
                    <button class="rec-action-btn post" style="flex: 1;" onclick="goToPostSettings()">Continue
                        </button>
                </div>
            </div>
        </div>

        <!-- SCREEN 5: PHOTO MODE -->
        <div id="screen5" class="recording-screen">
            <div class="camera-preview">
                <!-- Ratio Guide Frame (Live Preview) -->
                <div id="ratioGuide" class="ratio-guide-frame"></div>
            </div>
            <div class="rec-top-bar">
                <button class="rec-icon-btn" onclick="backToScreen1()"></button>
                <button class="rec-icon-btn" onclick="toggleRecLeftMenu()"></button>
                <button class="rec-icon-btn" onclick="switchPhotoCamera()"></button>
            </div>
            <div class="rec-left-menu" id="recPhotoLeftMenu">
                <div class="rec-menu-item" onclick="togglePhotoFlash()"> Flash</div>
                <div class="rec-menu-item" onclick="togglePhotoTimer()"> Timer</div>
                <div class="rec-menu-item" onclick="togglePhotoFilters()"> Filters</div>
                <div class="rec-menu-item" onclick="togglePhotoRatio()"> Ratio</div>
            </div>
            <div class="rec-effects-bar">


                <!-- Filters Panel (Right Side, Scrollable) -->
                <div class="photo-filters-panel" id="photoFiltersPanel">
                    <div class="photo-filters-scroll" id="photoFiltersScroll">
                        <button class="photo-filter-btn" onclick="applyPhotoFilter('none')" title="Original">
                            <div class="photo-filter-preview original"></div>
                            <span>Original</span>
                        </button>
                        <button class="photo-filter-btn" onclick="applyPhotoFilter('bw')" title="Black & White">
                            <div class="photo-filter-preview bw"></div>
                            <span>B&W</span>
                        </button>
                        <button class="photo-filter-btn" onclick="applyPhotoFilter('sepia')" title="Sepia">
                            <div class="photo-filter-preview sepia"></div>
                            <span>Sepia</span>
                        </button>
                        <button class="photo-filter-btn" onclick="applyPhotoFilter('vintage')" title="Vintage">
                            <div class="photo-filter-preview vintage"></div>
                            <span>Vintage</span>
                        </button>
                        <button class="photo-filter-btn" onclick="applyPhotoFilter('vivid')" title="Vivid">
                            <div class="photo-filter-preview vivid"></div>
                            <span>Vivid</span>
                        </button>
                        <button class="photo-filter-btn" onclick="applyPhotoFilter('warm')" title="Warm">
                            <div class="photo-filter-preview warm"></div>
                            <span>Warm</span>
                        </button>
                        <button class="photo-filter-btn" onclick="applyPhotoFilter('cool')" title="Cool">
                            <div class="photo-filter-preview cool"></div>
                            <span>Cool</span>
                        </button>
                    </div>
                </div>
            </div>

            <div class="rec-bottom-controls photo-controls">
                <div class="photo-control-row">
                    <button class="photo-control-btn" onclick="openPhotoGallery()">
                        <div class="rec-control-icon"></div>
                        <div class="rec-control-label">Gallery</div>
                    </button>
                    <button class="photo-control-btn" onclick="togglePhotoFlash()">
                        <div class="rec-control-icon"></div>
                        <div class="rec-control-label">Flash</div>
                    </button>
                    <button class="photo-control-btn" onclick="togglePhotoTimer()">
                        <div class="rec-control-icon"></div>
                        <div class="rec-control-label">Timer</div>
                    </button>
                    <button class="photo-control-btn" onclick="togglePhotoPanelCollapse()">
                        <div class="rec-control-icon"></div>
                        <div class="rec-control-label">Filters</div>
                    </button>
                </div>

                <div class="photo-record-btn-wrapper">
                    <button class="photo-record-btn" onclick="capturePhoto()"></button>
                </div>

                <div class="rec-mode-tabs">
                    <button class="rec-mode-tab" onclick="switchRecMode('video'); return false;">Video</button>
                    <button class="rec-mode-tab active" onclick="switchRecMode('photo'); return false;">Photo</button>
                    <button class="rec-mode-tab" onclick="switchRecMode('text'); return false;">Text</button>
                </div>

                <!-- Bottom Filters Panel -->
                <div class="photo-filters-bottom-panel" id="photoFiltersBottomPanel">
                    <div class="photo-filters-toggle-header" onclick="togglePhotoFiltersBottom()">
                        <span class="toggle-arrow"></span>
                        <span> Filters</span>
                    </div>
                    <div class="photo-filters-bottom-content">
                        <div class="photo-filters-grid">
                            <button class="photo-filter-btn-bottom" onclick="applyPhotoFilter('none')" title="Original">
                                <div class="photo-filter-preview original"></div>
                                <span>Original</span>
                            </button>
                            <button class="photo-filter-btn-bottom" onclick="applyPhotoFilter('bw')"
                                title="Black & White">
                                <div class="photo-filter-preview bw"></div>
                                <span>B&W</span>
                            </button>
                            <button class="photo-filter-btn-bottom" onclick="applyPhotoFilter('sepia')" title="Sepia">
                                <div class="photo-filter-preview sepia"></div>
                                <span>Sepia</span>
                            </button>
                            <button class="photo-filter-btn-bottom" onclick="applyPhotoFilter('vintage')"
                                title="Vintage">
                                <div class="photo-filter-preview vintage"></div>
                                <span>Vintage</span>
                            </button>
                            <button class="photo-filter-btn-bottom" onclick="applyPhotoFilter('vivid')" title="Vivid">
                                <div class="photo-filter-preview vivid"></div>
                                <span>Vivid</span>
                            </button>
                            <button class="photo-filter-btn-bottom" onclick="applyPhotoFilter('warm')" title="Warm">
                                <div class="photo-filter-preview warm"></div>
                                <span>Warm</span>
                            </button>
                            <button class="photo-filter-btn-bottom" onclick="applyPhotoFilter('cool')" title="Cool">
                                <div class="photo-filter-preview cool"></div>
                                <span>Cool</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SCREEN 6: PHOTO EDIT -->
        <div id="screen6" class="recording-screen">
            <div class="camera-preview"> Photo Preview</div>
            <!-- Selected Sound Display -->
            <div class="selected-sound-container" id="selectedSoundContainer">
                <div class="sound-display-thumbnail" id="soundDisplayThumbnail"><i class="fas fa-music"></i></div>
                <div class="sound-display-info">
                    <div class="sound-display-title" id="soundDisplayTitle">Sound Name</div>
                    <div class="sound-display-artist" id="soundDisplayArtist">Artist Name</div>
                </div>
                <div class="sound-display-controls">
                    <button class="sound-play-btn" id="soundPlayBtn" onclick="toggleSelectedSoundPlayback()"
                        title="Play/Pause"><i class="fas fa-play"></i></button>
                    <button class="sound-trim-btn" id="soundTrimBtn" onclick="openSoundTrimmer()" title="Trim Sound"><i
                            class="fas fa-cut"></i></button>
                    <button class="sound-remove-btn" onclick="removeSelectedSound()" title="Remove"><i
                            class="fas fa-times"></i></button>
                </div>
            </div>
            <div class="rec-top-bar">
                <button class="rec-icon-btn" onclick="backToScreen5()"></button>
                <button class="rec-icon-btn" onclick="toggleRecPhotoEditMenu()"></button>
            </div>
            <div class="rec-left-menu" id="recPhotoEditMenu">
                <div class="rec-menu-item" onclick="photoAddText()"> Text</div>
                <div class="rec-menu-item" onclick="photoCrop()"> Crop</div>
                <div class="rec-menu-item" onclick="photoAddEffects()"> Effects</div>
                <div class="rec-menu-item" onclick="photoDraw()"> Draw</div>
            </div>
            <div class="rec-edit-controls">
                <button class="rec-add-sound-btn" onclick="openSoundLibrary()"> Add Sound</button>

                <button class="rec-action-btn" style="background: rgba(255, 255, 255, 0.1); flex: 1;"
                    onclick="showPhotoDownloadOptions()">
                     Download
                </button>
                <button class="rec-action-btn post" style="flex: 1;" onclick="goToPhotoPostSettings()">
                    Continue 
                </button>
            </div>

        </div>

        <!-- Photo Download Options Modal -->
        <div id="photoDownloadModal" class="modal-overlay">
            <div class="modal">
                <h2>Download Options</h2>
                <p style="color: #aaa; margin-bottom: 20px; font-size: 14px;">What would you like to download?</p>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <button class="modal-btn" style="flex: 1; background: linear-gradient(45deg, #4C1D95, #6D28D9);"
                        onclick="downloadPhotoOnly()">
                        <i class="fas fa-image"></i> Picture Only
                    </button>

                    <button class="modal-btn" style="background: rgba(255, 255, 255, 0.1); flex: 1;"
                        onclick="closePhotoDownloadModal()">Cancel</button>
                </div>
            </div>
        </div>

        <div id="discardPhotoModal" class="modal-overlay">
            <div class="modal">
                <h2>Discard Photo?</h2>
                <p style="color: #aaa; margin-bottom: 20px;">Are you sure you want to discard this photo?</p>
                <div style="display: flex; gap: 10px;">
                    <button class="modal-btn" style="background: rgba(255, 255, 255, 0.1); flex: 1;"
                        onclick="closeDiscardModal()">Stay</button>
                    <button class="modal-btn" style="flex: 1;" onclick="confirmDiscardPhoto()">Discard</button>
                </div>
            </div>
        </div>
        <!-- SCREEN 7: PHOTO POST SETTINGS -->
        <div id="screen7" class="recording-screen">
            <div class="rec-post-header">
                <button class="rec-icon-btn" onclick="backToScreen6()"></button>
                <h2 style="color: #fff; margin: 0;">Post Photo</h2>
                <div></div>
            </div>

            <!-- PHOTO PREVIEW SECTION -->
            <div class="photo-post-preview-section">
                <div class="photo-post-preview-header">
                    <span style="font-size: 12px; color: #aaa;">Preview of your photo:</span>
                    <span id="photoEditsDisplayInfo"
                        style="font-size: 11px; color: #64c8ff; font-weight: 600; margin-left: auto;"></span>
                </div>
                <div class="photo-post-preview-container" id="photoPostPreviewContainer">
                    <img id="photoPostPreviewImage" src="" alt="Photo preview" class="photo-post-preview-img">
                </div>
                <div class="photo-post-edits-info" id="photoPostEditsInfo" style="display: none;">
                    <div style="font-size: 12px; color: #fff; margin-bottom: 8px; font-weight: 600;"> Applied Edits:
                    </div>
                    <div id="photoEditsListContainer" style="display: flex; flex-wrap: wrap; gap: 8px;">
                        <!-- Edit badges will be populated here -->
                    </div>
                </div>
            </div>

            <div class="rec-post-content">
                <!-- Sound Section -->
                <div class="rec-post-section">
                    <div class="rec-section-header"> Sound</div>
                    <div id="photoPostSoundDisplay"
                        style="display: none; background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div id="photoPostSoundTitle" style="color: #fff; font-weight: 600; font-size: 13px;">
                                </div>
                                <div id="photoPostSoundArtist"
                                    style="color: rgba(255, 255, 255, 0.6); font-size: 11px; margin-top: 3px;"></div>
                            </div>
                            <button class="rec-action-btn" style="padding: 6px 12px; font-size: 12px;"
                                onclick="removePhotoPostSound()">Remove</button>
                        </div>
                    </div>
                    <button class="rec-action-btn"
                        style="width: 100%; background: rgba(100, 200, 255, 0.3); color: #64c8ff; border: 1px solid rgba(100, 200, 255, 0.5);"
                        onclick="openSoundLibrary()">
                         Add Sound
                    </button>
                </div>

                <div class="rec-post-section">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div class="rec-section-header" style="margin: 0;">Caption</div>
                        <span id="photoCaptionCounter" style="color: #999; font-size: 12px;">0/300</span>
                    </div>
                    <textarea class="rec-caption-input" id="photoCaption" placeholder="Add a caption..." maxlength="300"
                        oninput="updatePhotoCaptionCounter()"></textarea>
                </div>
                <div class="rec-post-section">
                    <div class="rec-section-header"># Hashtags</div>
                    <input type="text" class="rec-input-field" placeholder="Add hashtags">
                </div>
                <div class="rec-post-section">
                    <div class="rec-section-header">@ Tags</div>
                    <input type="text" class="rec-input-field" placeholder="Tag people">
                </div>
                <div class="rec-post-section">
                    <div class="rec-section-header"> Privacy</div>
                    <select class="rec-input-field">
                        <option>Everyone</option>
                        <option>Friends</option>
                        <option>Only me</option>
                    </select>
                </div>
            </div>
            <div class="rec-post-actions">
                <button class="rec-action-btn draft" onclick="saveDraftPhoto()">Draft</button>
                <button class="rec-action-btn story" onclick="postPhotoStory()">Your Story</button>
                <button class="rec-action-btn post" onclick="publishPhotoPost()">Post</button>
            </div>
        </div>

        <!-- SCREEN 8: TEXT MODE -->
        <div id="screen8" class="recording-screen">
            <div class="rec-text-editor-container">
                <!-- Color Picker Bar -->
                <div class="rec-color-picker-bar">
                    <div class="rec-color-option active"
                        style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"
                        onclick="changeTextBg(this)">
                    </div>
                    <div class="rec-color-option" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);"
                        onclick="changeTextBg(this)"></div>
                    <div class="rec-color-option" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);"
                        onclick="changeTextBg(this)"></div>
                    <div class="rec-color-option" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);"
                        onclick="changeTextBg(this)"></div>
                    <div class="rec-color-option" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);"
                        onclick="changeTextBg(this)"></div>
                    <div class="rec-color-option" style="background: #000;" onclick="changeTextBg(this)"></div>
                    <div class="rec-color-option" style="background: #fff;" onclick="changeTextBg(this)"></div>
                </div>

                <div class="rec-top-bar">
                    <button class="rec-icon-btn" onclick="backToScreen1()"></button>
                    <button class="rec-icon-btn" onclick="closeRecordingUI()"></button>
                </div>

                <!-- Text Input Area -->
                <div class="text-canvas" id="textEditorBg">
                    <textarea class="rec-text-input" id="textInput" placeholder="Type something..."
                        maxlength="500"></textarea>
                </div>
                <!-- Text Formatting Tools -->
                <div class="rec-text-tools">
                    <button class="rec-text-tool-btn" onclick="changeTextAlign('left')"><i
                            class="fa-solid fa-align-left"></i></button>
                    <button class="rec-text-tool-btn active" onclick="changeTextAlign('center')"><i
                            class="fa-solid fa-align-center"></i></button>
                    <button class="rec-text-tool-btn" onclick="changeTextAlign('right')"><i
                            class="fa-solid fa-align-right"></i></button>
                    <button class="rec-text-tool-btn" onclick="toggleBold()"><i class="fa-solid fa-bold"></i></button>
                    <button class="rec-text-tool-btn" onclick="changeTextColor()"><i
                            class="fa-solid fa-palette"></i></button>
                </div>

                <div style="position: absolute; bottom: 40px; right: 20px;">
                    <button onclick="goToTextPostSettings()"
                        style="width: 60px; height: 60px; border-radius: 50%; background: #ff0050; border: none; color: #fff; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center;"></button>
                </div>
            </div>
        </div>

        <!-- SCREEN 9: TEXT POST SETTINGS -->
        <div id="screen9" class="recording-screen">
            <div class="rec-post-header">
                <button class="rec-icon-btn" onclick="backToScreen8()"></button>
                <h2 style="color: #fff; margin: 0;">Post Text</h2>
                <div></div>
            </div>
            <div class="rec-post-content">
                <!-- Text Preview Thumbnail -->
                <div class="post-preview">
                    <div class="rec-text-preview-thumbnail" id="textPreview">
                        <span>Your Text</span>
                    </div>
                </div>
                <div class="rec-post-section">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div class="rec-section-header" style="margin: 0;">Caption</div>
                        <span id="textPostCaptionCounter" style="color: #999; font-size: 12px;">0/300</span>
                    </div>
                    <textarea class="rec-caption-input" id="textPostCaption" placeholder="Add a caption..."
                        maxlength="300" oninput="updateTextPostCaptionCounter()"></textarea>
                </div>
                <div class="rec-post-section">
                    <div class="rec-section-header"># Hashtags</div>
                    <input type="text" class="rec-input-field" placeholder="Add hashtags">
                </div>
                <div class="rec-post-section">
                    <div class="rec-section-header">@ Tags</div>
                    <input type="text" class="rec-input-field" placeholder="Tag people">
                </div>
                <div class="rec-post-section">
                    <div class="rec-section-header"> Privacy</div>
                    <select class="rec-input-field">
                        <option>Everyone</option>
                        <option>Friends</option>
                        <option>Only me</option>
                    </select>
                </div>

                <!-- Allow Comments -->
                <div class="post-section toggle-section">
                    <div class="section-header">
                        <i class="fa-solid fa-comment"></i>
                        <span>Allow comments</span>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="rec-post-section toggle-section">
                    <div class="rec-section-header"> Allow Comments</div>
                    <label class="rec-toggle-switch">
                        <input type="checkbox" checked>
                        <span class="rec-toggle-slider"></span>
                    </label>
                </div>

            </div>

            <div class="rec-post-actions">
                <button class="rec-action-btn draft" onclick="saveDraftText()">Draft</button>
                <button class="rec-action-btn story" onclick="postTextStory()">Your Story</button>
                <button class="rec-action-btn post" onclick="publishTextPost()">Post</button>
            </div>
        </div>

        <!-- SCREEN 4: POST SETTINGS -->
        <div id="screen4" class="recording-screen">
            <div class="rec-post-header">
                <button class="rec-icon-btn" onclick="backToScreen3()"></button>
                <h2 style="color: #fff; margin: 0;">Post</h2>
                <div></div>
            </div>
            <div class="rec-post-content">
                <div class="rec-post-section">
                    <div
                        style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div class="rec-section-header" style="margin: 0;">Caption</div>
                        <span id="captionCounter" style="color: #999; font-size: 12px;">0/300</span>
                    </div>
                    <textarea class="rec-caption-input" id="recCaption" placeholder="Add a caption..." maxlength="300"
                        oninput="updateCaptionCounter()"></textarea>
                </div>
                <div class="rec-post-section">
                    <div class="rec-section-header"># Hashtags</div>
                    <input type="text" class="rec-input-field" placeholder="Add hashtags">
                </div>
                <div class="rec-post-section">
                    <div class="rec-section-header">@ Tags</div>
                    <input type="text" class="rec-input-field" placeholder="Tag people">
                </div>
                <div class="rec-post-section">
                    <div class="rec-section-header"> Privacy</div>
                    <select class="rec-input-field">
                        <option>Everyone</option>
                        <option>Friends</option>
                        <option>Only me</option>
                    </select>
                </div>
                <div class="rec-post-section toggle-section">
                    <div class="rec-section-header"> Allow Comments</div>
                    <label class="rec-toggle-switch">
                        <input type="checkbox" checked>
                        <span class="rec-toggle-slider"></span>
                    </label>
                </div>
                <div class="rec-post-section toggle-section">
                    <div class="rec-section-header"> Allow Duet</div>
                    <label class="rec-toggle-switch">
                        <input type="checkbox" checked>
                        <span class="rec-toggle-slider"></span>
                    </label>
                </div>
                <div class="rec-post-section toggle-section">
                    <div class="rec-section-header"> Allow Stitch</div>
                    <label class="rec-toggle-switch">
                        <input type="checkbox" checked>
                        <span class="rec-toggle-slider"></span>
                    </label>
                </div>
                <div class="rec-post-section toggle-section">
                    <div class="rec-section-header"> Allow Sound Reuse</div>
                    <label class="rec-toggle-switch">
                        <input type="checkbox" checked>
                        <span class="rec-toggle-slider"></span>
                    </label>
                </div>
                <div class="rec-post-section toggle-section">
                    <div class="rec-section-header"> Allow Download</div>
                    <label class="rec-toggle-switch">
                        <input type="checkbox">
                        <span class="rec-toggle-slider"></span>
                    </label>
                </div>
            </div>
            <div class="rec-post-actions">
                <button class="rec-action-btn draft" onclick="saveDraftRecording()">Draft</button>
                <button class="rec-action-btn story" onclick="postStory()">Your Story</button>
                <button class="rec-action-btn post" onclick="publishRecordingPost()">Post</button>
            </div>
        </div>
    </div>

    <!-- Effects Popup -->
    <div class="rec-popup" id="effectsPopup">
        <button class="rec-popup-close" onclick="closeRecPopup('effectsPopup')"></button>
        <div class="rec-popup-header">
            <button class="rec-popup-tab active">Trending</button>
            <button class="rec-popup-tab">New</button>
            <button class="rec-popup-tab">Favorites</button>
        </div>
        <div class="rec-popup-content">
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
        </div>
    </div>

    <!-- Sound Popup -->
    <div class="rec-popup" id="soundPopup">
        <button class="rec-popup-close" onclick="closeRecPopup('soundPopup')"></button>
        <div class="rec-popup-header">
            <button class="rec-popup-tab active">Sounds</button>
            <button class="rec-popup-tab">Your Sounds</button>
        </div>
        <div class="rec-popup-content">
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
            <div class="rec-popup-item"></div>
        </div>
    </div>

    <!-- NOTIFICATIONS PAGE -->
    <div id="notificationsOverlay" class="notifications-overlay">
        <div class="notifications-header">
            <h2>Notifications</h2>
            <button class="notifications-close-btn" onclick="closeNotifications()"></button>
        </div>
        <div class="notifications-container" id="notificationsContainer">
            <!-- Notifications will be populated here -->
        </div>
    </div>

    <!-- The rest remains the same (friendTab and poseTab) --><!-- Tab Content Containers -->
    <div id="busTab" class="tab-content active">
        <!-- Video Feed (TikTok style) - This is your existing video-feed -->
        <!-- Scrollable feed -->
        <div class="video-feed">
            <!-- Post 1 -->
            <div class="video-post">
                <video src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4" autoplay
                    muted loop></video>
                <div class="play-pause-overlay">
                    <svg class="play-icon" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z" />
                    </svg>
                    <svg class="pause-icon" viewBox="0 0 24 24" style="display: none;">
                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                    </svg>
                </div>
                <div class="overlay">
                    <div class="sidebar">
                        <div>
                            <i>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="white">
                                    <path
                                        d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" />
                                </svg>
                            </i>
                            <span>223k</span>
                        </div>
                        <div>
                            <i>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="white">
                                    <path
                                        d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h4l4 4 4-4h4c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z" />
                                </svg>
                            </i>
                            <span>223k</span>
                        </div>
                        <div>
                            <i>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="white">
                                    <path
                                        d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z" />
                                </svg>
                            </i>
                            <span>223k</span>
                        </div>
                        <div>
                            <i>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="white">
                                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" />
                                </svg>
                            </i>
                        </div>
                        <div>
                            <i>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="white">
                                    <path
                                        d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
                                </svg>
                            </i>
                        </div>
                        <div class="speaker">
                            <i>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="white">
                                    <path
                                        d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z" />
                                </svg>
                            </i>
                        </div>
                    </div>
                    <div class="profile-section">
                        <div class="profile-pic">
                            <img src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='50' height='50'><rect width='50' height='50' fill='%23ff6b6b'/><text x='25' y='32' text-anchor='middle' fill='white' font-size='14' font-family='Arial'>CM</text></svg>"
                                alt="profile">
                            <div class="infinity-badge"></div>
                        </div>
                        <div class="profile-info">
                            <div class="name">CRAVING THE MONSTER</div>
                            <div class="followers">1.5M followers</div>
                        </div>
                        <button class="follow-btn">FOLLOW</button>
                    </div>
                    <div class="ad-caption">
                        <b>Discover the stories behind artists.</b> <span>See more >></span><br>
                        #Pose #meesu #oml
                    </div>
                    <div class="banner-ad">
                        <script type="text/javascript">
                            atOptions = {
                                'key': 'ba4c9c3efefaaf080ddd092b0757ca21',
                                'format': 'iframe',
                                'height': 300,
                                'width': 200,
                                'params': {}
                            };
                        </script>
                        <script type="text/javascript"
                            src="https://www.highperformanceformat.com/ba4c9c3efefaaf080ddd092b0757ca21/invoke.js"></script>
                        <div class="close-btn"></div>
                    </div>
                </div>
                <script type="text/javascript"
                    src="https://pl28295311.effectivegatecpm.com/ac/69/d9/ac69d9c0f8fc91fe0e2aa37859720286.js"></script>
            </div>

            <!-- Post 2 -->
            <div class="video-post">
                <video src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4"
                    autoplay muted loop></video>
                <div class="play-pause-overlay">
                    <svg class="play-icon" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z" />
                    </svg>
                    <svg class="pause-icon" viewBox="0 0 24 24" style="display: none;">
                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                    </svg>
                </div>
                <div class="overlay">
                    <div class="sidebar">
                        <div>
                            <i>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="white">
                                    <path
                                        d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" />
                                </svg>
                            </i>
                            <span>89k</span>
                        </div>
                        <div>
                            <i>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="white">
                                    <path
                                        d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h4l4 4 4-4h4c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z" />
                                </svg>
                            </i>
                            <span>14k</span>
                        </div>
                        <div>
                            <i>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="white">
                                    <path
                                        d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z" />
                                </svg>
                            </i>
                            <span>5k</span>
                        </div>
                        <div>
                            <i>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="white">
                                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z" />
                                </svg>
                            </i>
                        </div>
                        <div>
                            <i>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="white">
                                    <path
                                        d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
                                </svg>
                            </i>
                        </div>
                        <div class="speaker">
                            <i>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="white">
                                    <path
                                        d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z" />
                                </svg>
                            </i>
                        </div>
                    </div>
                    <div class="profile-section">
                        <div class="profile-pic">
                            <img src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='50' height='50'><rect width='50' height='50' fill='%234ecdc4'/><text x='25' y='32' text-anchor='middle' fill='white' font-size='16' font-family='Arial'>DJ</text></svg>"
                                alt="profile">
                            <div class="infinity-badge"></div>
                        </div>
                        <div class="profile-info">
                            <div class="name">DJ SMOKEY</div>
                            <div class="followers">900K followers</div>
                        </div>
                        <button class="follow-btn">FOLLOW</button>
                    </div>
                    <div class="ad-caption">
                        <b>Join the hottest party of 2025!</b> <span>Tap now >></span><br>
                        #Party #Vibes #Live
                    </div>
                    <div class="banner-ad">
                        <img src="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='250' height='130'><rect width='250' height='130' fill='%23667eea'/><text x='125' y='70' text-anchor='middle' fill='white' font-size='18' font-family='Arial'> Club Night</text></svg>"
                            alt="ad">
                        <div class="close-btn"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="friendTab" class="tab-content" style="display: none;">
        <div class="tweet-feed-page">
            <!-- Create Post Section -->
            <div class="create-post-card">
                <div class="create-post-header">
                    <div class="user-avatar" id="tweetUserAvatar"></div>
                    <textarea class="create-post-input" placeholder="What's happening?" maxlength="500"></textarea>
                </div>
                <div class="create-post-actions">
                    <div class="action-buttons">
                        <button class="action-icon-btn"> Add Media</button>
                        <button class="action-icon-btn"> Video</button>
                        <button class="action-icon-btn"> Tag Creator</button>
                    </div>
                    <button class="post-submit-btn">POST </button>
                </div>
            </div>

            <!-- Feed Timeline -->
            <div class="feed-timeline">
                <!-- Post 1 -->
                <div class="timeline-post">
                    <div class="post-user-info">
                        <div class="user-avatar"></div>
                        <div class="user-details">
                            <div class="user-name">Display Name <span class="verified"></span></div>
                            <div class="user-handle">@username  2m ago</div>
                        </div>
                    </div>
                    <div class="post-content">
                        <p class="post-text">Just dropped my latest dance clip  #PoseChallenge</p>
                        <div class="post-media">
                            <div class="media-thumbnail"
                                style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); height: 250px; border-radius: 12px;">
                            </div>
                        </div>
                    </div>
                    <div class="post-interactions">
                        <span class="interaction-btn"> 3.2K</span>
                        <span class="interaction-btn"> 220</span>
                        <span class="interaction-btn"> 80</span>
                        <span class="interaction-btn tip-btn"> Tip Creator</span>
                    </div>
                </div>

                <!-- Post 2 -->
                <div class="timeline-post">
                    <div class="post-user-info">
                        <div class="user-avatar"></div>
                        <div class="user-details">
                            <div class="user-name">Creator Name <span class="verified"></span></div>
                            <div class="user-handle">@creatorhandle  25m ago</div>
                        </div>
                    </div>
                    <div class="post-content">
                        <p class="post-text">I made 10,000 today from exclusive views </p>
                        <div class="post-media">
                            <div class="media-thumbnail"
                                style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); height: 200px; border-radius: 12px;">
                            </div>
                        </div>
                    </div>
                    <div class="post-interactions">
                        <span class="interaction-btn"> 2.1K</span>
                        <span class="interaction-btn"> 180</span>
                        <span class="interaction-btn"> 75</span>
                        <span class="interaction-btn tip-btn"> Tip Creator</span>
                    </div>
                </div>

                <!-- Post 3 -->
                <div class="timeline-post">
                    <div class="post-user-info">
                        <div class="user-avatar"></div>
                        <div class="user-details">
                            <div class="user-name">@user</div>
                            <div class="user-handle">1h ago</div>
                        </div>
                    </div>
                    <div class="post-content">
                        <p class="post-text">Pose feed is cleaner than Twitter ngl </p>
                    </div>
                    <div class="post-interactions">
                        <span class="interaction-btn"> 540</span>
                        <span class="interaction-btn"> 70</span>
                        <span class="interaction-btn"> 18</span>
                        <span class="interaction-btn tip-btn"> Tip Creator</span>
                    </div>
                </div>

                <!-- Post 4 -->
                <div class="timeline-post">
                    <div class="post-user-info">
                        <div class="user-avatar"></div>
                        <div class="user-details">
                            <div class="user-name">@creator</div>
                            <div class="user-handle">3h ago</div>
                        </div>
                    </div>
                    <div class="post-content">
                        <p class="post-text">Uploading new exclusive content tonight </p>
                        <div class="post-media">
                            <div class="media-thumbnail"
                                style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); height: 220px; border-radius: 12px;">
                            </div>
                        </div>
                    </div>
                    <div class="post-interactions">
                        <span class="interaction-btn"> 1.9K</span>
                        <span class="interaction-btn"> 200</span>
                        <span class="interaction-btn"> 60</span>
                        <span class="interaction-btn tip-btn"> Tip Creator</span>
                    </div>
                </div>
            </div>

            <!-- Show More Section -->
            <div class="load-more-section">
                <button class="load-more-btn">Show More Posts </button>
                <p class="load-more-text">Scroll to load more...</p>
            </div>
        </div>
    </div>

    <div id="poseTab" class="tab-content" style="display: none;">
        <!-- Video Grid -->
        <div class="video-grid-page">
            <div class="grid-header">
                <h2>My Videos</h2>
            </div>

            <div class="video-grid-container">
                <!-- Video Item 1 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Dance Challenge Day 1</div>
                        <div class="grid-stats">
                            <span> 12K</span>
                            <span>2,000</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 2 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Comedy Skit #5</div>
                        <div class="grid-stats">
                            <span> 8.5K</span>
                            <span>1,500</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 3 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Tutorial Video</div>
                        <div class="grid-stats">
                            <span> 5K</span>
                            <span>800</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 4 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Music Video</div>
                        <div class="grid-stats">
                            <span> 9K</span>
                            <span>1,200</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 5 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #30cfd0 0%, #330867 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Behind The Scenes</div>
                        <div class="grid-stats">
                            <span> 7.2K</span>
                            <span>1,000</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 6 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Live Stream Recap</div>
                        <div class="grid-stats">
                            <span> 4.1K</span>
                            <span>600</span>
                        </div>
                    </div>
                </div>
                <!-- Video Item 3 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Tutorial Video</div>
                        <div class="grid-stats">
                            <span> 5K</span>
                            <span>800</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 4 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Music Video</div>
                        <div class="grid-stats">
                            <span> 9K</span>
                            <span>1,200</span>
                        </div>
                    </div>
                </div>
                <!-- Video Item 3 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Tutorial Video</div>
                        <div class="grid-stats">
                            <span> 5K</span>
                            <span>800</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 4 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Music Video</div>
                        <div class="grid-stats">
                            <span> 9K</span>
                            <span>1,200</span>
                        </div>
                    </div>
                </div>
                <!-- Video Item 3 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Tutorial Video</div>
                        <div class="grid-stats">
                            <span> 5K</span>
                            <span>800</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 4 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Music Video</div>
                        <div class="grid-stats">
                            <span> 9K</span>
                            <span>1,200</span>
                        </div>
                    </div>
                </div>
                <!-- Video Item 3 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Tutorial Video</div>
                        <div class="grid-stats">
                            <span> 5K</span>
                            <span>800</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 4 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Music Video</div>
                        <div class="grid-stats">
                            <span> 9K</span>
                            <span>1,200</span>
                        </div>
                    </div>
                </div>
                <!-- Video Item 3 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Tutorial Video</div>
                        <div class="grid-stats">
                            <span> 5K</span>
                            <span>800</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 4 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Music Video</div>
                        <div class="grid-stats">
                            <span> 9K</span>
                            <span>1,200</span>
                        </div>
                    </div>
                </div>
                <!-- Video Item 3 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Tutorial Video</div>
                        <div class="grid-stats">
                            <span> 5K</span>
                            <span>800</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 4 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Music Video</div>
                        <div class="grid-stats">
                            <span> 9K</span>
                            <span>1,200</span>
                        </div>
                    </div>
                </div>
                <!-- Video Item 3 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Tutorial Video</div>
                        <div class="grid-stats">
                            <span> 5K</span>
                            <span>800</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 4 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Music Video</div>
                        <div class="grid-stats">
                            <span> 9K</span>
                            <span>1,200</span>
                        </div>
                    </div>
                </div>
                <!-- Video Item 3 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Tutorial Video</div>
                        <div class="grid-stats">
                            <span> 5K</span>
                            <span>800</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 4 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Music Video</div>
                        <div class="grid-stats">
                            <span> 9K</span>
                            <span>1,200</span>
                        </div>
                    </div>
                </div>
                <!-- Video Item 3 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Tutorial Video</div>
                        <div class="grid-stats">
                            <span> 5K</span>
                            <span>800</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 4 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Music Video</div>
                        <div class="grid-stats">
                            <span> 9K</span>
                            <span>1,200</span>
                        </div>
                    </div>
                </div>
                <!-- Video Item 3 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Tutorial Video</div>
                        <div class="grid-stats">
                            <span> 5K</span>
                            <span>800</span>
                        </div>
                    </div>
                </div>

                <!-- Video Item 4 -->
                <div class="grid-video-item">
                    <div class="grid-thumbnail" style="background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">
                    </div>
                    <div class="grid-info">
                        <div class="grid-title">Music Video</div>
                        <div class="grid-stats">
                            <span> 9K</span>
                            <span>1,200</span>
                        </div>
                    </div>
                </div>

            </div>

            <div class="load-more">
                <button class="load-more-btn">Load More Videos </button>
            </div>
        </div>
    </div>
    <!-- Welcome Popup -->
    <div class="welcome-overlay" id="welcomePopup">
        <div class="welcome-modal">
            <!-- Logo and Branding -->
            <div class="welcome-logo">
                <div class="logo-icon">
                    <img src="https://i.ibb.co/60JJMHGJ/Red-and-White-Video-Centric-Coming-Soon-Instagram-Post-20250917-230708-0000.png"
                        alt="Red-and-White-Video-Centric-Coming-Soon-Instagram-Post-20250917-230708-0000"
                        class="logo-img" />
                </div>
                <h1 class="logo-text">POSE</h1>
            </div>



            <!-- Welcome Message -->
            <div class="welcome-message">
                <h2>Welcome to Pose (sample version)</h2>
                <p>Pose helps African creators get <strong>instant</strong> and <strong>multiple revenue models</strong>
                </p>
                <div class="features-list">
                    <div class="feature-item"> Get paid from 100 views</div>
                    <div class="feature-item"> Earn 70-85% of your revenue</div>
                    <div class="feature-item"> Multiple income streams</div>
                    <div class="feature-item"> Instant withdrawals</div>
                </div>
            </div>

            <!-- Auth Buttons -->
            <div class="welcome-actions">
                <button class="welcome-btn signup-btn" onclick="openSignupFromWelcome()">
                    Create Account
                </button>
                <button class="welcome-btn login-btn" onclick="openLoginFromWelcome()">
                    Sign In
                </button>
                <button class="skip-btn" onclick="closeWelcomePopup()">
                    Skip for now
                </button>
            </div>

            <!-- Footer -->
            <div class="welcome-footer">
                <p>Join thousands of African creators earning today </p>
            </div>
        </div>
    </div>

    <!-- Upload Page -->
    <div class="upload-page" id="uploadPage">
        <!-- Header -->
        <div class="upload-header">
            <button class="back-btn" onclick="closeUploadPage()"></button>
            <h1>Upload Content</h1>
            <div class="header-spacer"></div>
        </div>

        <!-- Tabs -->
        <div class="upload-tabs">
            <div class="upload-tab active" onclick="switchUploadTab('tweet')">Tweet</div>
            <div class="upload-tab" onclick="switchUploadTab('post')">Post</div>
            <div class="upload-tab" onclick="switchUploadTab('record')"> Record</div>
        </div>

        <!-- Tweet Tab Content -->
        <div class="tab-content-upload active" id="tweetTab">
            <div class="upload-form">
                <textarea class="upload-textarea" id="tweetText" placeholder="What's on your mind?"
                    maxlength="500"></textarea>

                <div class="media-upload-section">
                    <label class="media-label">Attach Media (Optional)</label>
                    <div class="media-buttons">
                        <input type="file" id="tweetMedia" accept="image/*,video/*" style="display: none;"
                            onchange="autoUploadVideo(this, 'tweet')">
                        <button class="media-btn" onclick="document.getElementById('tweetMedia').click()">
                            Image</button>
                        <button class="media-btn" onclick="document.getElementById('tweetMedia').click()">
                            Video</button>
                    </div>
                    <div id="tweetUploadStatus" style="color: #aaa; font-size: 12px; margin-top: 8px;"></div>
                    <div id="tweetMediaPreview" class="media-preview"></div>
                </div>

                <button class="done-btn" onclick="openTweetPreview()">Done</button>
            </div>
        </div>

        <!-- Debug Panel -->
        <div id="debugPanel"
            style="background: #222; color: #0f0; padding: 15px; margin-bottom: 15px; border-radius: 8px; font-family: monospace; font-size: 12px; max-height: 150px; overflow-y: auto; display: none;">
            <div style="text-align: right;">
                <button onclick="document.getElementById('debugPanel').style.display='none'"
                    style="background: #444; color: white; border: none; padding: 5px 10px; cursor: pointer; border-radius: 4px;">Close</button>
            </div>
            <div id="debugLog"></div>
        </div>

        <!-- Post Tab Content -->
        <div class="tab-content-upload" id="postTab">
            <div class="upload-form">
                <button type="button" onclick="toggleDebug()"
                    style="background: #666; color: white; padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 15px; width: 100%;">
                    Toggle Debug Panel</button>
                <div class="form-group">
                    <label class="form-label">Upload Video</label>
                    <input type="file" id="postVideo" accept="video/*" class="file-input"
                        onchange="autoUploadVideo(this, 'post')">
                    <div id="postUploadStatus" style="color: #aaa; font-size: 12px; margin-top: 8px;"></div>
                    <div id="postVideoPreview" class="media-preview"></div>
                </div>

                <div class="form-group">
                    <label class="form-label">Title</label>
                    <input type="text" id="postTitle" class="text-input" placeholder="Enter video title">
                </div>

                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea id="postDescription" class="upload-textarea" placeholder="Describe your video..."
                        rows="4"></textarea>
                </div>

                <div class="form-group">
                    <label class="form-label">Tags</label>
                    <input type="text" id="postTags" class="text-input" placeholder="#fun #pose #viral">
                </div>

                <div class="form-group">
                    <label class="form-label">Video Price</label>
                    <div class="price-options-group">
                        <div class="price-options">
                            <button type="button" class="price-btn active" onclick="setPostPrice(0, 'free')"
                                id="priceFreBtn"> Free</button>
                            <button type="button" class="price-btn" onclick="setPostPrice(1, '1pc')" id="price1pcBtn">
                                1 PC</button>
                            <button type="button" class="price-btn" onclick="setPostPrice(2, '2pc')" id="price2pcBtn">
                                2 PC</button>
                        </div>
                        <button class="price-info-icon" type="button">
                            <div class="price-tooltip">1 PC = 25</div>
                        </button>
                    </div>
                </div>

                <input type="hidden" id="postPrice" value="0">
                <input type="hidden" id="postPriceType" value="free">

                <div class="form-group">
                    <label class="form-label">Thumbnail</label>
                    <input type="file" id="postThumbnail" accept="image/*" class="file-input">
                    <div id="postThumbnailPreview" class="media-preview"></div>
                </div>

                <button class="done-btn" onclick="window.uploadPost()">Post Video</button>
            </div>
        </div>

        <!-- Record Tab Content (TikTok-Style Video Creator) -->
        <div class="tab-content-upload" id="recordTab">
            <!-- Recording Interface -->
            <div id="recordingInterface" class="record-interface active">
                <!-- Camera Preview & Controls -->
                <div class="record-container">
                    <video id="cameraPreview" class="camera-preview" autoplay playsinline></video>
                    <canvas id="effectsCanvas" class="effects-canvas" style="display:none;"></canvas>

                    <!-- Grid Lines (Optional) -->
                    <div id="gridOverlay" class="grid-overlay" style="display:none;">
                        <div class="grid-line horizontal top"></div>
                        <div class="grid-line horizontal middle"></div>
                        <div class="grid-line horizontal bottom"></div>
                        <div class="grid-line vertical left"></div>
                        <div class="grid-line vertical middle"></div>
                        <div class="grid-line vertical right"></div>
                    </div>

                    <!-- Timer Display -->
                    <div id="timerDisplay" class="timer-display">00:00</div>

                    <!-- Recording Clips List -->
                    <div id="clipsPreview" class="clips-preview"></div>
                </div>

                <!-- Top Controls Bar -->
                <div class="record-top-controls">
                    <button class="control-btn" id="gridToggle" onclick="toggleGrid()" title="Toggle Grid">
                        Grid</button>
                    <button class="control-btn" id="flashToggle" onclick="toggleFlash()" title="Toggle Flash">
                        Flash</button>
                    <button class="control-btn" id="flipCamera" onclick="flipCamera()" title="Flip Camera">
                        Flip</button>
                    <button class="control-btn" id="beautyToggle" onclick="openBeautyMode()" title="Beauty Mode">
                        Beauty</button>
                </div>

                <!-- Beauty Mode Slider -->
                <div id="beautyPanel" class="beauty-panel" style="display:none;">
                    <label>Smooth Skin: <span id="beautyValue">0</span></label>
                    <input type="range" id="beautySlider" min="0" max="100" value="0" onchange="applyBeautyEffect()">
                    <label>Sharpen: <span id="sharpenValue">0</span></label>
                    <input type="range" id="sharpenSlider" min="0" max="100" value="0" onchange="applyBeautyEffect()">
                    <button class="done-btn" onclick="closeBeautyMode()">Done</button>
                </div>

                <!-- Middle Controls - Recording & Speed -->
                <div class="record-middle-controls">
                    <div class="speed-control">
                        <label>Speed</label>
                        <div class="speed-buttons">
                            <button class="speed-btn" onclick="setRecordingSpeed(0.3)">0.3x</button>
                            <button class="speed-btn" onclick="setRecordingSpeed(0.5)">0.5x</button>
                            <button class="speed-btn active" onclick="setRecordingSpeed(1)">1x</button>
                            <button class="speed-btn" onclick="setRecordingSpeed(2)">2x</button>
                            <button class="speed-btn" onclick="setRecordingSpeed(3)">3x</button>
                        </div>
                    </div>

                    <div class="mode-control">
                        <label>Mode</label>
                        <div class="mode-buttons">
                            <button class="mode-btn active" onclick="setRecordMode('normal')"> Normal</button>
                            <button class="mode-btn" onclick="setRecordMode('handsfree')"> Hands-Free</button>
                        </div>
                    </div>

                    <div class="duration-control">
                        <label>Duration</label>
                        <select id="maxDuration" class="duration-select">
                            <option value="15">15 seconds</option>
                            <option value="30">30 seconds</option>
                            <option value="60">1 minute</option>
                            <option value="180">3 minutes</option>
                            <option value="600">10 minutes</option>
                        </select>
                    </div>

                    <div class="aspect-control">
                        <label>Aspect Ratio</label>
                        <div class="aspect-buttons">
                            <button class="aspect-btn active" onclick="setAspectRatio('9:16')">9:16</button>
                            <button class="aspect-btn" onclick="setAspectRatio('1:1')">1:1</button>
                            <button class="aspect-btn" onclick="setAspectRatio('16:9')">16:9</button>
                        </div>
                    </div>
                </div>

                <!-- Bottom Recording Controls -->
                <div class="record-bottom-controls">
                    <button class="action-btn delete-btn" id="deleteLastClip" onclick="deleteLastClip()"
                        style="display:none;"> Delete</button>

                    <div class="main-controls">
                        <button class="action-btn record-btn" id="recordStartBtn" onclick="startRecording()">
                            Start</button>
                        <button class="action-btn record-btn stop-btn" id="recordStopBtn" onclick="stopRecording()"
                            style="display:none;"> Stop</button>
                    </div>

                    <button class="action-btn next-btn" id="proceedToEdit" onclick="proceedToEdit()"
                        style="display:none;"> Next</button>
                </div>

                <!-- Hands-Free Countdown -->
                <div id="countdownOverlay" class="countdown-overlay" style="display:none;">
                    <div class="countdown-number" id="countdownNumber">3</div>
                </div>
            </div>

            <!-- Editor Interface -->
            <div id="editorInterface" class="editor-interface" style="display:none;">
                <div class="editor-header">
                    <button class="back-btn" onclick="backToRecording()"> Back</button>
                    <h3>Edit Video</h3>
                </div>

                <!-- Video Preview -->
                <div class="editor-preview">
                    <video id="editorPreview" controls class="editor-video"></video>
                </div>

                <!-- Clips Timeline -->
                <div class="clips-timeline">
                    <h4>Your Clips</h4>
                    <div id="clipsTimeline" class="timeline-tracks"></div>
                </div>

                <!-- Editor Tabs -->
                <div class="editor-tabs">
                    <button class="editor-tab-btn active" onclick="switchEditorTab('trim')"> Trim</button>
                    <button class="editor-tab-btn" onclick="switchEditorTab('filters')"> Filters</button>
                    <button class="editor-tab-btn" onclick="switchEditorTab('effects')"> Effects</button>
                    <button class="editor-tab-btn" onclick="switchEditorTab('text')"> Text</button>
                    <button class="editor-tab-btn" onclick="switchEditorTab('audio')"> Audio</button>
                </div>

                <!-- Trim Tab -->
                <div id="trimTab" class="editor-tab-content active">
                    <h4>Trim Clips</h4>
                    <div id="trimControls" class="trim-controls"></div>
                </div>

                <!-- Filters Tab -->
                <div id="filtersTab" class="editor-tab-content" style="display:none;">
                    <h4>Color Filters</h4>
                    <div class="filters-grid">
                        <button class="filter-btn" onclick="applyFilter('none')">Original</button>
                        <button class="filter-btn" onclick="applyFilter('vintage')">Vintage</button>
                        <button class="filter-btn" onclick="applyFilter('cool')">Cool</button>
                        <button class="filter-btn" onclick="applyFilter('warm')">Warm</button>
                        <button class="filter-btn" onclick="applyFilter('bw')">B&W</button>
                        <button class="filter-btn" onclick="applyFilter('sepia')">Sepia</button>
                    </div>
                    <label>Brightness: <span id="brightnessValue">0</span></label>
                    <input type="range" id="brightnessSlider" min="-100" max="100" value="0"
                        onchange="applyFilterAdjustment()">
                    <label>Contrast: <span id="contrastValue">0</span></label>
                    <input type="range" id="contrastSlider" min="-100" max="100" value="0"
                        onchange="applyFilterAdjustment()">
                    <label>Saturation: <span id="saturationValue">0</span></label>
                    <input type="range" id="saturationSlider" min="-100" max="100" value="0"
                        onchange="applyFilterAdjustment()">
                </div>

                <!-- Effects Tab -->
                <div id="effectsTab" class="editor-tab-content" style="display:none;">
                    <h4>Effects & Transitions</h4>
                    <div class="effects-grid">
                        <div class="effect-category">
                            <h5>Transitions</h5>
                            <button class="effect-btn" onclick="applyTransition('swipe')">Swipe</button>
                            <button class="effect-btn" onclick="applyTransition('flash')">Flash</button>
                            <button class="effect-btn" onclick="applyTransition('glitch')">Glitch</button>
                            <button class="effect-btn" onclick="applyTransition('zoom')">Zoom</button>
                        </div>
                        <div class="effect-category">
                            <h5>On-Screen Effects</h5>
                            <button class="effect-btn" onclick="applyEffect('vibrance')">Vibrance</button>
                            <button class="effect-btn" onclick="applyEffect('motionblur')">Motion Blur</button>
                            <button class="effect-btn" onclick="applyEffect('zoom-slow')">Slow Zoom</button>
                            <button class="effect-btn" onclick="applyEffect('sparkles')">Sparkles</button>
                        </div>
                        <div class="effect-category">
                            <h5>Beauty Effects</h5>
                            <button class="effect-btn" onclick="applyEffect('smooth')">Smooth Skin</button>
                            <button class="effect-btn" onclick="applyEffect('sharpen')">Sharpen</button>
                            <button class="effect-btn" onclick="applyEffect('brighten')">Brighten</button>
                        </div>
                    </div>
                </div>

                <!-- Text Tab -->
                <div id="textTab" class="editor-tab-content" style="display:none;">
                    <h4>Add Text & Stickers</h4>
                    <div class="text-controls">
                        <input type="text" id="textInput" class="text-input" placeholder="Enter text">
                        <input type="color" id="textColor" value="#ffffff" title="Text Color">
                        <select id="textAnimation">
                            <option value="none">No Animation</option>
                            <option value="fade">Fade In</option>
                            <option value="typewriter">Typewriter</option>
                            <option value="popup">Pop In</option>
                        </select>
                        <button class="action-btn" onclick="addText()">Add Text</button>
                    </div>
                    <h5>Stickers & Emojis</h5>
                    <div class="stickers-grid" id="stickersGrid">
                        <button class="sticker-btn" onclick="addSticker('')"></button>
                        <button class="sticker-btn" onclick="addSticker('')"></button>
                        <button class="sticker-btn" onclick="addSticker('')"></button>
                        <button class="sticker-btn" onclick="addSticker('')"></button>
                        <button class="sticker-btn" onclick="addSticker('')"></button>
                        <button class="sticker-btn" onclick="addSticker('')"></button>
                        <button class="sticker-btn" onclick="addSticker('')"></button>
                        <button class="sticker-btn" onclick="addSticker('')"></button>
                    </div>
                </div>

                <!-- Audio Tab -->
                <div id="audioTab" class="editor-tab-content" style="display:none;">
                    <h4>Audio Controls</h4>
                    <div class="audio-controls">
                        <button class="action-btn" onclick="openSoundLibrary()"> Add Sound</button>
                        <button class="action-btn" onclick="extractAudio()"> Extract Sound</button>
                    </div>
                    <label>Original Video Volume: <span id="originalVolValue">100</span>%</label>
                    <input type="range" id="originalVolume" min="0" max="100" value="100"
                        onchange="adjustVolume('original')">
                    <label id="bgMusicLabel" style="display:none;">Background Music Volume: <span
                            id="bgMusicVolValue">50</span>%</label>
                    <input type="range" id="bgMusicVolume" min="0" max="100" value="50" onchange="adjustVolume('music')"
                        style="display:none;">
                </div>

                <!-- Action Buttons -->
                <div class="editor-actions">
                    <button class="action-btn" id="saveAsDraft" onclick="saveToDraft()"> Save Draft</button>
                    <button class="action-btn next-btn" onclick="proceedToPreview()"> Next</button>
                </div>
            </div>

            <!-- Pre-Posting Interface (TikTok-Style) -->
            <div id="prePostingInterface" class="pre-posting-interface" style="display:none;">
                <div class="posting-header">
                    <button class="back-btn" onclick="backToEditor()"> Back</button>
                    <h3>Post Your Video</h3>
                </div>

                <!-- Full Screen Preview -->
                <div class="posting-preview">
                    <video id="postingPreview" controls class="posting-video"></video>
                </div>

                <!-- Caption & Hashtags -->
                <div class="posting-form">
                    <div class="form-group">
                        <label>Caption</label>
                        <textarea id="recordCaption" class="text-input" rows="3"
                            placeholder="Write a caption..."></textarea>
                        <div class="caption-suggestions" id="hashtagSuggestions"></div>
                    </div>

                    <div class="form-group">
                        <label>Add Sound</label>
                        <select id="recordSound" class="text-input">
                            <option value="">Original Audio</option>
                            <option value="trending">Trending Sounds</option>
                            <option value="library">Sound Library</option>
                        </select>
                    </div>

                    <!-- Post Options -->
                    <div class="post-options">
                        <label class="option-toggle">
                            <input type="checkbox" id="recordAllowComments" checked>
                            <span>Allow Comments</span>
                        </label>
                        <label class="option-toggle">
                            <input type="checkbox" id="recordAllowSoundReuse" checked>
                            <span>Allow Sound Reuse</span>
                        </label>
                        <label class="option-toggle">
                            <input type="checkbox" id="recordAllowSave" checked>
                            <span>Allow Download</span>
                        </label>
                        <label class="option-toggle">
                            <input type="checkbox" id="recordAllowAds" checked>
                            <span>Allow Ads</span>
                        </label>
                    </div>

                    <!-- Cover Selection -->
                    <div class="form-group">
                        <label>Video Cover</label>
                        <div class="cover-selector">
                            <canvas id="coverCanvas" class="cover-preview"></canvas>
                            <div class="cover-controls">
                                <button class="action-btn" onclick="selectCoverTime()"> Select Cover</button>
                                <input type="range" id="coverTime" min="0" max="100" value="0" style="width:100%;">
                            </div>
                        </div>
                    </div>

                    <!-- Collaborators -->
                    <div class="form-group">
                        <label>Collaborators (Optional)</label>
                        <input type="text" id="recordCollaborators" class="text-input"
                            placeholder="@username @username">
                    </div>

                    <!-- Action Buttons -->
                    <div class="posting-actions">
                        <button class="action-btn draft-btn" onclick="saveToDraft()"> Save Draft</button>
                        <button class="action-btn post-btn" onclick="postRecord()"> Post Video</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tweet Preview Popup -->
    <div class="preview-popup" id="tweetPreviewPopup">
        <div class="preview-modal">
            <button class="modal-close" onclick="closeTweetPreview()"></button>
            <h2>Preview & Details</h2>

            <div class="preview-content">
                <div id="tweetPreviewMedia" class="preview-media"></div>

                <div class="form-group">
                    <label class="form-label">Caption</label>
                    <textarea id="tweetCaption" class="text-input" rows="3" placeholder="Add a caption..."></textarea>
                </div>

                <div class="form-group">
                    <label class="form-label">Hashtags</label>
                    <input type="text" id="tweetHashtags" class="text-input" placeholder="#fun #pose">
                </div>

                <div class="form-group">
                    <label class="toggle-label">
                        <span>Allow Ads</span>
                        <input type="checkbox" id="tweetAllowAds" checked>
                    </label>
                </div>

                <div class="form-group">
                    <label class="form-label">Collaborators (Optional)</label>
                    <input type="text" id="tweetCollaborators" class="text-input" placeholder="@username">
                </div>

                <div class="form-group">
                    <label class="toggle-label">
                        <span>Allow Comments</span>
                        <input type="checkbox" id="tweetAllowComments" checked>
                    </label>
                </div>

                <div class="form-group">
                    <label class="toggle-label">
                        <span>Allow Save</span>
                        <input type="checkbox" id="tweetAllowSave" checked>
                    </label>
                </div>

                <button class="done-btn" onclick="postTweet()">Post</button>
            </div>
        </div>
    </div>

    <!-- Sound Library Modal -->
    <div class="sound-library-modal" id="soundLibraryModal">
        <!-- Header -->
        <div class="sound-library-header">
            <h2> Add Sound</h2>
            <button class="sound-library-close" onclick="closeSoundLibrary()"></button>
        </div>

        <!-- Banner Ads Section -->
        <div class="sound-banner-ads">
            <div class="banner-ads-slider" id="bannerAdsSlider">
                <!-- Banner ads will be populated here -->
            </div>
            <div class="banner-indicators" id="bannerIndicators"></div>
        </div>

        <!-- Sound Tabs -->
        <div class="sound-tabs">
            <button class="sound-tab active" onclick="switchSoundTab('favourite')"> Favourite</button>
            <button class="sound-tab" onclick="switchSoundTab('yourMusic')"> Your Music</button>
            <button class="sound-tab" onclick="switchSoundTab('poseMusic')"> Pose Music</button>
            <button class="sound-tab" onclick="switchSoundTab('voiceOver')"> Voice Over</button>
        </div>

        <!-- Tab Content -->
        <!-- Favourite Tab -->
        <div class="sound-tab-content active" id="favouriteTab">
            <div class="sound-search">
                <input type="text" class="sound-search-input" placeholder="Search favourite sounds..."
                    oninput="searchSounds('favourite', this.value)">
                <span class="search-icon"></span>
            </div>
            <div class="sound-list" id="favouriteSoundList">
                <!-- Sounds will be populated here -->
            </div>
        </div>

        <!-- Your Music Tab -->
        <div class="sound-tab-content" id="yourMusicTab">
            <div style="margin-bottom: 15px;">
                <button onclick="document.getElementById('uploadMusicInput').click()"
                    style="width: 100%; padding: 12px; background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); border: none; color: white; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 14px;">
                    <i class="fas fa-upload"></i> Add Music from Device
                </button>
                <input type="file" id="uploadMusicInput" accept="audio/*" style="display: none;"
                    onchange="handleMusicFileUpload(event)">
            </div>
            <div class="sound-search">
                <input type="text" class="sound-search-input" placeholder="Search your music..."
                    oninput="searchSounds('yourMusic', this.value)">
                <span class="search-icon"></span>
            </div>
            <div class="sound-list" id="yourMusicSoundList">
                <!-- User's uploaded music will be populated here -->
            </div>
        </div>

        <!-- Pose Music Tab -->
        <div class="sound-tab-content" id="poseMusicTab">
            <!-- iTunes API Search Panel -->
            <div
                style="background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%); border-radius: 12px; padding: 20px; margin-bottom: 20px; border: 1px solid #444;">
                <h3 style="color: white; margin: 0 0 15px 0; font-size: 16px;"><i class="fas fa-search"></i> Search
                    iTunes Music</h3>

                <!-- Song/Artist Search Input -->
                <div style="margin-bottom: 15px;">
                    <input type="text" id="iTunesSongArtistSearch" placeholder="Search by song name or artist..."
                        oninput="handleSongArtistSearch()"
                        style="width: 100%; padding: 12px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 6px; font-size: 13px;">
                </div>

                <!-- Filters Grid -->
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <div>
                        <label
                            style="display: block; font-size: 12px; font-weight: 600; color: #888; margin-bottom: 6px;"><i
                                class="fas fa-music"></i> Genre</label>
                        <select id="iTunesGenreFilter" onchange="handleGenreFilterChange()"
                            style="width: 100%; padding: 10px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 6px; font-size: 12px;">
                            <option value="">Any Genre</option>
                            <option value="afrobeat">Afrobeat</option>
                            <option value="hip-hop">Hip-Hop</option>
                            <option value="pop">Pop</option>
                            <option value="r&b">R&B</option>
                            <option value="amapiano">Amapiano</option>
                            <option value="reggae">Reggae</option>
                            <option value="house">House</option>
                            <option value="gospel">Gospel</option>
                            <option value="electronic">Electronic</option>
                            <option value="jazz">Jazz</option>
                        </select>
                    </div>

                    <div>
                        <label
                            style="display: block; font-size: 12px; font-weight: 600; color: #888; margin-bottom: 6px;"><i
                                class="fas fa-globe"></i> Country/Region</label>
                        <select id="iTunesCountryFilter" onchange="handleCountryFilterChange()"
                            style="width: 100%; padding: 10px; background: #1a1a1a; border: 1px solid #444; color: white; border-radius: 6px; font-size: 12px;">
                            <option value="">Any Country</option>
                            <option value="NG">Nigeria</option>
                            <option value="GH">Ghana</option>
                            <option value="ZA">South Africa</option>
                            <option value="KE">Kenya</option>
                            <option value="UG">Uganda</option>
                            <option value="CM">Cameroon</option>
                            <option value="US">USA</option>
                            <option value="GB">UK</option>
                            <option value="CA">Canada</option>
                            <option value="AU">Australia</option>
                        </select>
                    </div>

                </div>
            </div>

            <div class="sound-list" id="poseMusicSoundList">
                <!-- Pose music library will be populated here -->
            </div>
        </div>

        <!-- Voice Over Tab -->
        <div class="sound-tab-content" id="voiceOverTab">
            <div class="voice-recorder">
                <div class="voice-visualizer" id="voiceVisualizer">
                    <span class="voice-icon"></span>
                </div>
                <div class="voice-timer" id="voiceTimer">00:00</div>
                <div class="voice-controls">
                    <button class="voice-btn record" id="voiceRecordBtn" onclick="startVoiceRecording()">
                        
                    </button>
                    <button class="voice-btn stop" id="voiceStopBtn" onclick="stopVoiceRecording()"
                        style="display:none;">
                        
                    </button>
                </div>
                <!-- Accept/Discard Buttons (shown after recording stops) -->
                <div class="voice-preview-controls" id="voicePreviewControls"
                    style="display: none; margin-top: 20px; display: flex; gap: 10px; justify-content: center;">
                    <button class="voice-preview-btn discard" onclick="discardVoiceRecording()"
                        style="padding: 12px 30px; background: #dc2626; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 14px;">
                        <i class="fas fa-times"></i> Discard
                    </button>
                    <button class="voice-preview-btn listen" onclick="previewVoiceRecording()"
                        style="padding: 12px 30px; background: #6366f1; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 14px;">
                        <i class="fas fa-play"></i> Listen
                    </button>
                    <button class="voice-preview-btn accept" onclick="acceptVoiceRecording()"
                        style="padding: 12px 30px; background: #22c55e; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 14px;">
                        <i class="fas fa-check"></i> Accept
                    </button>
                </div>
            </div>
        </div>

        <!-- Voice Recording Success Modal -->
        <div class="modal-overlay" id="voiceSuccessModal" style="display: none; z-index: 2500;">
            <div class="modal" style="max-width: 450px;">
                <button class="modal-close" onclick="closeVoiceSuccessModal()"></button>
                <div style="text-align: center; padding: 20px 0;">
                    <div style="font-size: 64px; margin-bottom: 20px;"></div>
                    <h2 style="color: white; margin: 0 0 15px 0; font-size: 20px;">Recording Saved!</h2>
                    <p style="color: #aaa; margin: 0 0 25px 0; font-size: 14px; line-height: 1.6;">Your voice over has
                        been saved to your music tab</p>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="modal-btn" onclick="useVoiceRecording()"
                        style="flex: 1; background: linear-gradient(45deg, #6366f1, #8b5cf6);">
                        <i class="fas fa-check"></i> Use
                    </button>
                    <button class="modal-btn" onclick="closeVoiceSuccessModal()"
                        style="flex: 1; background: linear-gradient(45deg, #4C1D95, #6D28D9);">
                        <i class="fas fa-check-double"></i> Done
                    </button>
                </div>
            </div>
        </div>
    </div>


    <!-- Firebase Scripts -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>

    <!-- html2canvas for capturing edited photos -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <script>
        console.log('Script loaded!');

        // Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyDW8V2SjNITrA4LcdmeILh944mTbOKnM0c",
            authDomain: "rewarderhub.firebaseapp.com",
            projectId: "rewarderhub",
            storageBucket: "rewarderhub.appspot.com",
            messagingSenderId: "85965945106",
            appId: "1:85965945106:web:fa0a57d8968926e1041bcb",
            measurementId: "G-F2ERB5NGN0"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const storage = firebase.storage();

        let currentUser = null;

        // ====== Cloudinary Config ======
        const CLOUDINARY_CLOUD_NAME = 'dzhdgxjhl';
        const CLOUDINARY_UPLOAD_PRESET = 'posepreset';
        const CLOUDINARY_API_URL = `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/auto/upload`;

        // ====== Upload Variables ======
        let postVideoUrl = null;
        let postVideoFileName = null;
        let postVideoQuality = '4k';
        let exclusiveVideoUrl = null;
        let exclusiveVideoFileName = null;
        let tweetMediaUrl = null;
        let tweetMediaFileName = null;

        let isPostVideoUploading = false;
        let isExclusiveVideoUploading = false;
        let isTweetMediaUploading = false;

        // Auth State Listener
        auth.onAuthStateChanged((user) => {
            if (user) {
                currentUser = user;
                console.log(' User logged in:', user.uid);
                loadUserProfile(user.uid);
            } else {
                currentUser = null;
                console.log(' User logged out');
            }
        });

        // Debug: Log function availability
        console.log(' Functions loaded:', {
            postTweet: typeof window.postTweet,
            uploadPost: typeof window.uploadPost,
            postExclusive: typeof window.postExclusive
        });

        // ====== CLOUDINARY UPLOAD (REPLACED - use uploadToCloudinaryWithProgress instead) ======

        // ====== VIDEO COMPRESSION FUNCTION ======
        async function compressVideo(file, quality = '4k') {
            const MAX_SIZE_GB = 8;
            const MAX_SIZE_BYTES = MAX_SIZE_GB * 1024 * 1024 * 1024;

            if (file.size <= MAX_SIZE_BYTES) {
                console.log(' Video within size limit, no compression needed');
                return { file: file, compressed: false, originalSize: file.size, compressedSize: file.size };
            }

            console.log(` Video size: ${(file.size / (1024 ** 3)).toFixed(2)}GB - Compressing...`);

            // Note: Actual video compression requires FFmpeg (server-side recommended)
            // For now, we'll use Cloudinary's transformations
            return {
                file: file,
                compressed: true,
                originalSize: file.size,
                compressedSize: MAX_SIZE_BYTES,
                quality: quality
            };
        }

        // ====== AUTO-UPLOAD FUNCTION (Handles Post & Tweet) ======
        function autoUploadVideo(fileInput, uploadType) {
            if (!currentUser) {
                alert('Please login first');
                return;
            }

            const file = fileInput.files[0];
            if (!file) return;

            // Show upload UI based on type
            if (uploadType === 'post') {
                showPostUploadUI();
            } else if (uploadType === 'tweet') {
                showTweetUploadUI();
            }

            // Start upload in background
            startUploadProcess(file, uploadType);
        }

        // ====== UPLOAD PROCESS (WITH PROGRESS TRACKING) ======
        async function startUploadProcess(file, uploadType) {
            try {
                // Show progress container
                showUploadProgress();

                let statusElement = null;
                if (uploadType === 'post') {
                    statusElement = document.getElementById('postUploadStatus');
                } else if (uploadType === 'tweet') {
                    statusElement = document.getElementById('tweetUploadStatus');
                }

                const sizeGB = (file.size / (1024 ** 3)).toFixed(2);
                const sizeMB = (file.size / (1024 ** 2)).toFixed(2);
                const needsCompression = sizeGB > 4.5;

                // ====== STEP 1: ANALYZE ======
                updateStepProgress(1, `Analyzing ${sizeMB}MB...`, 0, true);
                await new Promise(resolve => setTimeout(resolve, 800));
                updateStepProgress(1, ` Format: ${file.type.split('/')[1].toUpperCase()}`, 100);

                // ====== STEP 2: OPTIMIZE ======
                updateStepProgress(2, needsCompression ? 'Compressing...' : 'No compression needed', 0, true);

                if (needsCompression) {
                    // Simulate compression (actual compression would happen here)
                    const compressionSteps = [30, 60, 100];
                    for (let progress of compressionSteps) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                        const compressedSize = (file.size * (1 - (progress / 100) * 0.3)).toFixed(2);
                        updateStepProgress(2, `Optimizing: ${compressedSize}MB`, progress);
                    }
                    updateStepProgress(2, `Optimized from ${sizeGB}GB to 4.5GB`, 100);
                } else {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    updateStepProgress(2, `Video ready: ${sizeMB}MB`, 100);
                }

                // ====== STEP 3: UPLOAD ======
                updateStepProgress(3, `Uploading...`, 0, true);

                const result = await uploadToCloudinaryWithProgress(file, uploadType, postVideoQuality);

                if (uploadType === 'post') {
                    postVideoUrl = result.url;
                    postVideoFileName = result.fileName;
                } else if (uploadType === 'tweet') {
                    tweetMediaUrl = result.url;
                    tweetMediaFileName = result.fileName;
                }

                // Complete upload step
                updateStepProgress(3, ` Uploaded successfully`, 100);

                // Update overall progress
                document.getElementById('overallBarFill').style.width = '100%';
                document.getElementById('uploadProgressTitle').textContent = 'Complete!';

                if (statusElement) {
                    statusElement.innerHTML = ` Ready to post`;
                }

                console.log(` ${uploadType} ready:`, result.url);

                // Hide progress after 2 seconds
                setTimeout(() => {
                    hideUploadProgress();
                }, 2000);

            } catch (error) {
                console.error(`Error uploading ${uploadType}:`, error);
                updateStepProgress(3, ` Upload failed`, 0);
                alert(` Upload failed: ${error.message}`);
                setTimeout(() => {
                    hideUploadProgress();
                }, 2000);
            }
        }

        // ====== UPLOAD WITH PROGRESS TRACKING ======
        async function uploadToCloudinaryWithProgress(file, uploadType, quality = '4k') {
            if (!currentUser || !file) return null;

            const fileName = `${Date.now()}_${file.name}`;
            const formData = new FormData();
            formData.append('file', file);
            formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
            formData.append('tags', `${uploadType},${currentUser.uid}`);
            formData.append('folder', uploadType);

            console.log(' Upload Config:', {
                cloudName: CLOUDINARY_CLOUD_NAME,
                uploadPreset: CLOUDINARY_UPLOAD_PRESET,
                uploadUrl: CLOUDINARY_API_URL,
                fileSize: (file.size / (1024 * 1024)).toFixed(2) + ' MB'
            });

            try {
                return new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();

                    // Timeout after 60 seconds
                    const timeoutId = setTimeout(() => {
                        xhr.abort();
                        reject(new Error('Upload timeout - took too long'));
                    }, 60000);

                    // Track progress
                    xhr.upload.addEventListener('progress', (e) => {
                        if (e.lengthComputable) {
                            const percentComplete = (e.loaded / e.total) * 100;
                            updateUploadStats(e.loaded, e.total);
                            updateStepProgress(3, `Uploading... ${Math.round(percentComplete)}%`, percentComplete);
                            console.log(` Upload progress: ${Math.round(percentComplete)}%`);
                        }
                    });

                    xhr.addEventListener('load', () => {
                        clearTimeout(timeoutId);
                        console.log(` XHR Load event, status: ${xhr.status}`);

                        if (xhr.status === 200) {
                            try {
                                const data = JSON.parse(xhr.responseText);
                                console.log(' Upload successful:', data.secure_url);
                                resolve({
                                    url: data.secure_url,
                                    fileName: fileName,
                                    publicId: data.public_id
                                });
                            } catch (parseError) {
                                console.error(' JSON parse error:', parseError);
                                reject(new Error('Invalid response from Cloudinary'));
                            }
                        } else {
                            console.error(` Upload failed with status ${xhr.status}:`, xhr.responseText);
                            reject(new Error(`Upload failed: ${xhr.status} - ${xhr.statusText}`));
                        }
                    });

                    xhr.addEventListener('error', () => {
                        clearTimeout(timeoutId);
                        console.error(' Network error during upload');
                        reject(new Error('Network error - check your connection'));
                    });

                    xhr.addEventListener('abort', () => {
                        clearTimeout(timeoutId);
                        console.error(' Upload aborted');
                        reject(new Error('Upload was cancelled'));
                    });

                    console.log(' Starting upload to:', CLOUDINARY_API_URL);
                    xhr.open('POST', CLOUDINARY_API_URL, true);
                    xhr.send(formData);
                });

            } catch (error) {
                console.error(` ${uploadType} upload error:`, error);
                throw error;
            }
        }

        // ====== UI HELPERS ======
        function showPostUploadUI() {
            const uploadSection = document.getElementById('postUploadSection');
            if (uploadSection) {
                uploadSection.style.display = 'block';
            }
        }

        function showTweetUploadUI() {
            const uploadSection = document.getElementById('tweetUploadSection');
            if (uploadSection) {
                uploadSection.style.display = 'block';
            }
        }

        function setPostQuality(quality) {
            postVideoQuality = quality;
            document.querySelectorAll('.post-quality-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.quality === quality);
            });
        }

        // ====== UPLOAD PROGRESS TRACKER ======
        const uploadProgress = {
            startTime: 0,
            totalSize: 0,
            uploadedSize: 0,
            lastUpdate: 0,
            uploadSpeed: 0
        };

        function showUploadProgress() {
            const container = document.getElementById('uploadProgressContainer');
            container.classList.add('active');
            container.classList.remove('collapsed');
            resetUploadProgress();
        }

        function hideUploadProgress() {
            const container = document.getElementById('uploadProgressContainer');
            container.classList.remove('active');
        }

        // ====== PRICE OPTIONS ======
        function setPostPrice(priceInPc, priceType) {
            document.getElementById('postPrice').value = priceInPc * 25; // Convert PC to Naira (1 PC = 25 Naira)
            document.getElementById('postPriceType').value = priceType;

            // Update button states
            document.querySelectorAll('.price-btn').forEach(btn => btn.classList.remove('active'));
            if (priceType === 'free') {
                document.getElementById('priceFreBtn').classList.add('active');
            } else if (priceType === '1pc') {
                document.getElementById('price1pcBtn').classList.add('active');
            } else if (priceType === '2pc') {
                document.getElementById('price2pcBtn').classList.add('active');
            }

            console.log(`Price set: ${priceType} (${priceInPc} PC = ${priceInPc * 25})`);
        }

        // ====== TIKTOK-STYLE COUNTDOWN ======
        let tiktokCountdownTimer = null;
        let onCountdownComplete = null;

        function showTiktokCountdown(duration = 5, callback = null) {
            const modal = document.getElementById('tiktokCountdownModal');
            const numberDisplay = document.getElementById('countdownNumberDisplay');

            modal.classList.add('active');
            onCountdownComplete = callback;

            let remaining = duration;
            numberDisplay.textContent = remaining;

            tiktokCountdownTimer = setInterval(() => {
                remaining--;

                if (remaining > 0) {
                    numberDisplay.textContent = remaining;
                } else {
                    clearInterval(tiktokCountdownTimer);
                    modal.classList.remove('active');
                    if (onCountdownComplete) {
                        onCountdownComplete();
                    }
                }
            }, 1000);
        }

        function hideTiktokCountdown() {
            const modal = document.getElementById('tiktokCountdownModal');
            modal.classList.remove('active');
            if (tiktokCountdownTimer) {
                clearInterval(tiktokCountdownTimer);
            }
        }

        // ====== UPLOAD RESULT MODAL ======
        let countdownTimer = null;

        function showUploadResultModal(isSuccess, title, message, thumbnailUrl = null) {
            const modal = document.getElementById('uploadResultModal');
            const resultTitle = document.getElementById('uploadResultTitle');
            const resultMessage = document.getElementById('uploadResultMessage');
            const resultThumbnail = document.getElementById('uploadResultThumbnail');
            const countdownSection = document.getElementById('uploadResultCountdown');

            resultTitle.textContent = title;
            resultMessage.textContent = message;
            resultMessage.className = `upload-result-message ${isSuccess ? 'success' : 'error'}`;

            if (thumbnailUrl) {
                resultThumbnail.innerHTML = `<img src="${thumbnailUrl}" alt="thumbnail">`;
            } else {
                resultThumbnail.innerHTML = isSuccess ? '' : '';
            }

            modal.classList.add('active');

            // TikTok countdown already happened, so just hide this countdown section
            countdownSection.style.display = 'none';
        }

        function startCountdown(seconds) {
            // Clear any existing timer
            if (countdownTimer) clearInterval(countdownTimer);

            let remaining = seconds;
            const countdownNumber = document.getElementById('countdownNumber');
            const countdownBarFill = document.getElementById('countdownBarFill');

            countdownNumber.textContent = remaining;
            countdownBarFill.style.width = '100%';

            countdownTimer = setInterval(() => {
                remaining--;
                countdownNumber.textContent = remaining;

                // Update progress bar (width decreases)
                const percentRemaining = (remaining / seconds) * 100;
                countdownBarFill.style.width = percentRemaining + '%';

                if (remaining <= 0) {
                    clearInterval(countdownTimer);
                    closeUploadResultModal();
                }
            }, 1000);
        }

        function closeUploadResultModal() {
            const modal = document.getElementById('uploadResultModal');
            modal.classList.remove('active');
            if (countdownTimer) clearInterval(countdownTimer);
        }

        // ===== PROFESSIONAL UPLOAD PROGRESS MODAL =====
        function showUploadProgressModal() {
            const modal = document.getElementById('uploadProgressModal');
            if (modal) {
                modal.classList.add('active');
                // Reset progress
                updateUploadProgressModal(0, 'Uploading Video', '', 'Starting upload...');
            }
        }

        function closeUploadProgressModal() {
            const modal = document.getElementById('uploadProgressModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        function updateUploadProgressModal(percent, title, icon, subtitle, speed, eta) {
            const modal = document.getElementById('uploadProgressModal');
            if (!modal) return;

            // Update progress bar
            const progressBar = document.getElementById('uploadProgressBarFill');
            if (progressBar) {
                progressBar.style.width = percent + '%';
            }

            // Update title
            const titleEl = document.getElementById('uploadProgressTitle');
            if (titleEl) {
                titleEl.textContent = title;
            }

            // Update icon
            const iconEl = document.getElementById('uploadProgressIcon');
            if (iconEl) {
                iconEl.textContent = icon;
                if (percent >= 100) {
                    iconEl.classList.remove('uploading');
                    iconEl.classList.add('upload-progress-success');
                } else {
                    iconEl.classList.add('uploading');
                    iconEl.classList.remove('upload-progress-success');
                }
            }

            // Update subtitle
            const subtitleEl = document.getElementById('uploadProgressSubtitle');
            if (subtitleEl) {
                subtitleEl.textContent = subtitle;
            }

            // Update percentage
            const percentEl = document.getElementById('uploadProgressPercent');
            if (percentEl) {
                percentEl.textContent = Math.round(percent) + '%';
            }

            // Update speed if provided
            if (speed !== undefined) {
                const speedEl = document.getElementById('uploadProgressSpeed');
                if (speedEl) {
                    speedEl.textContent = speed + ' MB/s';
                }
            }

            // Update size if provided
            if (subtitle && subtitle.includes('MB')) {
                const sizeEl = document.getElementById('uploadProgressSize');
                if (sizeEl) {
                    sizeEl.textContent = subtitle;
                }
            }

            // Update ETA if provided
            if (eta !== undefined) {
                const etaEl = document.getElementById('uploadProgressETA');
                if (etaEl) {
                    if (eta === 0 || percent >= 100) {
                        etaEl.textContent = 'Done!';
                    } else if (eta > 60) {
                        etaEl.textContent = Math.ceil(eta / 60) + 'm';
                    } else {
                        etaEl.textContent = eta + 's';
                    }
                }
            }
        }

        function resetUploadProgress() {
            uploadProgress.startTime = Date.now();
            uploadProgress.uploadedSize = 0;
            uploadProgress.lastUpdate = Date.now();
            uploadProgress.uploadSpeed = 0;

            // Reset all steps
            ['step1', 'step2', 'step3'].forEach(step => {
                document.getElementById(`${step}Icon`).className = 'step-icon pending';
                document.getElementById(`${step}Bar`).classList.remove('active');
                document.getElementById(`${step}Bar`).querySelector('.step-bar-fill').style.width = '0%';
            });

            document.getElementById('overallBarFill').style.width = '0%';
            document.getElementById('uploadElapsedTime').textContent = '0s';
            document.getElementById('uploadStats').textContent = '0 MB / 0 MB';
            document.getElementById('uploadSpeed').textContent = '0 MB/s';
        }

        function updateStepProgress(stepNum, label, progress, isActive = false) {
            const stepIcon = document.getElementById(`step${stepNum}Icon`);
            const stepProgress = document.getElementById(`step${stepNum}Progress`);
            const stepBar = document.getElementById(`step${stepNum}Bar`);
            const stepBarFill = stepBar.querySelector('.step-bar-fill');

            if (isActive) {
                stepIcon.className = 'step-icon active';
                stepBar.classList.add('active');
            }

            stepProgress.textContent = label;
            stepBarFill.style.width = progress + '%';

            if (progress === 100) {
                stepIcon.className = 'step-icon completed';
                stepIcon.innerHTML = '';
            }
        }

        function updateUploadStats(uploadedBytes, totalBytes) {
            uploadProgress.uploadedSize = uploadedBytes;
            uploadProgress.totalSize = totalBytes;

            const now = Date.now();
            const timeDiff = (now - uploadProgress.lastUpdate) / 1000; // seconds
            const bytesDiff = uploadedBytes - (uploadProgress.uploadedSize - (uploadedBytes % 1000));

            if (timeDiff > 0) {
                uploadProgress.uploadSpeed = (bytesDiff / timeDiff) / (1024 * 1024); // MB/s
                uploadProgress.lastUpdate = now;
            }

            const elapsedSeconds = Math.floor((now - uploadProgress.startTime) / 1000);
            const uploadedMB = (uploadedBytes / (1024 * 1024)).toFixed(2);
            const totalMB = (totalBytes / (1024 * 1024)).toFixed(2);
            const percentComplete = Math.round((uploadedBytes / totalBytes) * 100);

            document.getElementById('uploadElapsedTime').textContent = elapsedSeconds + 's';
            document.getElementById('uploadStats').textContent = `${uploadedMB} MB / ${totalMB} MB`;
            document.getElementById('uploadSpeed').textContent = uploadProgress.uploadSpeed.toFixed(1) + ' MB/s';

            // Update overall progress
            const overallPercent = (percentComplete * 0.5) + 33; // Assume 33% for analyze + optimize
            document.getElementById('overallBarFill').style.width = overallPercent + '%';
        }

        // Handle Profile Icon Click
        function handleProfileClick() {
            if (currentUser) {
                openProfile();
            } else {
                openAuthModal();
            }
        }

        // Open Auth Modal
        function openAuthModal() {
            document.getElementById('authModal').classList.add('active');
        }

        // Close Auth Modal
        function closeAuthModal() {
            document.getElementById('authModal').classList.remove('active');
            document.getElementById('authError').style.display = 'none';
            document.getElementById('loginError').style.display = 'none';
        }

        // Switch to Login
        function switchToLogin() {
            document.getElementById('signupForm').style.display = 'none';
            document.getElementById('loginForm').style.display = 'block';
        }

        // Switch to Signup
        function switchToSignup() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('signupForm').style.display = 'block';
        }

        // Handle Signup
        async function handleSignup() {
            const name = document.getElementById('signupName').value.trim();
            const username = document.getElementById('signupUsername').value.trim();
            const email = document.getElementById('signupEmail').value.trim();
            const password = document.getElementById('signupPassword').value;

            if (!name || !username || !email || !password) {
                showError('authError', 'Please fill in all fields');
                return;
            }

            if (password.length < 6) {
                showError('authError', 'Password must be at least 6 characters');
                return;
            }

            try {
                // Create user
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                const user = userCredential.user;

                // Save user profile to Firestore
                await db.collection('users').doc(user.uid).set({
                    name: name,
                    username: username,
                    email: email,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    followers: 0,
                    following: 0,
                    likes: 0,
                    views: 0,
                    earnings: 0
                });

                closeAuthModal();
                openProfile();
            } catch (error) {
                showError('authError', error.message);
            }
        }

        // Handle Login
        async function handleLogin() {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;

            if (!email || !password) {
                showError('loginError', 'Please fill in all fields');
                return;
            }

            try {
                await auth.signInWithEmailAndPassword(email, password);
                closeAuthModal();
                openProfile();
            } catch (error) {
                showError('loginError', error.message);
            }
        }

        // Show Error
        function showError(elementId, message) {
            const errorEl = document.getElementById(elementId);
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        // Load User Profile
        async function loadUserProfile(uid) {
            try {
                const doc = await db.collection('users').doc(uid).get();
                if (doc.exists) {
                    const userData = doc.data();
                    document.getElementById('profileDisplayName').textContent = userData.name;
                    document.getElementById('profileUsernameDisplay').textContent = '@' + userData.username;
                    document.getElementById('profilePicLarge').textContent = userData.name.charAt(0).toUpperCase();
                }
            } catch (error) {
                console.error('Error loading profile:', error);
            }
        }

        // Open Profile
        function openProfile() {
            document.getElementById('profilePage').classList.add('active');
        }

        // Close Profile
        function closeProfile() {
            document.getElementById('profilePage').classList.remove('active');
        }

        // Logout
        async function logout() {
            if (confirm('Are you sure you want to logout?')) {
                await auth.signOut();
                closeProfile();
            }
        }

        // Switch Profile Tab
        // ====== PROFILE TAB MANAGEMENT ======
        function switchProfileTab(tabName) {
            // Update tab active state
            const tabs = document.querySelectorAll('.profile-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            // Hide all tab content
            document.querySelectorAll('.profile-tab-content').forEach(content => {
                content.style.display = 'none';
            });

            // Show selected tab and load content
            const tabElement = document.getElementById(tabName + 'Tab');
            if (tabElement) {
                tabElement.style.display = 'block';

                // Load content for each tab
                if (currentUser) {
                    switch (tabName) {
                        case 'feed':
                            loadProfileFeed();
                            break;
                        case 'exclusive':
                            loadExclusiveVideos();
                            break;
                        case 'shorts':
                            loadShortVideos();
                            break;
                        case 'tweets':
                            loadProfileTweets();
                            break;
                        case 'liked':
                            loadLikedContent();
                            break;
                        case 'stories':
                            loadStories();
                            break;
                    }
                }
            }
        }

        // Load all posted videos (Feed)
        async function loadProfileFeed() {
            if (!currentUser) return;

            try {
                const feedGrid = document.getElementById('feedGrid');
                feedGrid.innerHTML = '<div class="loading">Loading feed...</div>';

                const snapshot = await db.collection('posts')
                    .where('userId', '==', currentUser.uid)
                    .where('type', '==', 'video')
                    .orderBy('createdAt', 'desc')
                    .limit(12)
                    .get();

                feedGrid.innerHTML = '';

                if (snapshot.empty) {
                    feedGrid.innerHTML = '<div class="empty-state">No videos posted yet</div>';
                    return;
                }

                snapshot.forEach(doc => {
                    const data = doc.data();
                    const videoItem = createVideoItem(doc.id, data);
                    feedGrid.appendChild(videoItem);
                });
            } catch (error) {
                console.error('Error loading feed:', error);
                document.getElementById('feedGrid').innerHTML = '<div class="error">Error loading feed</div>';
            }
        }

        // Load exclusive (paid) videos
        async function loadExclusiveVideos() {
            if (!currentUser) return;

            try {
                const exclusiveGrid = document.getElementById('exclusiveGrid');
                exclusiveGrid.innerHTML = '<div class="loading">Loading exclusive content...</div>';

                const snapshot = await db.collection('posts')
                    .where('userId', '==', currentUser.uid)
                    .where('type', '==', 'video')
                    .where('isExclusive', '==', true)
                    .where('price', '>', 0)
                    .orderBy('createdAt', 'desc')
                    .get();

                exclusiveGrid.innerHTML = '';

                if (snapshot.empty) {
                    exclusiveGrid.innerHTML = '<div class="empty-state">No exclusive content yet</div>';
                    return;
                }

                snapshot.forEach(doc => {
                    const data = doc.data();
                    const videoItem = createExclusiveVideoItem(doc.id, data);
                    exclusiveGrid.appendChild(videoItem);
                });
            } catch (error) {
                console.error('Error loading exclusive videos:', error);
                document.getElementById('exclusiveGrid').innerHTML = '<div class="error">Error loading exclusive content</div>';
            }
        }

        // Load short videos (5-15 seconds)
        async function loadShortVideos() {
            if (!currentUser) return;

            try {
                const shortsGrid = document.getElementById('shortsGrid');
                shortsGrid.innerHTML = '<div class="loading">Loading shorts...</div>';

                const snapshot = await db.collection('posts')
                    .where('userId', '==', currentUser.uid)
                    .where('type', '==', 'video')
                    .where('duration', '>=', 5)
                    .where('duration', '<=', 15)
                    .orderBy('createdAt', 'desc')
                    .get();

                shortsGrid.innerHTML = '';

                if (snapshot.empty) {
                    shortsGrid.innerHTML = '<div class="empty-state">No shorts created yet</div>';
                    return;
                }

                snapshot.forEach(doc => {
                    const data = doc.data();
                    const videoItem = createVideoItem(doc.id, data);
                    shortsGrid.appendChild(videoItem);
                });
            } catch (error) {
                console.error('Error loading shorts:', error);
                document.getElementById('shortsGrid').innerHTML = '<div class="error">Error loading shorts</div>';
            }
        }

        // Load profile tweets
        async function loadProfileTweets() {
            if (!currentUser) return;

            try {
                const tweetsContainer = document.getElementById('tweetsContainer');
                tweetsContainer.innerHTML = '<div class="loading">Loading tweets...</div>';

                const snapshot = await db.collection('posts')
                    .where('userId', '==', currentUser.uid)
                    .where('type', '==', 'tweet')
                    .orderBy('createdAt', 'desc')
                    .limit(20)
                    .get();

                tweetsContainer.innerHTML = '';

                if (snapshot.empty) {
                    tweetsContainer.innerHTML = '<div class="empty-state">No tweets yet</div>';
                    return;
                }

                snapshot.forEach(doc => {
                    const data = doc.data();
                    const tweetElement = createTweetElement(doc.id, data);
                    tweetsContainer.appendChild(tweetElement);
                });
            } catch (error) {
                console.error('Error loading tweets:', error);
                document.getElementById('tweetsContainer').innerHTML = '<div class="error">Error loading tweets</div>';
            }
        }

        // Load liked content
        async function loadLikedContent() {
            if (!currentUser) return;

            try {
                const likedGrid = document.getElementById('likedGrid');
                likedGrid.innerHTML = '<div class="loading">Loading liked content...</div>';

                const userLikesDoc = await db.collection('users').doc(currentUser.uid).get();
                const likedIds = userLikesDoc.data()?.likedPosts || [];

                if (likedIds.length === 0) {
                    likedGrid.innerHTML = '<div class="empty-state">No liked posts yet</div>';
                    return;
                }

                likedGrid.innerHTML = '';

                // Fetch liked posts in chunks
                for (let i = 0; i < likedIds.length; i += 10) {
                    const chunk = likedIds.slice(i, i + 10);
                    const snapshot = await db.collection('posts')
                        .where(firebase.firestore.FieldPath.documentId(), 'in', chunk)
                        .get();

                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const videoItem = createVideoItem(doc.id, data);
                        likedGrid.appendChild(videoItem);
                    });
                }
            } catch (error) {
                console.error('Error loading liked content:', error);
                document.getElementById('likedGrid').innerHTML = '<div class="error">Error loading liked content</div>';
            }
        }

        // Load stories
        async function loadStories() {
            if (!currentUser) return;

            try {
                const storiesContainer = document.getElementById('storiesContainer');
                storiesContainer.innerHTML = '<div class="loading">Loading stories...</div>';

                const snapshot = await db.collection('posts')
                    .where('userId', '==', currentUser.uid)
                    .where('type', '==', 'story')
                    .orderBy('createdAt', 'desc')
                    .get();

                storiesContainer.innerHTML = '';

                if (snapshot.empty) {
                    storiesContainer.innerHTML = '<div class="empty-state">No stories created yet</div>';
                    return;
                }

                snapshot.forEach(doc => {
                    const data = doc.data();
                    const storyElement = createStoryElement(doc.id, data);
                    storiesContainer.appendChild(storyElement);
                });
            } catch (error) {
                console.error('Error loading stories:', error);
                document.getElementById('storiesContainer').innerHTML = '<div class="error">Error loading stories</div>';
            }
        }

        // Create video item with interactions
        function createVideoItem(postId, data) {
            const item = document.createElement('div');
            item.className = 'video-item';
            item.innerHTML = `
                <div class="video-thumbnail" style="position: relative; height: 100%; background: ${data.thumbnailGradient || 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'} center/cover;">
                    ${data.thumbnail ? `<img src="${data.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;">` : ''}
                    <div class="video-overlay">
                        <div class="play-btn"></div>
                    </div>
                </div>
                <div class="video-stats">
                    <span> ${data.comments || 0}</span>
                    <span> ${data.views || 0}</span>
                    <span> ${data.likes || 0}</span>
                </div>
                <div class="video-actions">
                    <button class="action-btn" onclick="likePost('${postId}')"> Like</button>
                    <button class="action-btn" onclick="commentOnPost('${postId}')"> Comment</button>
                    <button class="action-btn" onclick="sharePost('${postId}')"> Share</button>
                    <button class="action-btn" onclick="downloadPost('${postId}')"> Download</button>
                </div>
            `;
            return item;
        }

        // Create exclusive video item
        function createExclusiveVideoItem(postId, data) {
            const item = document.createElement('div');
            item.className = 'video-item';
            item.innerHTML = `
                <div class="video-thumbnail exclusive-lock" style="position: relative; height: 100%; background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); display: flex; align-items: center; justify-content: center;">
                    <div style="text-align: center;">
                        <div style="font-size: 40px; margin-bottom: 10px;"></div>
                        <div style="color: white; font-weight: bold;">${data.price || 0}</div>
                    </div>
                </div>
                <div class="video-stats">
                    <span> ${data.comments || 0}</span>
                    <span> ${data.views || 0}</span>
                </div>
            `;
            return item;
        }

        // Create tweet element
        function createTweetElement(postId, data) {
            const createdAt = data.createdAt ? new Date(data.createdAt.toDate()).toLocaleDateString() : 'Just now';
            const tweet = document.createElement('div');
            tweet.className = 'profile-tweet-item';
            tweet.innerHTML = `
                <div class="tweet-header">
                    <div class="tweet-avatar"></div>
                    <div>
                        <div class="tweet-author">${data.authorName || 'Anonymous'}</div>
                        <div class="tweet-time">${createdAt}</div>
                    </div>
                </div>
                <div class="tweet-text">${data.text || ''}</div>
                ${data.media ? `<div class="tweet-media"><img src="${data.media}" style="max-width: 100%; border-radius: 10px;"></div>` : ''}
                <div class="tweet-actions">
                    <button class="tweet-action-btn" onclick="likeTweet('${postId}')"> ${data.likes || 0}</button>
                    <button class="tweet-action-btn" onclick="commentTweet('${postId}')"> ${data.comments || 0}</button>
                    <button class="tweet-action-btn" onclick="retweet('${postId}')"> ${data.retweets || 0}</button>
                    <button class="tweet-action-btn" onclick="sharePost('${postId}')"> Share</button>
                </div>
            `;
            return tweet;
        }

        // Create story element
        function createStoryElement(postId, data) {
            const story = document.createElement('div');
            story.className = 'story-item';
            story.style.cssText = `
                background: ${data.thumbnail ? `url(${data.thumbnail}) center/cover` : 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'};
                border-radius: 15px;
                aspect-ratio: 9/16;
                cursor: pointer;
                position: relative;
                overflow: hidden;
            `;
            story.innerHTML = `
                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center;">
                    <div style="text-align: center; color: white;">
                        <div style="font-size: 30px;"></div>
                        <div style="margin-top: 10px; font-size: 12px;">View Story</div>
                    </div>
                </div>
            `;
            story.onclick = () => viewStory(postId);
            return story;
        }

        // Post new tweet
        async function postNewTweet() {
            if (!currentUser) {
                alert('Please login first');
                return;
            }

            const text = document.getElementById('profileTweetInput').value.trim();
            if (!text) {
                alert('Please type something');
                return;
            }

            try {
                await db.collection('posts').add({
                    userId: currentUser.uid,
                    type: 'tweet',
                    text: text,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    likes: 0,
                    comments: 0,
                    retweets: 0,
                    authorName: (await db.collection('users').doc(currentUser.uid).get()).data().name
                });

                document.getElementById('profileTweetInput').value = '';
                showToast(' Tweet posted!', 'success');
                loadProfileTweets();
            } catch (error) {
                console.error('Error posting tweet:', error);
                showToast('Error posting tweet', 'error');
            }
        }

        // Interaction functions
        async function likePost(postId) {
            if (!currentUser) return;
            try {
                const postRef = db.collection('posts').doc(postId);
                const userRef = db.collection('users').doc(currentUser.uid);

                const postData = (await postRef.get()).data();
                const userData = (await userRef.get()).data() || {};

                const likedPosts = userData.likedPosts || [];
                if (likedPosts.includes(postId)) {
                    likedPosts.splice(likedPosts.indexOf(postId), 1);
                    await postRef.update({ likes: Math.max(0, (postData.likes || 1) - 1) });
                } else {
                    likedPosts.push(postId);
                    await postRef.update({ likes: (postData.likes || 0) + 1 });
                }

                await userRef.update({ likedPosts: likedPosts });
                showToast(' Updated!', 'success');
                loadProfileFeed();
            } catch (error) {
                console.error('Error liking post:', error);
            }
        }

        async function sharePost(postId) {
            const shareText = `Check out this post on Pose!\n${window.location.href}#post/${postId}`;
            if (navigator.share) {
                navigator.share({ text: shareText });
            } else {
                const textarea = document.createElement('textarea');
                textarea.value = shareText;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showToast(' Copied to clipboard!', 'success');
            }
        }

        async function downloadPost(postId) {
            showToast(' Download started', 'info');
            // Implementation depends on video/media URL
        }

        function commentOnPost(postId) {
            const comment = prompt('Write your comment:');
            if (comment && currentUser) {
                db.collection('posts').doc(postId).update({
                    comments: firebase.firestore.FieldValue.increment(1)
                });
                showToast(' Comment added!', 'success');
            }
        }

        function likeTweet(postId) {
            likePost(postId);
        }

        function commentTweet(postId) {
            commentOnPost(postId);
        }

        function retweet(postId) {
            showToast(' Retweeted!', 'success');
        }

        function viewStory(storyId) {
            alert('Opening story: ' + storyId);
        }

        function attachMediaToTweet() {
            alert('Media attachment feature coming soon');
        }

        // Original Video Feed Scripts
        const allTabs = document.querySelectorAll('.tabs span');
        allTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                allTabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
            });
        });

        function setupVideoControls() {
            const posts = document.querySelectorAll('.video-post');

            posts.forEach(post => {
                const video = post.querySelector('video');
                const playPauseOverlay = post.querySelector('.play-pause-overlay');
                const playIcon = post.querySelector('.play-icon');
                const pauseIcon = post.querySelector('.pause-icon');

                post.addEventListener('click', (e) => {
                    if (e.target.closest('.sidebar') || e.target.closest('.follow-btn') || e.target.closest('.close-btn')) {
                        return;
                    }

                    if (video.paused) {
                        video.play();
                        playIcon.style.display = 'none';
                        pauseIcon.style.display = 'block';
                    } else {
                        video.pause();
                        playIcon.style.display = 'block';
                        pauseIcon.style.display = 'none';
                    }

                    playPauseOverlay.classList.add('show');
                    setTimeout(() => {
                        playPauseOverlay.classList.remove('show');
                    }, 500);
                });

                video.addEventListener('play', () => {
                    playIcon.style.display = 'none';
                    pauseIcon.style.display = 'block';
                });

                video.addEventListener('pause', () => {
                    playIcon.style.display = 'block';
                    pauseIcon.style.display = 'none';
                });
            });
        }

        const posts = document.querySelectorAll('.video-post video');
        function handleVideoPlay() {
            posts.forEach(video => {
                const rect = video.getBoundingClientRect();
                if (rect.top >= 0 && rect.bottom <= window.innerHeight) {
                    if (video.paused) {
                        video.play();
                    }
                } else {
                    if (!video.paused) {
                        video.pause();
                    }
                }
            });
        }

        document.querySelector('.video-feed').addEventListener('scroll', () => {
            clearTimeout(window.scrollTimeout);
            window.scrollTimeout = setTimeout(handleVideoPlay, 100);
        });
        handleVideoPlay();

        document.querySelectorAll('.close-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const banner = btn.parentElement;
                const overlay = banner.closest('.overlay');
                const profileSection = overlay.querySelector('.profile-section');
                const adCaption = overlay.querySelector('.ad-caption');

                banner.classList.add('hidden');
                profileSection.classList.add('ad-closed');
                adCaption.classList.add('ad-closed');

                setTimeout(() => {
                    banner.style.display = 'none';
                }, 300);
            });
        });

        document.querySelectorAll('.follow-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (btn.textContent === 'FOLLOW') {
                    btn.textContent = 'FOLLOWING';
                    btn.style.background = 'rgba(255, 255, 255, 0.2)';
                    btn.style.border = '1px solid rgba(255, 255, 255, 0.5)';
                } else {
                    btn.textContent = 'FOLLOW';
                    btn.style.background = 'linear-gradient(45deg, #ff0050, #ff4081)';
                    btn.style.border = 'none';
                }
            });
        });

        setupVideoControls();

        document.querySelectorAll('.sidebar div').forEach(item => {
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                item.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    item.style.transform = 'scale(1)';
                }, 150);
            });
        });


        // Global variable to store profile picture
        let uploadedProfilePic = null;

        // Toast notification function for better UX
        function showToast(message, type = 'info') {
            // Remove existing toast
            const existingToast = document.getElementById('toast-notification');
            if (existingToast) {
                existingToast.remove();
            }

            const toast = document.createElement('div');
            toast.id = 'toast-notification';

            let bgColor = '#333';
            let borderColor = '#666';

            if (type === 'success') {
                bgColor = '#10b981';
                borderColor = '#059669';
            } else if (type === 'error') {
                bgColor = '#ef4444';
                borderColor = '#dc2626';
            }

            toast.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: ${bgColor};
    color: white;
    padding: 15px 20px;
    border-radius: 8px;
    border-left: 4px solid ${borderColor};
    z-index: 9999;
    max-width: 300px;
    font-weight: 600;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    animation: slideInRight 0.3s ease;
  `;

            toast.textContent = message;
            document.body.appendChild(toast);

            // Add animation
            const style = document.createElement('style');
            if (!document.getElementById('toast-animation')) {
                style.id = 'toast-animation';
                style.textContent = `
      @keyframes slideInRight {
        from {
          transform: translateX(400px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      @keyframes slideOutRight {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(400px);
          opacity: 0;
        }
      }
      @keyframes zoomIn {
        from {
          transform: scale(0.8);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }
      `;
                document.head.appendChild(style);
            }

            // Auto remove after 4 seconds
            setTimeout(() => {
                toast.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => {
                    toast.remove();
                }, 300);
            }, 4000);
        }

        // Update the profile icon when user logs in or profile picture changes
        function updateProfileIcon(profilePicUrl, userName) {
            const profileIcon = document.querySelector('.profile-icon');

            if (!profileIcon) return;

            if (profilePicUrl && profilePicUrl.trim()) {
                // If user has profile picture, show it
                const img = document.createElement('img');
                img.src = profilePicUrl;
                img.style.cssText = 'width: 100%; height: 100%; border-radius: 50%; object-fit: cover; display: block;';
                img.alt = 'profile';

                // Clear and add new image
                profileIcon.innerHTML = '';
                profileIcon.appendChild(img);

                console.log('Profile icon updated with image:', profilePicUrl);
            } else {
                // If no picture, show initial letter
                const initial = userName ? userName.charAt(0).toUpperCase() : 'U';
                profileIcon.innerHTML = `
      <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; color: white;">
        ${initial}
      </div>
    `;

                console.log('Profile icon updated with initial:', initial);
            }
        }

        // Handle profile picture file selection
        document.getElementById('profilePicInput').addEventListener('change', async function (e) {
            const file = e.target.files[0];
            if (!file) return;

            // Show preview
            const reader = new FileReader();
            reader.onload = function (event) {
                const previewPic = document.getElementById('previewPic');
                previewPic.style.backgroundImage = `url(${event.target.result})`;
                previewPic.style.backgroundSize = 'cover';
                previewPic.style.backgroundPosition = 'center';
                previewPic.textContent = '';
            };
            reader.readAsDataURL(file);
        });

        // Open Settings Modal
        function openSettings() {
            if (!currentUser) {
                showToast('Please login first', 'error');
                return;
            }

            // Load current user data into form
            db.collection('users').doc(currentUser.uid).get().then(doc => {
                if (doc.exists) {
                    const data = doc.data();
                    document.getElementById('editName').value = data.name || '';
                    document.getElementById('editUsername').value = data.username || '';
                    document.getElementById('editBio').value = data.bio || '';
                    document.getElementById('editLocation').value = data.location || '';

                    // Show profile picture if exists
                    const previewPic = document.getElementById('previewPic');
                    if (data.profilePicUrl && data.profilePicUrl.trim()) {
                        previewPic.style.backgroundImage = `url(${data.profilePicUrl})`;
                        previewPic.style.backgroundSize = 'cover';
                        previewPic.style.backgroundPosition = 'center';
                        previewPic.style.backgroundColor = 'transparent';
                        previewPic.textContent = '';
                    } else {
                        previewPic.style.backgroundImage = 'none';
                        previewPic.style.backgroundColor = '#333';
                        previewPic.textContent = (data.name || 'U').charAt(0).toUpperCase();
                    }
                } else {
                    showToast('Profile not found', 'error');
                }
            }).catch(error => {
                console.error('Error loading profile:', error);
                showToast('Error loading profile', 'error');
            });

            document.getElementById('settingsModal').classList.add('active');
        }

        // Close Settings Modal
        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
            document.getElementById('settingsError').style.display = 'none';
        }

        // Save Profile Changes - Base64 Image Version
        async function saveProfile() {
            if (!currentUser) {
                showToast('Please login first', 'error');
                return;
            }

            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'Saving...';
            btn.disabled = true;

            try {
                const userData = {
                    name: document.getElementById('editName').value.trim(),
                    username: document.getElementById('editUsername').value.trim(),
                    bio: document.getElementById('editBio').value.trim(),
                    location: document.getElementById('editLocation').value.trim(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                // Handle profile picture if selected
                const picInput = document.getElementById('profilePicInput');
                if (picInput.files && picInput.files[0]) {
                    btn.textContent = 'Processing image...';
                    const file = picInput.files[0];

                    // Convert image to base64
                    const base64String = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });

                    userData.profilePicUrl = base64String;

                    // Update profile picture in UI immediately
                    document.getElementById('profilePicLarge').style.backgroundImage = `url(${base64String})`;
                    document.getElementById('profilePicLarge').style.backgroundSize = 'cover';
                    document.getElementById('profilePicLarge').style.backgroundPosition = 'center';
                    document.getElementById('profilePicLarge').textContent = '';

                    // Update profile icon
                    updateProfileIcon(base64String, userData.name);
                }

                // Update display name and username in profile
                document.getElementById('profileDisplayName').textContent = userData.name;
                document.getElementById('profileUsernameDisplay').textContent = '@' + userData.username;

                // Update bio display
                const bioDiv = document.querySelector('.profile-bio');
                if (bioDiv) {
                    bioDiv.innerHTML = `${userData.bio}<br> ${userData.location}`;
                }

                btn.textContent = 'Saving...';

                // Save to Firestore (use set with merge to create if doesn't exist)
                await db.collection('users').doc(currentUser.uid).set(userData, { merge: true });

                showToast(' Profile updated successfully!', 'success');

                // Clear file input
                picInput.value = '';

                setTimeout(() => {
                    closeSettings();
                }, 1500);

            } catch (error) {
                console.error('Error saving profile:', error);
                showToast('Error: ' + error.message, 'error');
                showError('settingsError', 'Error saving profile: ' + error.message);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        // REPLACE your existing loadUserProfile function with this:
        async function loadUserProfile(uid) {
            try {
                const doc = await db.collection('users').doc(uid).get();
                if (doc.exists) {
                    const userData = doc.data();

                    // Update profile page
                    document.getElementById('profileDisplayName').textContent = userData.name;
                    document.getElementById('profileUsernameDisplay').textContent = '@' + userData.username;

                    // Update profile icon at top
                    updateProfileIcon(userData.profilePicUrl, userData.name);

                    // Load profile picture on profile page
                    const profilePicLarge = document.getElementById('profilePicLarge');
                    if (userData.profilePicUrl) {
                        profilePicLarge.style.backgroundImage = `url(${userData.profilePicUrl})`;
                        profilePicLarge.style.backgroundSize = 'cover';
                        profilePicLarge.style.backgroundPosition = 'center';
                        profilePicLarge.textContent = '';
                    } else {
                        profilePicLarge.style.backgroundImage = 'none';
                        profilePicLarge.textContent = userData.name.charAt(0).toUpperCase();
                    }

                    // Load bio and location
                    const bioDiv = document.querySelector('.profile-bio');
                    if (bioDiv) {
                        bioDiv.innerHTML = `${userData.bio || 'African Creator | Exclusive Content '}<br> ${userData.location || 'Lagos, Nigeria'}`;
                    }
                }
            } catch (error) {
                console.error('Error loading profile:', error);
            }
        }

        // REPLACE your existing auth.onAuthStateChanged with this:
        auth.onAuthStateChanged((user) => {
            if (user) {
                currentUser = user;
                loadUserProfile(user.uid);
            } else {
                currentUser = null;
                // Reset profile icon to default when logged out
                const profileIcon = document.querySelector('.profile-icon');
                profileIcon.innerHTML = `
      <svg width="22" height="22" viewBox="0 0 24 24" fill="white">
        <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
      </svg>
    `;
            }
        });
        // Tab Switching Function
        function switchMainTab(tabName) {
            // Remove active class from all tabs
            const allTabs = document.querySelectorAll('.tabs .tab');
            allTabs.forEach(tab => tab.classList.remove('active'));

            // Add active class to clicked tab
            event.target.classList.add('active');

            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });

            // Show selected tab content
            const selectedTab = document.getElementById(tabName);
            if (selectedTab) {
                selectedTab.classList.add('active');
                selectedTab.style.display = 'block';
            }

            // Pause all videos when switching tabs
            document.querySelectorAll('video').forEach(video => {
                video.pause();
            });

            // If switching to video feed, restart video playback logic
            if (tabName === 'busTab') {
                setTimeout(handleVideoPlay, 300);
            }
        }

        // Initialize Tab Click Listeners
        document.addEventListener('DOMContentLoaded', function () {
            const tabs = document.querySelectorAll('.tabs .tab');
            tabs.forEach((tab, index) => {
                tab.addEventListener('click', function () {
                    if (index === 0) switchMainTab('busTab');      // Bus = Video Feed
                    if (index === 1) switchMainTab('friendTab');   // Friend = Tweet Feed
                    if (index === 2) switchMainTab('poseTab');     // Pose = Video Grid
                    if (index === 3) switchMainTab('busTab');      // fyp = Video Feed (for now)
                });
            });
        });

        // Updated Tab Switching Function with Scroll Reset
        function switchMainTab(tabName) {
            // Remove active class from all tabs
            const allTabs = document.querySelectorAll('.tabs .tab');
            allTabs.forEach(tab => tab.classList.remove('active'));

            // Add active class to clicked tab
            event.target.classList.add('active');

            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });

            // Show selected tab content
            const selectedTab = document.getElementById(tabName);
            if (selectedTab) {
                selectedTab.classList.add('active');
                selectedTab.style.display = 'block';

                // Scroll to top of the new tab
                selectedTab.scrollTop = 0;
            }

            // Pause all videos when switching tabs
            document.querySelectorAll('video').forEach(video => {
                video.pause();
            });

            // If switching to video feed, restart video playback logic
            if (tabName === 'busTab') {
                setTimeout(handleVideoPlay, 300);
            }
        }

        // Add smooth scroll behavior to load more buttons
        document.addEventListener('DOMContentLoaded', function () {
            // Tab switching
            const tabs = document.querySelectorAll('.tabs .tab');
            tabs.forEach((tab, index) => {
                tab.addEventListener('click', function () {
                    if (index === 0) switchMainTab('busTab');      // Bus = Video Feed
                    if (index === 1) switchMainTab('friendTab');   // Friend = Tweet Feed
                    if (index === 2) switchMainTab('poseTab');     // Pose = Video Grid
                    if (index === 3) switchMainTab('busTab');      // fyp = Video Feed
                });
            });

            // Load more button scroll effect
            document.querySelectorAll('.load-more-btn').forEach(btn => {
                btn.addEventListener('click', function () {
                    // Add loading animation or fetch more content here
                    this.textContent = 'Loading... ';
                    setTimeout(() => {
                        this.textContent = this.closest('#poseTab') ? 'Load More Videos ' : 'Show More Posts ';
                    }, 1000);
                });
            });
        });


        // Check if user is new and show welcome popup
        function checkAndShowWelcomePopup() {
            // Check if user has visited before
            const hasVisited = localStorage.getItem('poseVisited');

            // Check if user is logged in
            if (!currentUser && !hasVisited) {
                document.getElementById('welcomePopup').classList.remove('hidden');
            }
        }

        // Close welcome popup
        function closeWelcomePopup() {
            document.getElementById('welcomePopup').classList.add('hidden');
            localStorage.setItem('poseVisited', 'true');
        }

        // Open signup from welcome popup
        function openSignupFromWelcome() {
            closeWelcomePopup();
            // Switch to signup form
            document.getElementById('signupForm').style.display = 'block';
            document.getElementById('loginForm').style.display = 'none';
            openAuthModal();
        }

        // Open login from welcome popup
        function openLoginFromWelcome() {
            closeWelcomePopup();
            // Switch to login form
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('signupForm').style.display = 'none';
            openAuthModal();
        }

        // Update auth.onAuthStateChanged to check welcome popup
        auth.onAuthStateChanged((user) => {
            if (user) {
                currentUser = user;
                loadUserProfile(user.uid);
                // Close welcome popup if user logs in
                closeWelcomePopup();
            } else {
                currentUser = null;
                // Reset profile icon to default when logged out
                const profileIcon = document.querySelector('.profile-icon');
                profileIcon.innerHTML = `
      <svg width="22" height="22" viewBox="0 0 24 24" fill="white">
        <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
      </svg>
    `;
            }
        });

        // Call this when page loads (add to your DOMContentLoaded)
        document.addEventListener('DOMContentLoaded', function () {
            // Existing code...

            // Show welcome popup after short delay
            setTimeout(checkAndShowWelcomePopup, 500);
        });


        // Open Upload Page
        function openUploadPage() {
            document.getElementById('uploadPage').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        // Close Upload Page
        function closeUploadPage() {
            document.getElementById('uploadPage').classList.remove('active');
            document.body.style.overflow = 'auto';
        }

        // Switch Upload Tabs
        function switchUploadTab(tabName) {
            // Remove active from all tabs
            document.querySelectorAll('.upload-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Add active to clicked tab
            event.target.classList.add('active');

            // Hide all tab contents
            document.querySelectorAll('.tab-content-upload').forEach(content => {
                content.classList.remove('active');
            });

            // Show selected tab
            if (tabName === 'tweet') {
                document.getElementById('tweetTab').classList.add('active');
            } else if (tabName === 'post') {
                document.getElementById('postTab').classList.add('active');
            } else if (tabName === 'record') {
                document.getElementById('recordTab').classList.add('active');
                initializeRecordTab();
            }
        }

        // ====== RECORD TAB VARIABLES ====== 
        let recordingState = {
            isRecording: false,
            mediaRecorder: null,
            mediaStream: null,
            stream: null,
            clips: [],
            currentSpeed: 1,
            currentMode: 'normal',
            maxDuration: 30,
            selectedDuration: 30,  // NEW: Selected duration for recording
            aspectRatio: '9:16',
            recordingTime: 0,
            timerInterval: null,
            timerPaused: false,
            cameraFacingMode: 'user',
            audioContext: null,
            analyser: null,
            beautyLevel: 0,
            sharpenLevel: 0,
            currentFilter: 'none',
            filterAdjustments: { brightness: 0, contrast: 0, saturation: 0 },
            selectedEffects: [],
            textOverlays: [],
            audioTracks: [],
            mergedVideo: null,
            videoCameraInitialized: false,
            recordingTimer: 0,  // 0, 3, 5, 10 seconds
            recordingStartTime: null,
            recordedBlob: null,
            // Canvas-based recording properties
            isCanvasRendering: false,
            recordingCanvas: null,
            canvasContext: null,
            canvasWidth: 0,
            canvasHeight: 0,
            // Screen 3 Sound properties
            selectedSound: null,
            videoOriginalVolume: 1,
            // Background audio during recording
            backgroundAudio: null,
            audioContext: null
        };

        // ====== VIDEO CAMERA INITIALIZATION (SCREEN 1) - TIKTOK OPTIMIZED ======
        async function initializeVideoCamera() {
            try {
                if (recordingState.videoCameraInitialized && recordingState.stream?.active) {
                    console.log(' Video camera already active');
                    return;
                }

                console.log(' Initializing camera (Responsive mode)...');

                // RESPONSIVE CAMERA: Adapt resolution based on device
                let videoWidth = 480;
                let videoHeight = 360;

                // Mobile optimization
                if (window.innerWidth <= 480) {
                    videoWidth = 360;
                    videoHeight = 270;
                } else if (window.innerWidth <= 768) {
                    videoWidth = 640;
                    videoHeight = 480;
                } else {
                    videoWidth = 1280;
                    videoHeight = 720;
                }

                const constraints = {
                    video: {
                        facingMode: recordingState.cameraFacingMode,
                        width: { ideal: 1920, max: 1920 },
                        height: { ideal: 1080, max: 1080 },
                        frameRate: { ideal: 30, max: 30 }
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 48000,
                        channelCount: 2
                    }
                };

                recordingState.stream = await navigator.mediaDevices.getUserMedia(constraints);
                const videoElement = document.getElementById('videoPreview');

                if (videoElement) {
                    videoElement.srcObject = recordingState.stream;

                    videoElement.onloadedmetadata = () => {
                        videoElement.play().catch(err => console.warn('Auto-play:', err));
                    };

                    setUpPreviewFilterUpdates();
                    recordingState.videoCameraInitialized = true;
                    recordingState.hasActiveEffects = false;

                    const errorOverlay = document.getElementById('videoCameraInitError');
                    if (errorOverlay) {
                        errorOverlay.style.display = 'none';
                    }

                    console.log(' Camera ready (1920x1080 Full HD @ 30fps - optimized for smooth recording)');
                    showToastRecording(' Ready to record', 'success', '');
                }
            } catch (error) {
                console.error(' Camera error:', error.name, error.message);

                const errorOverlay = document.getElementById('videoCameraInitError');
                if (errorOverlay) {
                    errorOverlay.style.display = 'flex';
                }

                if (error.name === 'NotAllowedError') {
                    showToastRecording(' Allow camera access', 'error', '');
                } else if (error.name === 'NotFoundError') {
                    showToastRecording(' No camera found', 'error', '');
                } else if (error.name === 'NotReadableError') {
                    showToastRecording(' Camera in use', 'error', '');
                }
            }
        }

        function setUpPreviewFilterUpdates() {
            // Apply filters that MATCH the canvas recording filters (pixel-based)
            const videoElement = document.getElementById('videoPreview');
            if (!videoElement) return;

            const updatePreviewFilter = () => {
                // Use CSS filters that closely approximate the pixel-based canvas filters
                let filterString = 'none';

                if (recordingState.currentFilter && recordingState.currentFilter !== 'none') {
                    // These CSS filters are carefully matched to the canvas pixel algorithms
                    const filterMap = {
                        'none': 'none',
                        'bw': 'grayscale(100%)',  // Matches luminosity: r*0.299 + g*0.587 + b*0.114
                        'sepia': 'sepia(100%)',   // Browser sepia matches our calculation
                        'vintage': 'sepia(100%) brightness(80%) saturate(80%)',  // Sepia + reduced brightness + saturation (0.9 multiplier)
                        'vivid': 'saturate(200%) contrast(120%)',  // Increased saturation and contrast (1.5x saturation boost)
                        'warm': 'brightness(110%) saturate(105%) hue-rotate(5deg)',  // R*1.1, G*1.05, warmer tone
                        'cool': 'brightness(95%) saturate(90%) hue-rotate(-15deg)'  // R*0.95, B*1.15, cooler tone
                    };
                    filterString = filterMap[recordingState.currentFilter] || 'none';
                }

                const adjustments = recordingState.filterAdjustments || {};
                let brightness = parseFloat(adjustments.brightness) || 0;
                let contrast = parseFloat(adjustments.contrast) || 0;
                let saturation = parseFloat(adjustments.saturation) || 0;

                // Match canvas filter multiplier (x2) for consistency
                brightness = brightness * 2;
                contrast = contrast * 2;
                saturation = saturation * 2;

                if (brightness !== 0 || contrast !== 0 || saturation !== 0) {
                    const brightnessPercent = 100 + brightness;
                    const contrastPercent = 100 + contrast;
                    const saturationPercent = 100 + saturation;
                    const adjustmentString = `brightness(${brightnessPercent}%) contrast(${contrastPercent}%) saturate(${saturationPercent}%)`;
                    filterString = filterString === 'none' ? adjustmentString : `${filterString} ${adjustmentString}`;
                }

                videoElement.style.filter = filterString;
                console.log(` Preview filter updated: ${filterString}`);
            };

            // Initial update
            updatePreviewFilter();

            // Listen for filter changes
            recordingState.previewFilterCallback = updatePreviewFilter;
        }

        // Stop video camera
        function stopVideoCamera() {
            if (recordingState.stream) {
                recordingState.stream.getTracks().forEach(track => track.stop());
                recordingState.stream = null;
                recordingState.videoCameraInitialized = false;
                console.log(' Video camera stopped');
            }
        }

        // Toggle camera facing (front/back)
        async function toggleVideoCameraFacing() {
            stopVideoCamera();
            recordingState.cameraFacingMode = recordingState.cameraFacingMode === 'user' ? 'environment' : 'user';
            const mode = recordingState.cameraFacingMode === 'user' ? 'Front' : 'Back';
            showToastRecording(` Switched to ${mode} camera`, 'info', '');
            await initializeVideoCamera();
        }

        // ====== INITIALIZE RECORD TAB ======
        async function initializeRecordTab() {
            try {
                if (!recordingState.stream) {
                    const constraints = {
                        video: {
                            facingMode: recordingState.cameraFacingMode,
                            width: { ideal: 1280, max: 1280 },
                            height: { ideal: 720, max: 720 },
                            frameRate: { ideal: 24, max: 24 }
                        },
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 48000,
                            channelCount: 2
                        }
                    };

                    recordingState.stream = await navigator.mediaDevices.getUserMedia(constraints);
                    const videoElement = document.getElementById('cameraPreview');
                    videoElement.srcObject = recordingState.stream;
                }
            } catch (error) {
                console.error('Camera error:', error);
                alert('Please allow camera and microphone access');
            }
        }

        // ====== RECORDING CONTROLS - TIKTOK SPEED OPTIMIZATION ======

        async function recordVideo() {
            // Check if duration is selected
            if (!recordingState.selectedDuration || recordingState.selectedDuration <= 0) {
                showToastRecording(' Select duration first', 'warning', '');
                toggleRecordingDuration();
                return;
            }

            if (!recordingState.stream) {
                showToastRecording(' Camera not available', 'error', '');
                return;
            }

            recordingState.isRecording = true;
            recordingState.timerPaused = false;
            recordingState.recordingTime = 0;
            recordingState.recordingStartTime = Date.now();
            recordingState.maxDuration = recordingState.selectedDuration;

            const chunks = [];

            // ===== DIRECT CAMERA STREAM RECORDING (NO CANVAS LAG) =====
            // Record directly from camera for smooth quality like TikTok
            console.log(` Recording directly from camera stream (smooth, no lag)`);

            // Get video stream directly from camera
            const videoStream = recordingState.stream;
            const recordingStream = new MediaStream();

            // ===== ADD VIDEO TRACKS =====
            // Add all video tracks from camera directly to recording stream
            videoStream.getVideoTracks().forEach(track => {
                recordingStream.addTrack(track);
            });
            console.log(' Video tracks added directly from camera');

            // ===== AUDIO SETUP: Use background music OR microphone (not both) =====
            let finalStream = recordingStream;

            if (recordingState.selectedSound) {
                // Background music selected - Record ONLY music audio
                console.log(' Recording with background music ONLY (no microphone)');

                try {
                    // Use preloaded audio (already fetched and decoded)
                    let audioBuffer = recordingState.preloadedAudioBuffer;
                    let audioContext = recordingState.preloadedAudioContext;

                    // If not preloaded yet, create fresh (fallback)
                    if (!audioBuffer || !audioContext) {
                        console.log(' Audio not preloaded, creating fresh context...');
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const audioResponse = await fetch(recordingState.selectedSound.url);
                        const audioBlob = await audioResponse.blob();
                        audioBuffer = await audioContext.decodeAudioData(await audioBlob.arrayBuffer());
                    } else {
                        console.log(' Using preloaded audio (no lag!)');
                    }

                    recordingState.audioContext = audioContext;

                    // Step 1: Create destination to capture audio
                    const destination = audioContext.createMediaStreamDestination();

                    // Step 5: Prepare audio source (don't start yet)
                    let audioSource = audioContext.createBufferSource();
                    audioSource.buffer = audioBuffer;
                    audioSource.loop = true;  // Loop the audio

                    const gain = audioContext.createGain();
                    gain.gain.value = 1.0;  // 100% volume

                    audioSource.connect(gain);
                    gain.connect(destination);  // Connect to video recording
                    gain.connect(audioContext.destination);  // IMPORTANT: Also connect to speakers so user can HEAR it!
                    console.log(' Audio source connected to destination AND speakers (NOT STARTED YET)');

                    // Step 6: Add the mixed audio stream to canvas
                    const audioTracks = destination.stream.getAudioTracks();
                    if (audioTracks.length > 0) {
                        recordingStream.addTrack(audioTracks[0]);
                        console.log(' Music audio track added to video - WILL BE SAVED');
                    } else {
                        console.log(' No audio track in destination');
                    }

                    // Step 7: Store references for delayed start (1 second after recording starts)
                    recordingState.audioSource = audioSource;
                    recordingState.audioContext = audioContext;
                    recordingState.audioDestination = destination;
                    recordingState.audioStartPending = true;  // Flag for delayed start

                } catch (error) {
                    console.error(' Music audio setup error:', error);
                    console.log(' Recording video only (no music audio - error occurred)');
                }

            } else {
                // No music - Record ONLY microphone audio
                console.log(' Recording with microphone ONLY (no background music)');

                const audioTracks = recordingState.stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    recordingStream.addTrack(audioTracks[0]);
                    console.log(' Microphone audio added to video');
                } else {
                    console.log(' No microphone available');
                }
            }

            finalStream = recordingStream;

            console.log(' Recording setup complete - Ready to record');

            const options = {
                mimeType: 'video/webm;codecs=vp8,opus',
                videoBitsPerSecond: 800000,   // 800 kbps for 720p 24fps (smooth)
                audioBitsPerSecond: 96000     // 96 kbps audio
            };

            try {
                recordingState.mediaRecorder = new MediaRecorder(finalStream, options);
            } catch (e) {
                recordingState.mediaRecorder = new MediaRecorder(finalStream);
            }

            recordingState.mediaRecorder.ondataavailable = (event) => {
                chunks.push(event.data);
            };

            recordingState.mediaRecorder.onstop = () => {
                // Stop background audio
                if (recordingState.backgroundAudio) {
                    recordingState.backgroundAudio.pause();
                    recordingState.backgroundAudio.currentTime = 0;
                    recordingState.backgroundAudio = null;
                }

                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);

                recordingState.clips.push({
                    url: url,
                    blob: blob,
                    duration: recordingState.recordingTime,
                    speed: recordingState.currentSpeed,
                    hasEffects: recordingState.selectedEffects.length > 0 || recordingState.currentFilter !== 'none',
                    hasBackgroundSound: recordingState.selectedSound ? true : false,
                    selectedSound: recordingState.selectedSound
                });

                recordingState.recordedBlob = blob;
                updateUIAfterRecording(false);

                const soundInfo = recordingState.selectedSound ? `with "${recordingState.selectedSound.title}"` : '';
                showToastRecording(` Recording saved ${soundInfo}`, 'success', '');

                // Stop canvas rendering
                recordingState.isCanvasRendering = false;

                // Mark that onstop has been called
                recordingState.mediaRecorderStopped = true;
            };

            recordingState.mediaRecorder.start();
            updateUIAfterRecording(true);

            const soundMessage = recordingState.selectedSound ? ` "${recordingState.selectedSound.title}"` : '';
            showToastRecording(`${soundMessage} Recording started...`, 'success', '');

            // ===== DELAYED AUDIO START (1 second after recording starts) =====
            if (recordingState.audioStartPending && recordingState.audioSource) {
                console.log(' Waiting 1 second before starting audio (to prevent lag)...');
                setTimeout(() => {
                    if (recordingState.audioSource && recordingState.isRecording) {
                        recordingState.audioSource.start(0);
                        console.log(' Background music started playing (1 sec delayed)');
                        recordingState.audioStartPending = false;
                    }
                }, 1000);  // 1 second delay
            }

            // No canvas rendering needed - recording directly from camera
            startRecordingTimer();
        }

        // ===== CANVAS RENDERING LOOP FOR RECORDING =====
        // ===== OPTIMIZED: Convert filter to CSS instead of pixel manipulation =====
        function getFilterString(filterName, adjustments = {}) {
            let filters = [];

            switch (filterName) {
                case 'bw':
                    filters.push('grayscale(100%)');
                    break;
                case 'sepia':
                    filters.push('sepia(100%)');
                    break;
                case 'vintage':
                    filters.push('sepia(70%)');
                    filters.push('brightness(90%)');
                    break;
                case 'cool':
                    filters.push('hue-rotate(30deg)');
                    filters.push('saturate(120%)');
                    break;
                case 'warm':
                    filters.push('hue-rotate(-30deg)');
                    filters.push('saturate(120%)');
                    break;
                case 'vivid':
                    filters.push('contrast(130%)');
                    filters.push('saturate(150%)');
                    break;
            }

            // Apply adjustments (GPU-accelerated)
            if (adjustments.brightness) {
                filters.push(`brightness(${100 + adjustments.brightness * 2}%)`);
            }
            if (adjustments.contrast) {
                filters.push(`contrast(${100 + adjustments.contrast * 2}%)`);
            }
            if (adjustments.saturation) {
                filters.push(`saturate(${100 + adjustments.saturation * 2}%)`);
            }

            return filters.join(' ');
        }

        // Apply CSS filter to video preview (GPU-accelerated, NO pixel operations)
        function applyFilterToPreview(filterName, adjustments = {}) {
            const videoElement = document.getElementById('videoPreview');
            if (!videoElement) return;

            const filterString = getFilterString(filterName, adjustments);
            videoElement.style.filter = filterString;

            console.log(' GPU Filter applied:', filterName, '- Smooth 60fps preview');
        }

        function renderCanvasForRecording() {
            if (!recordingState.isCanvasRendering) return;

            const ctx = recordingState.canvasContext;
            const canvas = recordingState.recordingCanvas;
            const videoElement = document.getElementById('videoPreview');

            // Draw video frame to canvas (video already has CSS filter applied for smooth preview)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);

            // NOTE: Filters now applied via CSS (GPU-accelerated) on the video element
            // This removes the heavy pixel-by-pixel processing that was causing lag
            // The canvas just captures the already-filtered frame

            // OPTIMIZATION: Skip effects during recording to reduce lag
            // Effects are more for preview - during actual recording we just capture the video
            // If you want effects, comment out these lines:
            // if (recordingState.selectedEffects && recordingState.selectedEffects.length > 0) {
            //     renderRecordingEffects(ctx, canvas, recordingState.selectedEffects);
            // }

            // Continue rendering next frame
            requestAnimationFrame(renderCanvasForRecording);
        }

        // ===== APPLY FILTERS TO CANVAS =====
        function applyCanvasFilter(ctx, canvas, filterName, adjustments) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            switch (filterName) {
                case 'bw':
                    // Black & White
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        data[i] = gray;
                        data[i + 1] = gray;
                        data[i + 2] = gray;
                    }
                    break;

                case 'sepia':
                    // Sepia tone
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                        data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                        data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
                    }
                    break;

                case 'vivid':
                    // Increase saturation
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const max = Math.max(r, g, b);
                        const min = Math.min(r, g, b);
                        const l = (max + min) / 2;
                        const s = (max - min) / 255;
                        const saturation = Math.min(255, s * 255 * 1.5);

                        data[i] = Math.min(255, r + (r - l) * 0.5);
                        data[i + 1] = Math.min(255, g + (g - l) * 0.5);
                        data[i + 2] = Math.min(255, b + (b - l) * 0.5);
                    }
                    break;

                case 'warm':
                    // Warm (orange tint)
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * 1.1);     // Increase red
                        data[i + 1] = Math.min(255, data[i + 1] * 1.05); // Slight green increase
                        // Blue stays same for warm effect
                    }
                    break;

                case 'cool':
                    // Cool (blue tint)
                    for (let i = 0; i < data.length; i += 4) {
                        // Red decreases slightly
                        data[i] = Math.max(0, data[i] * 0.95);
                        // Blue increases
                        data[i + 2] = Math.min(255, data[i + 2] * 1.15);
                    }
                    break;

                case 'vintage':
                    // Vintage (sepia + reduced brightness)
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        data[i] = Math.max(0, Math.min(255, (r * 0.393 + g * 0.769 + b * 0.189) * 0.9));
                        data[i + 1] = Math.max(0, Math.min(255, (r * 0.349 + g * 0.686 + b * 0.168) * 0.9));
                        data[i + 2] = Math.max(0, Math.min(255, (r * 0.272 + g * 0.534 + b * 0.131) * 0.9));
                    }
                    break;
            }

            // Apply brightness/contrast adjustments
            const brightness = (adjustments.brightness || 0) * 2;
            const contrast = (adjustments.contrast || 0) * 2;
            const saturation = (adjustments.saturation || 0) * 2;

            if (brightness !== 0 || contrast !== 0 || saturation !== 0) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, Math.max(0, data[i] * (1 + contrast / 100) + brightness));
                    data[i + 1] = Math.min(255, Math.max(0, data[i + 1] * (1 + contrast / 100) + brightness));
                    data[i + 2] = Math.min(255, Math.max(0, data[i + 2] * (1 + contrast / 100) + brightness));
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // ===== RECORDING EFFECTS - Use same individual effect functions as preview =====

        // Call the appropriate effect rendering function based on selected effect
        function renderRecordingEffects(ctx, canvas, selectedEffects) {
            if (!selectedEffects || selectedEffects.length === 0) return;

            const effectType = selectedEffects[0];

            // Delegate to the specific effect renderer based on effect type
            switch (effectType) {
                // Particle Effects
                case 'sparkle':
                    renderSparkleEffectToCanvas(ctx, canvas);
                    break;
                case 'hearts':
                    renderHeartsEffectToCanvas(ctx, canvas);
                    break;
                case 'confetti':
                    renderConfettiEffectToCanvas(ctx, canvas);
                    break;
                case 'star':
                    renderStarEffectToCanvas(ctx, canvas);
                    break;
                case 'snow':
                    renderSnowEffectToCanvas(ctx, canvas);
                    break;
                case 'flowers':
                    renderFlowersEffectToCanvas(ctx, canvas);
                    break;
                // Light & Glow Effects
                case 'glow':
                    renderGlowEffectToCanvas(ctx, canvas);
                    break;
                case 'bokeh':
                    renderBokehEffectToCanvas(ctx, canvas);
                    break;
                case 'rainbow':
                    renderRainbowEffectToCanvas(ctx, canvas);
                    break;
                case 'sunbeam':
                    renderSunbeamEffectToCanvas(ctx, canvas);
                    break;
                // Distortion Effects
                case 'wave':
                    renderWaveEffectToCanvas(ctx, canvas);
                    break;
                case 'kaleidoscope':
                    renderKaleidoscopeEffectToCanvas(ctx, canvas);
                    break;
                case 'pixelate':
                    renderPixelateEffectToCanvas(ctx, canvas);
                    break;
                case 'fisheye':
                    renderFisheyeEffectToCanvas(ctx, canvas);
                    break;
                // Retro/Film Effects
                case 'vhs':
                    renderVHSEffectToCanvas(ctx, canvas);
                    break;
                case 'glitch':
                    renderGlitchEffectToCanvas(ctx, canvas);
                    break;
                case 'filmburn':
                    renderFilmBurnEffectToCanvas(ctx, canvas);
                    break;
                case 'scanlines':
                    renderScanlinesEffectToCanvas(ctx, canvas);
                    break;
                // Neon & Vibrant Effects
                case 'neon':
                    renderNeonEffectToCanvas(ctx, canvas);
                    break;
                case 'cyberpunk':
                    renderCyberpunkEffectToCanvas(ctx, canvas);
                    break;
                case 'vaporwave':
                    renderVaporwaveEffectToCanvas(ctx, canvas);
                    break;
                // Mood Effects
                case 'ghost':
                    renderGhostEffectToCanvas(ctx, canvas);
                    break;
                case 'mask':
                    renderMaskEffectToCanvas(ctx, canvas);
                    break;
                case 'dreamy':
                    renderDreamyEffectToCanvas(ctx, canvas);
                    break;
                case 'noir':
                    renderNoirEffectToCanvas(ctx, canvas);
                    break;
                // Clone & Mirror Effects
                case 'mirror':
                    renderMirrorEffectToCanvas(ctx, canvas);
                    break;
                case 'clone':
                    renderCloneEffectToCanvas(ctx, canvas);
                    break;
                // AFCON Face Effect
                case 'afcon':
                    renderAFCONEffectToCanvas(ctx, canvas);
                    break;
                default:
                    break;
            }
        }

        // ===== INDIVIDUAL EFFECT RENDERERS FOR RECORDING =====
        let recordingSparkles = [];

        function renderSparkleEffectToCanvas(ctx, canvas) {
            const timestamp = Date.now();

            // Add new sparkles
            if (Math.random() > 0.7) {
                recordingSparkles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 3 + 1,
                    opacity: 1,
                    decay: Math.random() * 0.02 + 0.01
                });
            }

            // Update and draw sparkles
            recordingSparkles = recordingSparkles.filter(sparkle => {
                sparkle.opacity -= sparkle.decay;
                sparkle.size += 0.1;

                ctx.fillStyle = `rgba(255, 255, 255, ${sparkle.opacity})`;
                ctx.beginPath();
                ctx.arc(sparkle.x, sparkle.y, sparkle.size, 0, Math.PI * 2);
                ctx.fill();

                // Draw sparkle rays
                ctx.strokeStyle = `rgba(255, 255, 255, ${sparkle.opacity * 0.5})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(sparkle.x - sparkle.size * 2, sparkle.y);
                ctx.lineTo(sparkle.x + sparkle.size * 2, sparkle.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(sparkle.x, sparkle.y - sparkle.size * 2);
                ctx.lineTo(sparkle.x, sparkle.y + sparkle.size * 2);
                ctx.stroke();

                return sparkle.opacity > 0;
            });
        }

        let recordingHearts = [];

        function renderHeartsEffectToCanvas(ctx, canvas) {
            // Add new hearts
            if (Math.random() > 0.85) {
                recordingHearts.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 20 + 15,
                    opacity: 1,
                    decay: Math.random() * 0.01 + 0.005,
                    vx: Math.random() * 2 - 1,
                    vy: Math.random() * 2 - 2
                });
            }

            // Update and draw hearts
            recordingHearts = recordingHearts.filter(heart => {
                heart.opacity -= heart.decay;
                heart.x += heart.vx;
                heart.y += heart.vy;

                ctx.fillStyle = `rgba(255, 100, 150, ${heart.opacity})`;
                ctx.font = `bold ${heart.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('', heart.x, heart.y);

                return heart.opacity > 0;
            });
        }

        let recordingConfetti = [];

        function renderConfettiEffectToCanvas(ctx, canvas) {
            // Add new confetti
            if (Math.random() > 0.80) {
                for (let i = 0; i < 3; i++) {
                    recordingConfetti.push({
                        x: Math.random() * canvas.width,
                        y: -10,
                        size: Math.random() * 5 + 3,
                        opacity: 1,
                        decay: Math.random() * 0.01 + 0.008,
                        vx: Math.random() * 3 - 1.5,
                        vy: Math.random() * 3 + 2,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: Math.random() * 0.2 - 0.1
                    });
                }
            }

            // Update and draw confetti
            recordingConfetti = recordingConfetti.filter(c => {
                c.opacity -= c.decay;
                c.x += c.vx;
                c.y += c.vy;
                c.rotation += c.rotationSpeed;
                c.vy += 0.15; // gravity

                ctx.save();
                ctx.translate(c.x, c.y);
                ctx.rotate(c.rotation);
                ctx.fillStyle = `hsla(${Math.random() * 360}, 100%, 60%, ${c.opacity})`;
                ctx.fillRect(-c.size, -c.size, c.size * 2, c.size * 2);
                ctx.restore();

                return c.opacity > 0 && c.y < canvas.height;
            });
        }

        let recordingStars = [];

        function renderStarEffectToCanvas(ctx, canvas) {
            // Add new stars
            if (Math.random() > 0.8) {
                recordingStars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 15 + 10,
                    rotation: Math.random() * Math.PI * 2,
                    opacity: 1,
                    decay: Math.random() * 0.015 + 0.01,
                    rotationSpeed: Math.random() * 0.1 - 0.05
                });
            }

            // Update and draw stars
            recordingStars = recordingStars.filter(star => {
                star.opacity -= star.decay;
                star.rotation += star.rotationSpeed;

                ctx.save();
                ctx.translate(star.x, star.y);
                ctx.rotate(star.rotation);
                ctx.fillStyle = `rgba(255, 223, 0, ${star.opacity})`;
                ctx.shadowColor = `rgba(255, 223, 0, ${star.opacity * 0.8})`;
                ctx.shadowBlur = 10;

                // Draw 5-pointed star (same as preview)
                drawStar(ctx, 0, 0, 5, star.size / 2, star.size / 4);

                ctx.restore();
                return star.opacity > 0;
            });
        }

        let recordingSnow = [];

        function renderSnowEffectToCanvas(ctx, canvas) {
            // Add new snowflakes
            if (Math.random() > 0.8) {
                for (let i = 0; i < 5; i++) {
                    recordingSnow.push({
                        x: Math.random() * canvas.width,
                        y: -10,
                        size: Math.random() * 4 + 2,
                        opacity: 0.8,
                        decay: Math.random() * 0.005 + 0.002,
                        vx: Math.random() * 0.5 - 0.25,
                        vy: Math.random() * 1 + 0.5
                    });
                }
            }

            // Update and draw snowflakes
            recordingSnow = recordingSnow.filter(snowflake => {
                snowflake.opacity -= snowflake.decay;
                snowflake.x += snowflake.vx;
                snowflake.y += snowflake.vy;

                ctx.fillStyle = `rgba(255, 255, 255, ${snowflake.opacity})`;
                ctx.beginPath();
                ctx.arc(snowflake.x, snowflake.y, snowflake.size, 0, Math.PI * 2);
                ctx.fill();
                return snowflake.opacity > 0 && snowflake.y < canvas.height;
            });
        }

        let recordingFlowers = [];

        function renderFlowersEffectToCanvas(ctx, canvas) {
            // Add new flowers
            if (Math.random() > 0.85) {
                recordingFlowers.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height - 50,
                    size: Math.random() * 15 + 10,
                    opacity: 1,
                    decay: Math.random() * 0.008 + 0.004,
                    vx: Math.random() * 1.5 - 0.75,
                    vy: Math.random() * 1 + 0.5,
                    rotation: Math.random() * Math.PI * 2
                });
            }

            // Update and draw flowers
            recordingFlowers = recordingFlowers.filter(flower => {
                flower.opacity -= flower.decay;
                flower.x += flower.vx;
                flower.y += flower.vy;
                flower.rotation += 0.02;

                ctx.save();
                ctx.translate(flower.x, flower.y);
                ctx.rotate(flower.rotation);
                ctx.fillStyle = `hsla(${340 + Math.random() * 20}, 100%, 60%, ${flower.opacity})`;
                ctx.font = `bold ${flower.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('', 0, 0);
                ctx.restore();
                return flower.opacity > 0;
            });
        }

        let recordingGlow = [];

        function renderGlowEffectToCanvas(ctx, canvas) {
            // Add new glow particles
            if (Math.random() > 0.75) {
                recordingGlow.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 5 + 2,
                    opacity: 1,
                    decay: 0.02
                });
            }

            // Update and draw glow
            recordingGlow = recordingGlow.filter(glow => {
                glow.opacity -= glow.decay;
                glow.size += 0.2;

                ctx.fillStyle = `rgba(200, 100, 255, ${glow.opacity * 0.5})`;
                ctx.beginPath();
                ctx.arc(glow.x, glow.y, glow.size, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = `rgba(200, 100, 255, ${glow.opacity})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(glow.x, glow.y, glow.size * 0.7, 0, Math.PI * 2);
                ctx.stroke();

                return glow.opacity > 0;
            });
        }

        let recordingBokeh = [];

        function renderBokehEffectToCanvas(ctx, canvas) {
            // Add new bokeh circles
            if (Math.random() > 0.70) {
                recordingBokeh.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 20 + 10,
                    opacity: Math.random() * 0.5 + 0.3,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`
                });
            }

            // Draw bokeh
            recordingBokeh = recordingBokeh.filter(bokeh => {
                ctx.fillStyle = bokeh.color;
                ctx.globalAlpha = bokeh.opacity;
                ctx.beginPath();
                ctx.arc(bokeh.x, bokeh.y, bokeh.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                return true;
            });
        }

        function renderRainbowEffectToCanvas(ctx, canvas) {
            // Rainbow effect: Apply hue-rotate filter to entire canvas (matching preview)
            // This matches applyRainbowEffect() which does: hue-rotate(${hue}deg) saturate(1.4) brightness(1.1)
            const hue = (Date.now() / 20) % 360;

            // Apply rainbow color shift by manipulating image data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];

                // Convert RGB to HSL
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h = 0;
                let s = 0;
                let l = (max + min) / 2 / 255;

                if (max !== min) {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 * 255 - max - min) : d / (max + min);

                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }

                // Apply hue rotation
                h = (h * 360 + hue) % 360;
                h /= 360;

                // Apply saturation boost (1.4x)
                s = Math.min(1, s * 1.4);

                // Convert HSL back to RGB
                const c = (1 - Math.abs(2 * l - 1)) * s;
                const x = c * (1 - Math.abs((h * 6) % 2 - 1));
                const m = l - c / 2;

                let rr = 0, gg = 0, bb = 0;
                if (h < 1 / 6) { rr = c; gg = x; bb = 0; }
                else if (h < 2 / 6) { rr = x; gg = c; bb = 0; }
                else if (h < 3 / 6) { rr = 0; gg = c; bb = x; }
                else if (h < 4 / 6) { rr = 0; gg = x; bb = c; }
                else if (h < 5 / 6) { rr = x; gg = 0; bb = c; }
                else { rr = c; gg = 0; bb = x; }

                // Apply brightness boost (1.1x)
                data[i] = Math.min(255, (rr + m) * 255 * 1.1);
                data[i + 1] = Math.min(255, (gg + m) * 255 * 1.1);
                data[i + 2] = Math.min(255, (bb + m) * 255 * 1.1);
                data[i + 3] = a;
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function renderSunbeamEffectToCanvas(ctx, canvas) {
            // Sunbeam effect: 12 rotating rays from center (matching preview)
            // This matches applySunbeamEffect() which renders from centerX, centerY
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const beamCount = 12;
            const rotation = (Date.now() / 50) % (Math.PI * 2);

            for (let i = 0; i < beamCount; i++) {
                const angle = (i / beamCount) * Math.PI * 2 + rotation;
                ctx.strokeStyle = `rgba(255, 200, 0, 0.1)`;
                ctx.lineWidth = 30;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * 500,
                    centerY + Math.sin(angle) * 500
                );
                ctx.stroke();
            }
        }

        // ===== DISTORTION EFFECTS =====
        function renderWaveEffectToCanvas(ctx, canvas) {
            // Wave effect: skew animation matching applyWaveEffect()
            const wave = Math.sin(Date.now() / 200) * 5;
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Apply brightness boost (1.05x)
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.05);
                data[i + 1] = Math.min(255, data[i + 1] * 1.05);
                data[i + 2] = Math.min(255, data[i + 2] * 1.05);
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function renderKaleidoscopeEffectToCanvas(ctx, canvas) {
            // Kaleidoscope: saturate(1.5) hue-rotate(45deg) brightness(1.1) contrast(1.2)
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                // Simple approximation: boost saturation and brightness
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const delta = max - min;

                data[i] = Math.min(255, r * 1.1 * 1.2);
                data[i + 1] = Math.min(255, g * 1.1 * 1.2);
                data[i + 2] = Math.min(255, b * 1.1 * 1.2);
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function renderPixelateEffectToCanvas(ctx, canvas) {
            // Pixelate: blur(4px) effect - downsample and upsample
            const blockSize = 4;
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < canvas.height; y += blockSize) {
                for (let x = 0; x < canvas.width; x += blockSize) {
                    let r = 0, g = 0, b = 0, count = 0;

                    // Average block
                    for (let dy = 0; dy < blockSize && y + dy < canvas.height; dy++) {
                        for (let dx = 0; dx < blockSize && x + dx < canvas.width; dx++) {
                            const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                            r += data[idx];
                            g += data[idx + 1];
                            b += data[idx + 2];
                            count++;
                        }
                    }

                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);

                    // Fill block with average
                    for (let dy = 0; dy < blockSize && y + dy < canvas.height; dy++) {
                        for (let dx = 0; dx < blockSize && x + dx < canvas.width; dx++) {
                            const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                            data[idx] = r;
                            data[idx + 1] = g;
                            data[idx + 2] = b;
                        }
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function renderFisheyeEffectToCanvas(ctx, canvas) {
            // Fisheye: blur(1px) brightness(1.1) - apply slight blur
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.1);
                data[i + 1] = Math.min(255, data[i + 1] * 1.1);
                data[i + 2] = Math.min(255, data[i + 2] * 1.1);
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // ===== RETRO/FILM EFFECTS =====
        function renderVHSEffectToCanvas(ctx, canvas) {
            // VHS: contrast(1.1) brightness(0.9) hue-rotate(5deg)
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, data[i] * 1.1 * 0.9));
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] * 1.1 * 0.9));
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] * 1.1 * 0.9));
            }
            ctx.putImageData(imageData, 0, 0);
        }

        let recordingGlitches = [];

        function renderGlitchEffectToCanvas(ctx, canvas) {
            // Glitch: random colorful horizontal slices
            if (Math.random() > 0.85) {
                const sliceHeight = Math.random() * 50 + 10;
                const sliceY = Math.random() * canvas.height;
                const offset = Math.random() * 20 - 10;

                ctx.fillStyle = 'rgba(255, 0, 100, 0.15)';
                ctx.fillRect(0, sliceY, canvas.width, sliceHeight);
                ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
                ctx.fillRect(offset, sliceY, canvas.width, sliceHeight);
            }
        }

        function renderFilmBurnEffectToCanvas(ctx, canvas) {
            // FilmBurn: sepia(30%) brightness(0.85) contrast(1.1) hue-rotate(15deg)
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];

                // Apply sepia tone slightly
                const sepiaR = r * 0.393 + g * 0.769 + b * 0.189;
                const sepiaG = r * 0.349 + g * 0.686 + b * 0.168;
                const sepiaB = r * 0.272 + g * 0.534 + b * 0.131;

                data[i] = Math.min(255, sepiaR * 0.3 + r * 0.7) * 0.85 * 1.1;
                data[i + 1] = Math.min(255, sepiaG * 0.3 + g * 0.7) * 0.85 * 1.1;
                data[i + 2] = Math.min(255, sepiaB * 0.3 + b * 0.7) * 0.85 * 1.1;
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function renderScanlinesEffectToCanvas(ctx, canvas) {
            // Scanlines: horizontal black lines
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.lineWidth = 1;
            for (let y = 0; y < canvas.height; y += 4) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // ===== NEON & VIBRANT EFFECTS =====
        function renderNeonEffectToCanvas(ctx, canvas) {
            // Neon: brightness(1.2) saturate(1.8) contrast(1.3) hue-rotate(20deg) + glow
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.2 * 1.3);
                data[i + 1] = Math.min(255, data[i + 1] * 1.2 * 1.3);
                data[i + 2] = Math.min(255, data[i + 2] * 1.2 * 1.3);
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function renderCyberpunkEffectToCanvas(ctx, canvas) {
            // Cyberpunk: saturate(2) hue-rotate(-30deg) brightness(1.3) contrast(1.5)
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.3 * 1.5);
                data[i + 1] = Math.min(255, data[i + 1] * 1.3 * 1.5);
                data[i + 2] = Math.min(255, data[i + 2] * 1.3 * 1.5);
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function renderVaporwaveEffectToCanvas(ctx, canvas) {
            // Vaporwave: hue-rotate(260deg) saturate(1.3) brightness(1.1) contrast(1.2)
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.1 * 1.2);
                data[i + 1] = Math.min(255, data[i + 1] * 1.1 * 1.2);
                data[i + 2] = Math.min(255, data[i + 2] * 1.1 * 1.2);
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // ===== MOOD EFFECTS =====
        function renderGhostEffectToCanvas(ctx, canvas) {
            // Ghost effect: semi-transparent overlay
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i + 3] = data[i + 3] * 0.7; // Semi-transparent
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function renderMaskEffectToCanvas(ctx, canvas) {
            // Mask: brightness(1.1) saturate(1.2) hue-rotate(30deg)
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.1);
                data[i + 1] = Math.min(255, data[i + 1] * 1.1);
                data[i + 2] = Math.min(255, data[i + 2] * 1.1);
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function renderDreamyEffectToCanvas(ctx, canvas) {
            // Dreamy: blur(2px) brightness(1.2) contrast(0.9) saturate(0.8)
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, data[i] * 1.2 * 0.9 * 0.8);
                data[i + 1] = Math.min(255, data[i + 1] * 1.2 * 0.9 * 0.8);
                data[i + 2] = Math.min(255, data[i + 2] * 1.2 * 0.9 * 0.8);
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function renderNoirEffectToCanvas(ctx, canvas) {
            // Noir: grayscale(100%) contrast(1.3) brightness(0.95)
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                const adjusted = Math.min(255, Math.max(0, gray * 1.3 * 0.95));
                data[i] = adjusted;
                data[i + 1] = adjusted;
                data[i + 2] = adjusted;
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // ===== CLONE & MIRROR EFFECTS =====
        function renderMirrorEffectToCanvas(ctx, canvas) {
            // Mirror: left half normal, right half flipped (handled in recording canvas)
            // This is handled specially during canvas rendering
        }

        function renderCloneEffectToCanvas(ctx, canvas) {
            // Clone: 4 scaled versions of video (handled in recording canvas)
            // This is handled specially during canvas rendering
        }

        function generateParticles(canvas, effects, count) {
            const particles = [];
            const effectEmojis = {
                'sparkle': '',
                'star': '',
                'hearts': '',
                'confetti': ['', '', ''],
                'flowers': ['', '', '', '', ''],
                'snow': '',
                'glow': '',
                'bokeh': '',
                'rainbow': '',
                'sunbeam': '',
                'neon': '',
                'mirror': '',
                'clone': ''
            };

            // Scale particle size based on canvas dimensions
            // Base size for 480px width, scale proportionally
            const scaleMultiplier = canvas.width / 480;
            const minSize = 14 * scaleMultiplier;
            const maxSize = 24 * scaleMultiplier;

            for (let i = 0; i < count; i++) {
                const randomEffect = effects[Math.floor(Math.random() * effects.length)];
                const emojiData = effectEmojis[randomEffect];
                const emoji = Array.isArray(emojiData) ? emojiData[Math.floor(Math.random() * emojiData.length)] : emojiData;

                particles.push({
                    emoji: emoji,
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 0.5,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 1,
                    gravity: 0.1,
                    size: minSize + Math.random() * (maxSize - minSize),
                    age: 0,
                    maxAge: 100 + Math.random() * 100,
                    opacity: 1
                });
            }

            return particles;
        }

        // Filter map cache for performance
        const filterMap = {
            'none': 'none',
            'bw': 'grayscale(100%)',
            'sepia': 'sepia(100%)',
            'vintage': 'sepia(50%) contrast(0.9) brightness(0.9)',
            'vivid': 'saturate(1.5) contrast(1.1)',
            'warm': 'brightness(1.1) saturate(1.3) hue-rotate(10deg)',
            'cool': 'hue-rotate(-20deg) saturate(1.2) brightness(0.95)'
        };

        let cachedFilterString = 'none';
        let lastCachedFilter = null;
        let lastCachedAdjustments = null;

        function buildFilterString() {
            // Cache filter string to avoid rebuilding every frame
            const currentFilter = recordingState.currentFilter || 'none';
            const adjustments = recordingState.filterAdjustments || {};

            // Check if anything changed
            if (lastCachedFilter === currentFilter &&
                lastCachedAdjustments === JSON.stringify(adjustments)) {
                return cachedFilterString;
            }

            let filterString = filterMap[currentFilter] || 'none';

            const brightness = parseFloat(adjustments.brightness) || 0;
            const contrast = parseFloat(adjustments.contrast) || 0;
            const saturation = parseFloat(adjustments.saturation) || 0;

            if (brightness !== 0 || contrast !== 0 || saturation !== 0) {
                const brightnessPercent = 100 + brightness;
                const contrastPercent = 100 + contrast;
                const saturationPercent = 100 + saturation;
                const adjustmentString = `brightness(${brightnessPercent}%) contrast(${contrastPercent}%) saturate(${saturationPercent}%)`;
                filterString = filterString === 'none' ? adjustmentString : `${filterString} ${adjustmentString}`;
            }

            cachedFilterString = filterString;
            lastCachedFilter = currentFilter;
            lastCachedAdjustments = JSON.stringify(adjustments);

            return filterString;
        }

        // OPTIMIZATION: Preview-only filter updates (not baked into recording)
        // This is CPU-efficient since filters are applied via CSS only
        function updatePreviewFilterOnly() {
            const videoElement = document.getElementById('videoPreview');
            if (!videoElement) return;

            // Filters already applied via CSS in setUpPreviewFilterUpdates()
            // This function is a no-op for the optimized version
            // but kept for compatibility with the recording flow
            console.log(' Preview filter update (CSS-based, zero CPU impact)');
        }

        function stopRecording() {
            if (!recordingState.mediaRecorder || !recordingState.isRecording) {
                return;
            }

            recordingState.isRecording = false;
            stopRecordingTimer();

            // Stop canvas rendering loop IMMEDIATELY (no wait)
            recordingState.isCanvasRendering = false;
            if (recordingState.recordingCanvas) {
                recordingState.recordingCanvas = null;
                recordingState.canvasContext = null;
            }

            // Clear all recording effect particles IMMEDIATELY
            recordingSparkles = [];
            recordingHearts = [];
            recordingConfetti = [];
            recordingStars = [];
            recordingSnow = [];
            recordingFlowers = [];
            recordingGlow = [];
            recordingBokeh = [];

            console.log(' Canvas rendering stopped immediately');

            // Stop audio source if playing
            if (recordingState.audioSource) {
                try {
                    recordingState.audioSource.stop();
                } catch (e) {
                    // Already stopped, safe to ignore
                }
                recordingState.audioSource = null;
            }

            // Close audio context async (non-blocking)
            if (recordingState.audioContext && recordingState.audioContext.state !== 'closed') {
                recordingState.audioContext.close().catch(() => {
                    // Ignore close errors
                });
            }
            recordingState.audioContext = null;

            // Stop background audio element
            if (recordingState.backgroundAudio) {
                try {
                    recordingState.backgroundAudio.pause();
                    recordingState.backgroundAudio.currentTime = 0;
                } catch (e) {
                    // Ignore errors
                }
                recordingState.backgroundAudio = null;
            }

            showToastRecording(' Recording stopped, processing video...', 'success', '');
            console.log(' Video recorded successfully:', recordingState.recordingTime + 's');

            // Mark that we've initiated stop
            recordingState.mediaRecorderStopped = false;
            recordingState.mediaRecorder.stop();

            // Stop stream tracks immediately (doesn't block MediaRecorder)
            if (recordingState.stream) {
                recordingState.stream.getTracks().forEach(track => {
                    try {
                        track.stop();
                    } catch (e) {
                        // Ignore errors
                    }
                });
            }

            // Wait for mediaRecorder.onstop event to fire, then process
            // Use polling to avoid blocking, max wait 500ms
            let waitCount = 0;
            const maxWaitTime = 500; // max 500ms
            const checkInterval = setInterval(() => {
                waitCount += 10;
                if (recordingState.mediaRecorderStopped || waitCount >= maxWaitTime) {
                    clearInterval(checkInterval);
                    processRecordedVideo();
                }
            }, 10);
        }

        function processRecordedVideo() {
            // Check what was applied during recording
            const hasFilters = recordingState.currentFilter && recordingState.currentFilter !== 'none';
            const hasEffects = recordingState.selectedEffects && recordingState.selectedEffects.length > 0;
            const hasSpeed = recordingState.currentSpeed && recordingState.currentSpeed !== 1;

            console.log(' Video Processing Complete!');
            console.log(' Filters applied during recording:', hasFilters, recordingState.currentFilter);
            console.log(' Effects applied during recording:', hasEffects, recordingState.selectedEffects.length);
            console.log(' Speed setting:', recordingState.currentSpeed);

            // Show upload message (effects already baked in)
            const editLoadingOverlay = document.getElementById('editLoadingOverlay');
            if (editLoadingOverlay) {
                editLoadingOverlay.style.display = 'flex';
                editLoadingOverlay.innerHTML = `
                    <div style="text-align: center; color: #fff; max-width: 300px;">
                        <div style="font-size: 36px; margin-bottom: 15px; animation: pulse 1s infinite;"></div>
                        <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px;">Uploading video</div>
                        <div style="font-size: 12px; color: #aaa; margin-top: 10px;">
                            ${hasFilters ? ' Filter baked in' : ''}
                            ${hasEffects ? '<br> Effects baked in' : ''}
                            <br> Sending to Cloudinary...
                        </div>
                    </div>
                `;
            }

            // Always upload (effects are already baked into the video)
            uploadRecordedVideoWithEffects();
        }

        async function uploadRecordedVideoWithEffects() {
            const latestClip = recordingState.clips[recordingState.clips.length - 1];
            if (!latestClip || !latestClip.blob) {
                console.error(' No video blob found');
                transitionToEditScreen();
                return;
            }

            console.log(' Starting Cloudinary upload (effects already baked in)...');

            // Hide edit loading overlay and show professional upload progress (non-blocking)
            const editLoadingOverlay = document.getElementById('editLoadingOverlay');
            if (editLoadingOverlay) {
                editLoadingOverlay.style.display = 'none';
            }

            // Show professional upload progress modal (non-blocking)
            showUploadProgressModal();

            try {
                console.log(' Uploading blob with effects...');

                // Upload to Cloudinary (video already has effects baked in)
                const uploadResult = await uploadRecordingToCloudinary(latestClip.blob);

                if (uploadResult && uploadResult.url) {
                    console.log(' Upload successful:', uploadResult.url);

                    // Update the clip with Cloudinary URL (all updates in one step)
                    latestClip.url = uploadResult.url;
                    latestClip.cloudinaryUrl = uploadResult.url;
                    latestClip.publicId = uploadResult.publicId;
                    latestClip.filter = recordingState.currentFilter;
                    latestClip.effects = recordingState.selectedEffects;

                    console.log(' Filter used:', recordingState.currentFilter);
                    console.log(' Effects applied:', recordingState.selectedEffects.length);
                    console.log(' Speed setting:', recordingState.currentSpeed);

                    // Show success state
                    updateUploadProgressModal(100, 'Upload Complete!', '', 'Ready to edit...');
                    console.log(' Video upload complete');

                    // Save to Firebase in background (fire and forget - doesn't block)
                    saveRecordingToFirebase(latestClip);

                    // Transition to edit screen quickly (500ms instead of 1000ms)
                    setTimeout(() => {
                        closeUploadProgressModal();
                        transitionToEditScreen();
                    }, 500);
                } else {
                    throw new Error('Upload failed - no URL returned');
                }

            } catch (error) {
                console.error(' Video upload error:', error);
                // Show error state
                updateUploadProgressModal(0, 'Upload Failed', '', error.message.substring(0, 50));

                // Transition to edit screen after 1.5 seconds (quicker on error)
                setTimeout(() => {
                    closeUploadProgressModal();
                    transitionToEditScreen();
                }, 1500);
            }
        }

        function getCloudinaryFilterTransform(filterName) {
            // Map filter names to Cloudinary effects
            // Note: For videos, we don't use transformation params that cause 400 errors
            // Instead, save the raw URL and apply filters via CSS on preview
            // Filters will be applied server-side when needed
            const filterMap = {
                'none': '',
                'bw': 'e_grayscale',                      // Black & White
                'sepia': 'e_sepia',                       // Sepia
                'vintage': 'e_sepia:50',                 // Vintage - sepia
                'vivid': 'e_saturation:70',              // Vivid - increased saturation
                'warm': 'e_colorize:40:FF8C00',         // Warm - orange tint
                'cool': 'e_colorize:30:00BFFF'          // Cool - blue tint
            };
            return filterMap[filterName] || '';
        }

        function applyCloudinaryTransformations(originalUrl, transforms) {
            // Simply return the raw Cloudinary URL without transforms
            // This ensures preview loads without 400 errors
            // Transform application can be done server-side later if needed

            if (!originalUrl) {
                return originalUrl;
            }

            console.log(' Using raw Cloudinary URL (no transforms applied)');
            return originalUrl;
        }

        async function uploadRecordingToCloudinary(videoBlob) {
            const CLOUDINARY_CLOUD_NAME = 'dzhdgxjhl';
            const CLOUDINARY_UPLOAD_PRESET = 'posepreset';
            const CLOUDINARY_API_URL = `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/auto/upload`;

            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                const formData = new FormData();

                const fileName = `recording_${Date.now()}.webm`;
                formData.append('file', videoBlob, fileName);
                formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
                formData.append('tags', `video_recording,${recordingState.recordingTime}s`);
                formData.append('folder', 'recorded-videos');
                formData.append('resource_type', 'auto');

                // Timeout after 120 seconds
                const timeoutId = setTimeout(() => {
                    xhr.abort();
                    reject(new Error('Upload timeout'));
                }, 120000);

                // Track upload progress
                const uploadStartTime = Date.now();
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percentComplete = (e.loaded / e.total) * 100;
                        const uploadedMB = (e.loaded / (1024 * 1024)).toFixed(1);
                        const totalMB = (e.total / (1024 * 1024)).toFixed(1);
                        const elapsedSeconds = (Date.now() - uploadStartTime) / 1000;
                        const uploadSpeed = (e.loaded / elapsedSeconds / (1024 * 1024)).toFixed(1);
                        const remainingBytes = e.total - e.loaded;
                        const etaSeconds = remainingBytes / (e.loaded / elapsedSeconds);

                        // Update professional progress modal
                        updateUploadProgressModal(
                            percentComplete,
                            `Uploading... ${Math.round(percentComplete)}%`,
                            '',
                            `${uploadedMB} MB of ${totalMB} MB`,
                            uploadSpeed,
                            Math.max(0, Math.ceil(etaSeconds))
                        );

                        console.log(` Upload: ${Math.round(percentComplete)}% (${uploadSpeed} MB/s)`);
                    }
                });

                xhr.addEventListener('load', () => {
                    clearTimeout(timeoutId);

                    if (xhr.status === 200) {
                        try {
                            const response = JSON.parse(xhr.responseText);
                            console.log(' Cloudinary upload response:', response);
                            resolve({
                                url: response.secure_url,
                                publicId: response.public_id,
                                fileName: fileName
                            });
                        } catch (error) {
                            reject(new Error('Invalid Cloudinary response'));
                        }
                    } else {
                        reject(new Error(`Upload failed: ${xhr.status}`));
                    }
                });

                xhr.addEventListener('error', () => {
                    clearTimeout(timeoutId);
                    reject(new Error('Network error during upload'));
                });

                xhr.open('POST', CLOUDINARY_API_URL);
                xhr.send(formData);
            });
        }

        async function saveRecordingToFirebase(clip) {
            try {
                const user = firebase.auth().currentUser;
                if (!user) {
                    console.log(' No user logged in, skipping Firebase save');
                    return;
                }

                const db = firebase.firestore();
                const userId = user.uid;

                // Simple recording data
                const recordingData = {
                    userId: userId,
                    url: clip.url,
                    cloudinaryUrl: clip.cloudinaryUrl,
                    publicId: clip.publicId || '',
                    duration: clip.duration || 0,
                    speed: clip.speed || 1,
                    filter: recordingState.currentFilter || 'none',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    timestamp: Date.now()
                };

                // Save to user's recordings collection (fire and forget)
                db.collection('users').doc(userId).collection('recordings').add(recordingData)
                    .then(docRef => {
                        console.log(' Recording saved to Firebase:', docRef.id);
                        clip.firebaseId = docRef.id;
                    })
                    .catch(err => {
                        console.log(' Firebase save error (preview still works):', err.message);
                    });

            } catch (error) {
                console.error(' Firebase error:', error.message);
                // Don't block - preview still works
            }
        }

        function updateRecordingUploadProgress(percent) {
            const editLoadingOverlay = document.getElementById('editLoadingOverlay');
            if (editLoadingOverlay) {
                editLoadingOverlay.style.display = 'flex';

                // Determine speed indicator
                let speedEmoji = '';
                let speedText = 'Slow';
                if (percent < 30) {
                    speedEmoji = '';
                    speedText = 'Fast';
                } else if (percent < 70) {
                    speedEmoji = '';
                    speedText = 'Normal';
                }

                editLoadingOverlay.innerHTML = `
                    <div style="text-align: center; color: #fff; max-width: 300px;">
                        <div style="font-size: 36px; margin-bottom: 15px; animation: pulse 1s infinite;"></div>
                        <div style="font-size: 16px; font-weight: 600; margin-bottom: 20px;">Uploading video</div>
                        
                        <div style="width: 100%; height: 8px; background: #2a2a2a; border-radius: 4px; overflow: hidden; margin: 0 auto 15px;">
                            <div style="height: 100%; background: linear-gradient(90deg, #4C1D95, #6D28D9); width: ${percent}%; transition: width 0.2s;"></div>
                        </div>
                        
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 15px;">
                            <div style="font-size: 24px;">${speedEmoji}</div>
                            <div style="font-size: 14px; color: #aaa;">${Math.round(percent)}%</div>
                            <div style="font-size: 12px; color: #888;">${speedText}</div>
                        </div>
                        
                        <div style="font-size: 11px; color: #666; margin-top: 15px;">Applying effects & filters</div>
                    </div>
                `;
            }
        }

        function transitionToEditScreen() {
            // Load the latest recorded video into Screen 3
            if (recordingState.clips.length > 0) {
                const latestClip = recordingState.clips[recordingState.clips.length - 1];
                const editVideoElement = document.getElementById('editVideoPreview');
                const loadingOverlay = document.getElementById('editLoadingOverlay');

                console.log(' Transitioning to edit screen...');
                console.log(' Video URL:', latestClip.url);

                if (editVideoElement) {
                    // Set video source
                    editVideoElement.src = latestClip.url;
                    editVideoElement.preload = 'auto';
                    editVideoElement.crossOrigin = 'anonymous';
                    editVideoElement.autoplay = false;
                    editVideoElement.muted = false;

                    // Load the video
                    editVideoElement.load();

                    // Handle when metadata is loaded
                    const onMetadataLoaded = () => {
                        console.log(' Video metadata loaded, duration:', editVideoElement.duration);
                        if (loadingOverlay) {
                            loadingOverlay.style.display = 'none';
                        }
                        editVideoElement.removeEventListener('loadedmetadata', onMetadataLoaded);
                    };

                    editVideoElement.addEventListener('loadedmetadata', onMetadataLoaded, { once: true });

                    // Fallback: hide overlay after timeout
                    setTimeout(() => {
                        if (loadingOverlay) {
                            loadingOverlay.style.display = 'none';
                        }
                    }, 2000);

                    editVideoElement.onerror = (err) => {
                        console.error(' Video load error:', err);
                        if (loadingOverlay) loadingOverlay.style.display = 'none';
                    };
                }
            }

            // Show screen immediately
            showScreen('screen3');
            console.log(' Screen 3 shown');
        }

        function startRecordingTimer() {
            if (recordingState.timerInterval) {
                clearInterval(recordingState.timerInterval);
            }

            recordingState.timerInterval = setInterval(() => {
                if (recordingState.isRecording && !recordingState.timerPaused) {
                    recordingState.recordingTime++;
                    updateRecordingDisplay();

                    // Warning at 80% of max duration
                    if (recordingState.recordingTime === Math.floor(recordingState.maxDuration * 0.8)) {
                        showToastRecording(' Approaching max duration', 'warning', '');
                    }

                    // Auto-stop at max duration
                    if (recordingState.recordingTime >= recordingState.maxDuration) {
                        stopRecording();
                        showToastRecording(' Max duration reached', 'info', '');
                    }
                }
            }, 1000);
        }

        function stopRecordingTimer() {
            if (recordingState.timerInterval) {
                clearInterval(recordingState.timerInterval);
                recordingState.timerInterval = null;
            }
        }

        function updateRecordingDisplay() {
            // Update status bar timer
            const statusTimer = document.getElementById('recTimerDisplay');
            if (statusTimer) {
                const minutes = Math.floor(recordingState.recordingTime / 60);
                const seconds = recordingState.recordingTime % 60;
                statusTimer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            // Update quick stats bar
            const statsDisplay = document.getElementById('recDurationDisplay');
            if (statsDisplay) {
                const minutes = Math.floor(recordingState.recordingTime / 60);
                const seconds = recordingState.recordingTime % 60;
                statsDisplay.textContent = ` ${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function toggleRecordingPause() {
            if (!recordingState.mediaRecorder || !recordingState.isRecording) {
                return;
            }

            if (recordingState.mediaRecorder.state === 'recording') {
                // Pause recording
                recordingState.mediaRecorder.pause();
                recordingState.timerPaused = true;
                stopRecordingTimer();

                const pauseBtn = document.getElementById('recPauseBtn');
                if (pauseBtn) {
                    pauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                    pauseBtn.title = 'Resume Recording';
                }

                const mainBtn = document.getElementById('recMainBtn');
                if (mainBtn) {
                    mainBtn.style.opacity = '0.6';
                }

                showToastRecording(' Recording paused', 'info', '');
                console.log(' Recording paused at:', recordingState.recordingTime + 's');
            } else if (recordingState.mediaRecorder.state === 'paused') {
                // Resume recording
                recordingState.mediaRecorder.resume();
                recordingState.timerPaused = false;
                startRecordingTimer();

                const pauseBtn = document.getElementById('recPauseBtn');
                if (pauseBtn) {
                    pauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    pauseBtn.title = 'Pause Recording';
                }

                const mainBtn = document.getElementById('recMainBtn');
                if (mainBtn) {
                    mainBtn.style.opacity = '1';
                }

                showToastRecording(' Recording resumed', 'info', '');
                console.log(' Recording resumed from:', recordingState.recordingTime + 's');
            }
        }

        function updateUIAfterRecording(isRecording) {
            const mainBtn = document.getElementById('recMainBtn');
            const btnLabel = document.getElementById('recBtnLabel');
            const statusBar = document.getElementById('recRecordingStatus');
            const controls = document.getElementById('recRecordingControls');
            const qualityBadge = document.getElementById('recQualityBadge');
            const controlRow = document.getElementById('recControlRow');

            if (isRecording) {
                // Recording started - hide controls, show recording UI
                if (mainBtn) mainBtn.classList.add('recording');
                if (btnLabel) btnLabel.textContent = 'Stop';
                if (statusBar) statusBar.style.display = 'flex';
                if (controls) controls.style.display = 'flex';
                if (qualityBadge) qualityBadge.style.opacity = '0.5';
                if (controlRow) controlRow.style.display = 'none';
            } else {
                // Recording stopped - show controls, hide recording UI
                if (mainBtn) mainBtn.classList.remove('recording');
                if (btnLabel) btnLabel.textContent = 'Start';
                if (statusBar) statusBar.style.display = 'none';
                if (controls) controls.style.display = 'none';
                if (qualityBadge) qualityBadge.style.opacity = '1';
                if (controlRow) controlRow.style.display = 'flex';

                // Reset pause button
                const pauseBtn = document.getElementById('recPauseBtn');
                if (pauseBtn) {
                    pauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                    pauseBtn.title = 'Pause';
                }
            }
        }

        function startTimer() {
            const timerDisplay = document.getElementById('timerDisplay');
            const maxDuration = parseInt(document.getElementById('maxDuration').value);

            recordingState.timerInterval = setInterval(() => {
                recordingState.recordingTime++;

                const minutes = Math.floor(recordingState.recordingTime / 60);
                const seconds = recordingState.recordingTime % 60;
                timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

                // Auto-stop if max duration reached
                if (recordingState.recordingTime >= maxDuration) {
                    stopRecording();
                }
            }, 1000);
        }

        function updateClipsPreview() {
            const preview = document.getElementById('clipsPreview');
            preview.innerHTML = '';

            recordingState.clips.forEach((clip, index) => {
                const div = document.createElement('div');
                div.className = 'clip-thumbnail';

                const video = document.createElement('video');
                video.src = clip.url;
                video.style.width = '100%';
                video.style.height = '100%';

                div.appendChild(video);
                preview.appendChild(div);
            });
        }

        function deleteLastClip() {
            if (recordingState.clips.length > 0) {
                recordingState.clips.pop();
                updateClipsPreview();

                if (recordingState.clips.length === 0) {
                    document.getElementById('deleteLastClip').style.display = 'none';
                    document.getElementById('proceedToEdit').style.display = 'none';
                }
            }
        }

        function showClipFeedback() {
            console.log(`Clip ${recordingState.clips.length} recorded: ${recordingState.recordingTime}s`);
        }

        // ====== CAMERA CONTROLS ======
        function toggleGrid() {
            const grid = document.getElementById('gridOverlay');
            const btn = document.getElementById('gridToggle');

            if (grid.style.display === 'none') {
                grid.style.display = 'block';
                btn.style.background = '#6D28D9';
            } else {
                grid.style.display = 'none';
                btn.style.background = '#4C1D95';
            }
        }

        function toggleFlash() {
            const btn = document.getElementById('flashToggle');
            alert('Flash control coming soon - requires hardware access');
        }

        function flipCamera() {
            recordingState.cameraFacingMode = recordingState.cameraFacingMode === 'user' ? 'environment' : 'user';

            if (recordingState.stream) {
                recordingState.stream.getTracks().forEach(track => track.stop());
            }

            recordingState.stream = null;
            initializeRecordTab();
        }

        function openBeautyMode() {
            const panel = document.getElementById('beautyPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function closeBeautyMode() {
            document.getElementById('beautyPanel').style.display = 'none';
        }

        function applyBeautyEffect() {
            recordingState.beautyLevel = document.getElementById('beautySlider').value;
            recordingState.sharpenLevel = document.getElementById('sharpenSlider').value;

            document.getElementById('beautyValue').textContent = recordingState.beautyLevel;
            document.getElementById('sharpenValue').textContent = recordingState.sharpenLevel;
        }

        // ====== SPEED & MODE CONTROLS ======


        // ====== PROCEED TO EDITOR ======
        function proceedToEdit() {
            if (recordingState.clips.length === 0) {
                alert('Please record at least one clip');
                return;
            }

            // Hide recording interface, show editor
            document.getElementById('recordingInterface').classList.remove('active');
            document.getElementById('recordingInterface').style.display = 'none';
            document.getElementById('editorInterface').classList.add('active');
            document.getElementById('editorInterface').style.display = 'flex';

            // Load clips into editor
            loadClipsToEditor();
        }

        // ====== EDITOR INTERFACE ======
        function loadClipsToEditor() {
            // Merge all clips into single video for preview
            const timeline = document.getElementById('clipsTimeline');
            timeline.innerHTML = '';

            recordingState.clips.forEach((clip, index) => {
                const clipDiv = document.createElement('div');
                clipDiv.className = 'timeline-clip';
                clipDiv.style.backgroundImage = `url('${clip.url}')`;
                clipDiv.style.backgroundSize = 'cover';
                clipDiv.onclick = () => selectClip(index);
                timeline.appendChild(clipDiv);
            });
        }

        function selectClip(index) {
            document.querySelectorAll('.timeline-clip').forEach(c => c.classList.remove('selected'));
            document.querySelectorAll('.timeline-clip')[index].classList.add('selected');
        }

        function switchEditorTab(tabName) {
            // Hide all editor tabs
            document.querySelectorAll('.editor-tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.editor-tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName + 'Tab').classList.add('active');
            event.target.classList.add('active');
        }

        function applyFilter(filterName) {
            recordingState.currentFilter = filterName;
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function applyFilterAdjustment() {
            recordingState.filterAdjustments.brightness = document.getElementById('brightnessSlider').value;
            recordingState.filterAdjustments.contrast = document.getElementById('contrastSlider').value;
            recordingState.filterAdjustments.saturation = document.getElementById('saturationSlider').value;

            document.getElementById('brightnessValue').textContent = recordingState.filterAdjustments.brightness;
            document.getElementById('contrastValue').textContent = recordingState.filterAdjustments.contrast;
            document.getElementById('saturationValue').textContent = recordingState.filterAdjustments.saturation;
        }

        function applyTransition(transitionType) {
            recordingState.selectedEffects.push({ type: 'transition', name: transitionType });
            console.log('Transition applied:', transitionType);
        }

        function applyEffect(effectType) {
            recordingState.selectedEffects.push({ type: 'effect', name: effectType });
            console.log('Effect applied:', effectType);
        }

        function addText() {
            const text = document.getElementById('textInput').value;
            const color = document.getElementById('textColor').value;
            const animation = document.getElementById('textAnimation').value;

            if (!text) {
                alert('Please enter text');
                return;
            }

            recordingState.textOverlays.push({ text, color, animation });
            document.getElementById('textInput').value = '';
            console.log('Text added:', text);
        }

        function addSticker(emoji) {
            recordingState.textOverlays.push({ text: emoji, type: 'sticker' });
            console.log('Sticker added:', emoji);
        }

        function extractAudio() {
            alert('Extract audio feature coming soon');
        }

        function adjustVolume(type) {
            const value = type === 'original' ?
                document.getElementById('originalVolume').value :
                document.getElementById('bgMusicVolume').value;

            if (type === 'original') {
                document.getElementById('originalVolValue').textContent = value;
            } else {
                document.getElementById('bgMusicVolValue').textContent = value;
            }
        }

        function saveToDraft() {
            alert('Video saved to drafts');
        }

        function proceedToPreview() {
            // Move to pre-posting interface
            document.getElementById('editorInterface').style.display = 'none';
            document.getElementById('prePostingInterface').style.display = 'flex';

            // Load preview video
            if (recordingState.clips.length > 0) {
                const firstClip = recordingState.clips[0];
                document.getElementById('postingPreview').src = firstClip.url;
            }
        }

        function backToRecording() {
            document.getElementById('editorInterface').style.display = 'none';
            document.getElementById('recordingInterface').style.display = 'flex';
            document.getElementById('recordingInterface').classList.add('active');
        }

        function backToEditor() {
            document.getElementById('prePostingInterface').style.display = 'none';
            document.getElementById('editorInterface').style.display = 'flex';
        }

        function selectCoverTime() {
            const time = document.getElementById('coverTime').value;
            console.log('Cover selected at:', time + '%');
        }

        async function postRecord() {
            if (!currentUser) {
                alert(' Please login to post');
                return;
            }

            const caption = document.getElementById('recordCaption').value.trim();

            if (!caption) {
                alert(' Please add a caption');
                return;
            }

            try {
                // Show TikTok-style countdown
                showTiktokCountdown(5, async () => {
                    // Show success message 1 second after countdown
                    setTimeout(() => {
                        showUploadResultModal(true, ' Uploading...', 'Your video is being processed');
                    }, 1000);

                    // Merge and upload clips
                    await mergeAndUploadClips(caption);
                });
            } catch (error) {
                console.error('Error posting video:', error);
                hideTiktokCountdown();
                alert(' Failed to post video: ' + error.message);
            }
        }

        async function mergeAndUploadClips(caption) {
            try {
                // Get user data
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                const userData = userDoc.data();

                if (!userData) {
                    alert('User profile not found');
                    return;
                }

                // Merge clips (simplified - in production use FFmpeg.js or backend)
                const mergedBlob = await mergeVideoClips(recordingState.clips);

                // Upload to Cloudinary
                const formData = new FormData();
                formData.append('file', mergedBlob);
                formData.append('upload_preset', 'pose_videos');

                const uploadResponse = await fetch('https://api.cloudinary.com/v1_1/drjptwqij/video/upload', {
                    method: 'POST',
                    body: formData
                });

                const videoData = await uploadResponse.json();
                const videoUrl = videoData.secure_url;

                // Save to Firestore
                const docRef = await db.collection('records').add({
                    userId: currentUser.uid,
                    userName: userData.name || '',
                    username: userData.username || '',
                    userProfilePic: userData.profilePicUrl || null,
                    caption: caption,
                    videoUrl: videoUrl,
                    allowComments: document.getElementById('recordAllowComments').checked,
                    allowSoundReuse: document.getElementById('recordAllowSoundReuse').checked,
                    allowSave: document.getElementById('recordAllowSave').checked,
                    allowAds: document.getElementById('recordAllowAds').checked,
                    status: 'posted',
                    views: 0,
                    likes: 0,
                    comments: 0,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Update success modal
                document.getElementById('uploadResultTitle').textContent = ' Video Posted!';
                document.getElementById('uploadResultMessage').textContent = 'Your recording was posted successfully!';

                // Reset form after 5 seconds
                setTimeout(() => {
                    closeUploadResultModal();
                    resetRecordTab();
                    closeUploadPage();
                }, 5000);

            } catch (error) {
                console.error('Upload error:', error);
                showUploadResultModal(false, ' Upload Failed', error.message);
            }
        }

        async function mergeVideoClips(clips) {
            // Simplified merge - combines clips sequentially
            // In production, use FFmpeg.js or backend service
            if (clips.length === 1) {
                return clips[0].blob;
            }

            // For now, return first clip
            return clips[0].blob;
        }

        function resetRecordTab() {
            recordingState.clips = [];
            recordingState.recordingTime = 0;
            recordingState.selectedEffects = [];
            recordingState.textOverlays = [];

            document.getElementById('clipsPreview').innerHTML = '';
            document.getElementById('recordCaption').value = '';
            document.getElementById('timerDisplay').textContent = '00:00';

            document.getElementById('recordingInterface').style.display = 'flex';
            document.getElementById('editorInterface').style.display = 'none';
            document.getElementById('prePostingInterface').style.display = 'none';
        }

        // Preview Media Function
        function previewMedia(inputId, previewId) {
            const input = document.getElementById(inputId);
            const preview = document.getElementById(previewId);

            input.addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        if (file.type.startsWith('image/')) {
                            preview.innerHTML = `<img src="${e.target.result}" alt="preview">`;
                        } else if (file.type.startsWith('video/')) {
                            preview.innerHTML = `<video src="${e.target.result}" controls></video>`;
                        }
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        // Initialize media previews
        document.addEventListener('DOMContentLoaded', function () {
            previewMedia('tweetMedia', 'tweetMediaPreview');
            previewMedia('postVideo', 'postVideoPreview');
            previewMedia('postThumbnail', 'postThumbnailPreview');
            previewMedia('exclusiveVideo', 'exclusiveVideoPreview');
        });

        // Open Tweet Preview
        function openTweetPreview() {
            const text = document.getElementById('tweetText').value.trim();

            if (!text) {
                alert('Please enter some text for your tweet');
                return;
            }

            // Copy media preview to popup
            const mediaPreview = document.getElementById('tweetMediaPreview').innerHTML;
            document.getElementById('tweetPreviewMedia').innerHTML = mediaPreview;

            document.getElementById('tweetPreviewPopup').classList.add('active');
        }

        // Close Tweet Preview
        function closeTweetPreview() {
            document.getElementById('tweetPreviewPopup').classList.remove('active');
        }

        // Open Exclusive Preview
        function openExclusivePreview() {
            const videoInput = document.getElementById('exclusiveVideo');

            if (!videoInput.files || videoInput.files.length === 0) {
                alert('Please upload or record a video');
                return;
            }

            // Copy video preview to popup
            const videoPreview = document.getElementById('exclusiveVideoPreview').innerHTML;
            document.getElementById('exclusivePreviewVideo').innerHTML = videoPreview;

            document.getElementById('exclusivePreviewPopup').classList.add('active');
        }

        // Close Exclusive Preview
        function closeExclusivePreview() {
            document.getElementById('exclusivePreviewPopup').classList.remove('active');
        }

        // Post Tweet to Firebase - with Cloudinary
        window.postTweet = async function postTweet() {
            console.log(' postTweet called');
            if (!currentUser) {
                alert(' Please login to post');
                console.error('Not logged in');
                return;
            }

            const text = document.getElementById('tweetText').value.trim();
            console.log('Tweet text:', text);

            if (!text) {
                alert(' Please enter some text for your tweet');
                return;
            }

            try {
                console.log('Getting user profile...');
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                const userData = userDoc.data();

                if (!userData) {
                    alert('User profile not found. Please complete your profile first.');
                    return;
                }

                // Use Cloudinary media URL (if any media was selected)
                let mediaUrl = tweetMediaUrl; // This will be null if no media was uploaded

                // Save to Firestore
                const docRef = await db.collection('tweets').add({
                    userId: currentUser.uid,
                    userName: userData.name || '',
                    username: userData.username || '',
                    userProfilePic: userData.profilePicUrl || null,
                    text: text,
                    caption: document.getElementById('tweetCaption').value.trim(),
                    hashtags: document.getElementById('tweetHashtags').value.trim(),
                    mediaUrl: mediaUrl,
                    allowAds: document.getElementById('tweetAllowAds').checked,
                    allowComments: document.getElementById('tweetAllowComments').checked,
                    allowSave: document.getElementById('tweetAllowSave').checked,
                    likes: 0,
                    comments: 0,
                    shares: 0,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                console.log('Tweet saved with ID:', docRef.id);
                alert(' Tweet posted successfully!');
                closeTweetPreview();
                closeUploadPage();

                // Clear form
                document.getElementById('tweetText').value = '';
                document.getElementById('tweetCaption').value = '';
                document.getElementById('tweetHashtags').value = '';
                document.getElementById('tweetMedia').value = '';
                document.getElementById('tweetMediaPreview').innerHTML = '';
                document.getElementById('tweetPreviewMedia').innerHTML = '';
                document.getElementById('tweetUploadStatus').innerHTML = '';

                // Reset media variables
                tweetMediaUrl = null;
                tweetMediaFileName = null;

            } catch (error) {
                console.error('Error posting tweet:', error);
                alert(' Failed to post tweet: ' + error.message);
            }
        }

        // Post Exclusive to Firebase - Optimized for Spark Mode
        window.postExclusive = async function postExclusive() {
            console.log(' postExclusive called');
            if (!currentUser) {
                alert(' Please login to post');
                console.error('Not logged in');
                return;
            }

            // Check if video URL exists (auto-uploaded)
            if (!exclusiveVideoUrl) {
                alert(' Please wait for video upload to complete');
                console.warn('Video not uploaded yet');
                return;
            }

            try {
                console.log(' Getting user profile...');
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                const userData = userDoc.data();

                if (!userData) {
                    alert('User profile not found. Please complete your profile first.');
                    return;
                }

                // Use pre-uploaded video URL
                const videoUrl = exclusiveVideoUrl;

                // Save to Firestore - minimal fields for Spark mode
                const docRef = await db.collection('exclusive').add({
                    userId: currentUser.uid,
                    userName: userData.name || '',
                    username: userData.username || '',
                    userProfilePic: userData.profilePicUrl || null,
                    caption: document.getElementById('exclusiveCaption').value.trim(),
                    hashtags: document.getElementById('exclusiveHashtags').value.trim(),
                    videoUrl: videoUrl,
                    videoFileName: exclusiveVideoFileName,
                    allowAds: document.getElementById('exclusiveAllowAds').checked,
                    allowComments: document.getElementById('exclusiveAllowComments').checked,
                    allowSave: document.getElementById('exclusiveAllowSave').checked,
                    views: 0,
                    likes: 0,
                    comments: 0,
                    earnings: 0,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                console.log('Exclusive saved with ID:', docRef.id);

                alert(' Exclusive video posted successfully!');
                closeExclusivePreview();
                closeUploadPage();

                // Clear form
                document.getElementById('exclusiveVideo').value = '';
                document.getElementById('exclusiveVideoPreview').innerHTML = '';
                document.getElementById('exclusiveUploadStatus').innerHTML = '';

                // Reset video variables
                exclusiveVideoUrl = null;
                exclusiveVideoFileName = null;

            } catch (error) {
                console.error('Error posting exclusive:', error);
                alert(' Failed to post exclusive: ' + error.message);
            }
        };

        // Debug logging function
        function addDebugLog(message) {
            const debugLog = document.getElementById('debugLog');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${timestamp}] ${message}`;
            debugLog.appendChild(logEntry);
            debugLog.scrollTop = debugLog.scrollHeight;
            console.log(message);
        }

        function toggleDebug() {
            const panel = document.getElementById('debugPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function clearDebugLog() {
            document.getElementById('debugLog').innerHTML = '';
        }

        // Upload Post - Optimized with Cloudinary
        window.uploadPost = async function uploadPost() {
            clearDebugLog();
            addDebugLog(' uploadPost started');

            if (!currentUser) {
                addDebugLog(' User not logged in');
                alert(' Please login first');
                return;
            }

            // Show TikTok-style countdown (5 seconds)
            showTiktokCountdown(5, async () => {
                // This callback runs after countdown completes
                // Show success message 1 second after countdown
                setTimeout(() => {
                    showUploadResultModal(true, ' Uploading...', 'Your post is being processed');
                }, 1000);

                await performUpload();
            });

            async function performUpload() {
                try {
                    const titleInput = document.getElementById('postTitle');
                    const descInput = document.getElementById('postDescription');
                    const tagsInput = document.getElementById('postTags');
                    const priceInput = document.getElementById('postPrice');
                    const priceTypeInput = document.getElementById('postPriceType');
                    const thumbInput = document.getElementById('postThumbnail');

                    addDebugLog(' Form elements found');

                    // Check if video URL exists (from Cloudinary)
                    if (!postVideoUrl) {
                        addDebugLog(' Video not uploaded yet');
                        alert(' Please wait for video upload to complete');
                        return;
                    }

                    const title = titleInput.value.trim();
                    if (!title) {
                        addDebugLog(' Title is empty');
                        alert(' Please enter a title for your post');
                        return;
                    }

                    addDebugLog(` Using Cloudinary video URL`);

                    // Get user data
                    addDebugLog(' Reading user data...');
                    const userDoc = await db.collection('users').doc(currentUser.uid).get();
                    const userData = userDoc.data();

                    if (!userData) {
                        addDebugLog(' User profile not found');
                        alert('User profile not found. Please complete your profile first.');
                        return;
                    }
                    addDebugLog(' User data loaded');

                    // Upload thumbnail to Cloudinary if provided
                    let thumbnailUrl = null;
                    if (thumbInput.files && thumbInput.files[0]) {
                        addDebugLog(' Uploading thumbnail to Cloudinary...');
                        try {
                            const thumbResult = await uploadToCloudinaryWithProgress(thumbInput.files[0], 'post_thumbnail');
                            thumbnailUrl = thumbResult.url;
                            addDebugLog(' Thumbnail uploaded: ' + thumbnailUrl);
                        } catch (thumbError) {
                            addDebugLog(` Thumbnail upload failed: ${thumbError.message}`);
                        }
                    }

                    // Prepare post data with Cloudinary URLs
                    const postData = {
                        userId: currentUser.uid,
                        userName: userData.name || '',
                        username: userData.username || '',
                        userProfilePic: userData.profilePicUrl || null,
                        title: title,
                        description: descInput.value.trim(),
                        tags: tagsInput.value.trim(),
                        videoUrl: postVideoUrl,
                        thumbnailUrl: thumbnailUrl,
                        price: parseFloat(priceInput.value) || 0,
                        priceType: priceTypeInput.value || 'free',
                        views: 0,
                        likes: 0,
                        comments: 0,
                        earnings: 0,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    };

                    // Save to Firestore
                    addDebugLog(' Saving to Firestore...');

                    try {
                        const docRef = await db.collection('posts').add(postData);
                        const postId = docRef.id;
                        addDebugLog(` Post saved! ID: ${postId}`);
                    } catch (firestoreError) {
                        addDebugLog(` Firestore error: ${firestoreError.message}`);
                        showUploadResultModal(false, ' Upload Failed', 'Failed to save post: ' + firestoreError.message);
                        return;
                    }

                    // Update success modal with final message
                    const modal = document.getElementById('uploadResultModal');
                    document.getElementById('uploadResultTitle').textContent = ' Video Posted!';
                    document.getElementById('uploadResultMessage').textContent = `"${title}" has been posted successfully!`;
                    if (thumbnailUrl) {
                        document.getElementById('uploadResultThumbnail').innerHTML = `<img src="${thumbnailUrl}" alt="thumbnail">`;
                    }
                    addDebugLog(' Upload complete!');

                    // Clear form after 5-second countdown
                    setTimeout(() => {
                        document.getElementById('postVideo').value = '';
                        titleInput.value = '';
                        descInput.value = '';
                        tagsInput.value = '';
                        priceInput.value = '0';
                        priceTypeInput.value = 'free';
                        thumbInput.value = '';
                        document.getElementById('postVideoPreview').innerHTML = '';
                        document.getElementById('postThumbnailPreview').innerHTML = '';
                        document.getElementById('postUploadStatus').innerHTML = '';

                        // Reset price buttons
                        setPostPrice(0, 'free');

                        // Reset variables
                        postVideoUrl = null;
                        postVideoFileName = null;

                        closeUploadPage();
                        closeUploadResultModal();
                    }, 5000);

                } catch (error) {
                    addDebugLog(` Error: ${error.message}`);
                    hideTiktokCountdown();
                    showUploadResultModal(false, ' Error', error.message);
                }
            } // End performUpload function
        };





        // ============================================================================
        // RECORDING UI FUNCTIONALITY
        // ============================================================================

        // State Management
        const recordingUIState = {
            isRecording: false,
            recordedBlob: null,
            recordingStartTime: 0,
            timerInterval: null,
            selectedMode: 'video',
            activeEffects: [],
            mediaStream: null,
            mediaRecorder: null,
            textBgGradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
            textAlign: 'center',
            isBold: false,
            textColor: '#fff'
        };

        // ============================================================================
        // SCREEN NAVIGATION
        // ============================================================================

        function showScreen(screenId) {
            // Get current active screen before hiding
            const currentScreen = document.querySelector('.recording-screen.active');
            const currentScreenId = currentScreen?.id;

            // Stop cameras when leaving screens
            if (currentScreenId === 'screen5' && screenId !== 'screen5') {
                console.log('Leaving screen 5 - stopping photo camera');
                stopPhotoMode();
            }
            if (currentScreenId === 'screen1' && screenId !== 'screen1') {
                console.log('Leaving screen 1 - stopping video camera');
                stopVideoCamera();
            }

            // Hide all screens
            document.querySelectorAll('.recording-screen').forEach(screen => {
                screen.classList.remove('active');
            });

            // Show target screen
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');

                // Initialize video camera when showing screen 1
                if (screenId === 'screen1') {
                    if (!recordingState.videoCameraInitialized || !recordingState.stream?.active) {
                        console.log('Entering screen 1 - initializing video camera...');
                        initializeVideoCamera();
                    } else {
                        console.log('Entering screen 1 - video camera already active');
                    }
                }

                // Initialize photo mode when showing screen 5
                if (screenId === 'screen5') {
                    // Check if camera is already active/streaming
                    if (!photoState.photoStream || !photoState.photoStream.active) {
                        console.log('Entering screen 5 - camera not ready, initializing...');
                        initializePhotoMode();
                    } else {
                        console.log('Entering screen 5 - camera already active');
                        ensureVideoElement();
                    }
                    // Update button states to reflect current settings
                    setTimeout(() => {
                        updatePhotoFlashButtonState();
                        updatePhotoTimerButtonState();
                    }, 100);
                }

                // Initialize video controls when showing screen 3 (edit screen)
                if (screenId === 'screen3') {
                    setTimeout(() => {
                        initEditVideoControls();
                    }, 100);
                }
            }
        }

        function closeRecordingUI() {
            const overlay = document.getElementById('recordingUIOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        }

        function backToScreen1() {
            // Stop camera if navigating away from photo mode
            stopPhotoMode();
            showScreen('screen1');
        }

        function backToScreen2() {
            // Stop camera if navigating away from photo mode
            stopPhotoMode();
            showScreen('screen2');
        }

        function backToScreen3() {
            showScreen('screen3');
        }

        function backToScreen5() {
            showScreen('screen5');
        }

        function backToScreen6() {
            showScreen('screen6');
        }

        function backToScreen8() {
            showScreen('screen8');
        }

        // ============================================================================
        // MENU TOGGLES
        // ============================================================================

        function toggleRecLeftMenu() {
            // Determine which menu to toggle based on active screen
            const activeScreen = document.querySelector('.recording-screen.active');
            let menuId = 'recLeftMenu'; // Default for other screens

            if (activeScreen?.id === 'screen5') {
                menuId = 'recPhotoLeftMenu'; // Photo mode menu
            } else if (activeScreen?.id === 'screen6') {
                menuId = 'recPhotoEditMenu'; // Photo edit menu
            }

            const menu = document.getElementById(menuId);
            if (menu) {
                // Toggle the 'show' class for smooth animation
                if (menu.classList.contains('show')) {
                    menu.classList.remove('show');
                    console.log('Menu closed:', menuId);
                } else {
                    menu.classList.add('show');
                    console.log('Menu opened:', menuId);
                }
            } else {
                console.warn('Menu not found:', menuId);
            }
        }

        function toggleRecEditMenu() {
            const menu = document.getElementById('recEditMenu');
            if (menu) {
                menu.classList.toggle('show');
                console.log('Edit menu toggled, show class:', menu.classList.contains('show'));
            }
        }

        function toggleRecPhotoEditMenu() {
            const menu = document.getElementById('recPhotoEditMenu');
            if (menu) {
                menu.classList.toggle('show');
                console.log('Menu toggled, class:', menu.className);
            }
        }

        // ============================================================================
        // TOAST NOTIFICATIONS
        // ============================================================================

        function showToastRecording(message, type = 'success', icon = '') {
            const toast = document.getElementById('recordingToast');
            const toastIcon = document.getElementById('recordingToastIcon');
            const toastMessage = document.getElementById('recordingToastMessage');

            if (toast && toastMessage && toastIcon) {
                toastIcon.textContent = icon;
                toastMessage.textContent = message;
                toast.className = `recording-toast ${type}`;
                toast.style.display = 'flex';

                setTimeout(() => {
                    toast.style.display = 'none';
                }, 3000);
            }
        }

        // ============================================================================
        // VIDEO RECORDING FUNCTIONALITY
        // ============================================================================

        function startRecording() {
            // Check if timer is set
            if (recordingState.recordingTimer > 0) {
                // Show countdown first
                showRecordingCountdown();
                return;
            }

            // Proceed with actual recording
            performRecording();
        }

        function performRecording() {
            // Request camera access
            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                .then(stream => {
                    recordingState.mediaStream = stream;

                    // IMPORTANT: Display camera stream to user
                    const videoElement = document.getElementById('recordingVideoPreview');
                    if (videoElement) {
                        videoElement.srcObject = stream;
                        videoElement.play().catch(err => {
                            console.error('Error playing video:', err);
                        });
                    }

                    recordingState.mediaRecorder = new MediaRecorder(stream);
                    const chunks = [];

                    recordingState.mediaRecorder.ondataavailable = (e) => {
                        chunks.push(e.data);
                    };

                    recordingState.mediaRecorder.onstop = () => {
                        recordingState.recordedBlob = new Blob(chunks, { type: 'video/webm' });
                    };

                    recordingState.mediaRecorder.start();
                    recordingState.isRecording = true;
                    recordingState.recordingStartTime = Date.now();

                    // Update record button to show recording state
                    const recordBtn = document.querySelector('.rec-record-btn');
                    if (recordBtn) {
                        recordBtn.classList.add('recording');
                        recordBtn.onclick = stopRecording;
                        recordBtn.textContent = '';
                    }

                    showScreen('screen2');
                    startRecordingTimer();
                    showToastRecording(' Recording started', 'success', '');
                })
                .catch(err => {
                    showToastRecording('Camera access denied', 'error', '');
                    console.error('Error accessing camera:', err);
                });
        }





        // ============================================================================
        // MODE SWITCHING
        // ============================================================================

        function switchRecMode(mode) {
            recordingState.selectedMode = mode;

            // Update active tab
            document.querySelectorAll('.rec-mode-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            if (mode === 'photo') {
                // Initialize filters panel (closed by default)
                const filtersPanel = document.querySelector('.photo-filters-panel');
                if (filtersPanel) {
                    initPhotoPanelState();
                }

                // Pre-initialize camera BEFORE showing screen for instant availability
                console.log('Initializing camera before showing Screen 5...');
                initializePhotoMode().then(() => {
                    console.log('Camera ready - showing Screen 5');
                    showScreen('screen5');
                    showToastRecording('Photo mode', 'info', '');
                }).catch(err => {
                    console.error('Camera init error:', err);
                    showScreen('screen5');
                    showToastRecording('Photo mode - camera may not be ready', 'warning', '');
                });
            } else if (mode === 'text') {
                // Hide filters panel
                const filtersPanel = document.querySelector('.photo-filters-panel');
                if (filtersPanel) {
                    filtersPanel.classList.remove('show');
                }
                showScreen('screen8');
                showToastRecording('Text mode', 'info', '');
            } else if (mode === 'video') {
                // Hide filters panel
                const filtersPanel = document.querySelector('.photo-filters-panel');
                if (filtersPanel) {
                    filtersPanel.classList.remove('show');
                }
                showScreen('screen1');
                showToastRecording('Video mode', 'info', '');
            }
        }

        // ============================================================================
        // VIDEO RECORDING MENU - SCREEN 1
        // ============================================================================

        function switchRecordingMode(mode) {
            if (mode === 'photo') {
                switchRecMode('photo');
            }
        }

        function openLayoutOptions() {
            const layoutPanel = document.getElementById('recLayoutPanel');
            const speedPanel = document.getElementById('recSpeedPanel');
            if (speedPanel) speedPanel.classList.remove('show');
            if (layoutPanel) {
                layoutPanel.classList.toggle('show');
                if (layoutPanel.classList.contains('show')) {
                    showToastRecording(' Layout Options', 'info', '');
                }
            }
        }

        function closeLayoutPanel() {
            const layoutPanel = document.getElementById('recLayoutPanel');
            if (layoutPanel) layoutPanel.classList.remove('show');
        }

        function setRecordingLayout(layout) {
            recordingState.layout = layout;
            recordingState.aspectRatio = layout;

            // Apply layout to video preview element
            const video = getRecordingVideoElement();
            if (video && video.parentElement) {
                video.parentElement.style.aspectRatio = layout === '16:9' ? '16/9' : layout === '1:1' ? '1/1' : 'auto';
            }

            // Update active button
            document.querySelectorAll('#recLayoutPanel .rec-option-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.closest('.rec-option-btn').classList.add('active');

            const layoutNames = {
                'full': 'Full Screen',
                '16:9': '16:9 Aspect',
                '1:1': 'Square'
            };
            showToastRecording(` ${layoutNames[layout]} Selected`, 'info', '');
        }

        function openTimerOptions() {
            // Timer options now handled by toggleRecordingTimer()
            toggleRecordingTimer();
        }

        function openFilterOptions() {
            // Filter options now handled by toggleRecordingFilters()
            toggleRecordingFilters();
        }

        function openSpeedOptions() {
            const speedPanel = document.getElementById('recSpeedPanel');
            const layoutPanel = document.getElementById('recLayoutPanel');
            if (layoutPanel) layoutPanel.classList.remove('show');
            if (speedPanel) {
                speedPanel.classList.toggle('show');
                if (speedPanel.classList.contains('show')) {
                    showToastRecording(' Speed Options', 'info', '');
                }
            }
        }

        function closeSpeedPanel() {
            const speedPanel = document.getElementById('recSpeedPanel');
            if (speedPanel) speedPanel.classList.remove('show');
        }

        function setRecordingSpeed(speed) {
            recordingState.currentSpeed = speed;
            recordingState.playbackSpeed = speed;

            // Apply playback rate to ALL video preview elements
            const videoPreview = document.getElementById('videoPreview');
            if (videoPreview) {
                videoPreview.playbackRate = speed;
            }

            const recordingVideoPreview = document.getElementById('recordingVideoPreview');
            if (recordingVideoPreview) {
                recordingVideoPreview.playbackRate = speed;
            }

            const editVideoPreview = document.getElementById('editVideoPreview');
            if (editVideoPreview) {
                editVideoPreview.playbackRate = speed;
            }

            // Apply to current recording video element
            const video = getRecordingVideoElement();
            if (video) {
                video.playbackRate = speed;
            }

            // Apply to all camera preview elements
            document.querySelectorAll('.camera-preview').forEach(el => {
                el.playbackRate = speed;
            });

            // Update active button
            document.querySelectorAll('#recSpeedPanel .rec-option-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.closest('.rec-option-btn').classList.add('active');

            const speedEmoji = {
                0.5: '',
                1: '',
                1.5: '',
                2: ''
            };

            const speedNames = {
                0.5: 'Slow Motion',
                1: 'Normal',
                1.5: 'Fast',
                2: 'Hyper Speed'
            };

            console.log(` Speed set to ${speed}x`);
            showToastRecording(`${speedEmoji[speed]} ${speedNames[speed]} (${speed}x)`, 'info', '');
        }

        // ============================================================================
        // RECORDING DURATION OPTIONS
        // ============================================================================

        function toggleRecordingDuration() {
            const durationPanel = document.getElementById('recDurationPanel');
            if (durationPanel) {
                durationPanel.classList.toggle('show');
            }
        }

        function closeDurationPanel() {
            const durationPanel = document.getElementById('recDurationPanel');
            if (durationPanel) durationPanel.classList.remove('show');
        }

        function setRecordingDuration(seconds) {
            recordingState.selectedDuration = seconds;
            recordingState.maxDuration = seconds;

            // Update active button
            document.querySelectorAll('#recDurationPanel .rec-options-grid .rec-option-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.closest('.rec-option-btn').classList.add('active');

            // Update label
            const durationLabel = document.getElementById('recDurationLabel');
            if (durationLabel) {
                durationLabel.textContent = `${seconds}s`;
            }

            // Clear custom input
            const customInput = document.getElementById('customDurationInput');
            if (customInput) customInput.value = seconds;

            showToastRecording(` Duration set to ${seconds} seconds`, 'info', '');

            // Close panel after selection
            closeDurationPanel();
        }

        function setCustomRecordingDuration() {
            const customInput = document.getElementById('customDurationInput');
            if (!customInput) return;

            const customSeconds = parseInt(customInput.value);
            if (isNaN(customSeconds) || customSeconds < 1 || customSeconds > 600) {
                showToastRecording(' Duration must be 1-600 seconds', 'error', '');
                return;
            }

            recordingState.selectedDuration = customSeconds;
            recordingState.maxDuration = customSeconds;

            // Deselect all preset buttons
            document.querySelectorAll('#recDurationPanel .rec-options-grid .rec-option-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Update label
            const durationLabel = document.getElementById('recDurationLabel');
            if (durationLabel) {
                durationLabel.textContent = `${customSeconds}s`;
            }

            showToastRecording(` Duration set to ${customSeconds} seconds`, 'success', '');

            // Close panel after setting
            closeDurationPanel();
        }

        // ============================================================================
        // VIDEO EDIT MENU - SCREEN 3
        // ============================================================================

        function openVideoTextEditor() {
            console.log(' Opening video text editor');
            toggleRecEditMenu(); // Close menu
            closeVideoTextModal(); // Close any existing modal

            // Create text overlay modal with full controls
            const modal = document.createElement('div');
            modal.id = 'videoTextModal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 2px solid #4C1D95;
                border-radius: 12px;
                padding: 20px;
                z-index: 3000;
                min-width: 320px;
                color: white;
            `;

            modal.innerHTML = `
                <h3 style="margin-top: 0; color: #fff;">Add Text to Video</h3>
                
                <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;"> Text</label>
                <input type="text" id="videoTextInput" placeholder="Enter text..." style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 6px; margin-bottom: 15px; font-size: 14px;">
                
                <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;"> Color</label>
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; margin-bottom: 15px;">
                    <button onclick="setVideoTextColor('#ffffff')" style="padding: 15px; background: white; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="White"></button>
                    <button onclick="setVideoTextColor('#000000')" style="padding: 15px; background: black; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Black"></button>
                    <button onclick="setVideoTextColor('#ff0000')" style="padding: 15px; background: red; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Red"></button>
                    <button onclick="setVideoTextColor('#ffff00')" style="padding: 15px; background: yellow; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Yellow"></button>
                    <button onclick="setVideoTextColor('#00ff00')" style="padding: 15px; background: lime; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Green"></button>
                    <button onclick="setVideoTextColor('#4C1D95')" style="padding: 15px; background: #4C1D95; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Purple"></button>
                </div>
                
                <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;"> Size: <span id="videoTextSizeDisplay">24</span>px</label>
                <input type="range" id="videoTextSize" min="12" max="72" value="24" style="width: 100%; margin-bottom: 15px; cursor: pointer;" oninput="document.getElementById('videoTextSizeDisplay').textContent = this.value">
                
                <div style="display: flex; gap: 10px;">
                    <button onclick="applyVideoText()" style="flex: 1; padding: 10px; background: #4C1D95; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Apply</button>
                    <button onclick="closeVideoTextModal()" style="flex: 1; padding: 10px; background: #333; color: white; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
                </div>
            `;

            document.body.appendChild(modal);
            document.getElementById('videoTextInput').focus();
            showToastRecording(' Enter text, select color & size', 'info', '');
        }

        function setVideoTextColor(color) {
            recordingState.videoTextColor = color;
            console.log('Video text color set to:', color);
        }

        function closeVideoTextModal() {
            const modal = document.getElementById('videoTextModal');
            if (modal) modal.remove();
        }

        function applyVideoText() {
            const text = document.getElementById('videoTextInput').value.trim();
            const size = document.getElementById('videoTextSize')?.value || 24;
            const color = recordingState.videoTextColor || '#ffffff';

            if (!text) {
                showToastRecording(' Please enter some text', 'warning', '');
                return;
            }

            // Store text settings in recordingState
            recordingState.videoTextOverlay = {
                text: text,
                size: size,
                color: color,
                offsetX: 0,
                offsetY: 0,
                timestamp: Date.now()
            };

            // Apply text overlay to video preview
            const screen3 = document.getElementById('screen3');
            const videoPreview = screen3?.querySelector('#editVideoPreview');

            if (!videoPreview) {
                console.error(' Video preview not found in screen 3');
                showToastRecording(' Video preview not found', 'error', '');
                return;
            }

            // Ensure container is positioned relatively
            const previewWrapper = videoPreview.parentElement;
            if (window.getComputedStyle(previewWrapper).position === 'static') {
                previewWrapper.style.position = 'relative';
            }

            // Remove old overlay if exists
            const oldOverlay = previewWrapper.querySelector('#videoTextOverlay');
            if (oldOverlay) oldOverlay.remove();

            // Create and add new overlay to video preview
            const overlay = document.createElement('div');
            overlay.id = 'videoTextOverlay';
            overlay.style.cssText = `
                position: absolute;
                top: calc(50% + ${recordingState.videoTextOverlay.offsetY}px);
                left: calc(50% + ${recordingState.videoTextOverlay.offsetX}px);
                transform: translate(-50%, -50%);
                color: ${color};
                font-size: ${size}px;
                font-weight: bold;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), -2px -2px 4px rgba(0,0,0,0.8);
                cursor: move;
                z-index: 100;
                white-space: nowrap;
                max-width: 90%;
                word-wrap: break-word;
                text-align: center;
                padding: 8px 12px;
                border: 2px dashed rgba(76, 29, 149, 0.5);
                border-radius: 6px;
                background: rgba(0,0,0,0.3);
            `;
            overlay.textContent = text;

            // Make text interactive and draggable
            overlay.draggable = true;
            overlay.onclick = (e) => {
                e.stopPropagation();
                openVideoTextEditor();
            };

            overlay.ondragstart = (e) => {
                e.dataTransfer.effectAllowed = 'move';
                recordingState.textDragStartX = e.clientX;
                recordingState.textDragStartY = e.clientY;
            };

            previewWrapper.ondragover = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            previewWrapper.ondrop = (e) => {
                e.preventDefault();
                const rect = previewWrapper.getBoundingClientRect();
                const newX = e.clientX - rect.left - (rect.width / 2);
                const newY = e.clientY - rect.top - (rect.height / 2);

                // Update position
                recordingState.videoTextOverlay.offsetX = Math.round(newX);
                recordingState.videoTextOverlay.offsetY = Math.round(newY);

                // Update overlay position
                overlay.style.left = `calc(50% + ${newX}px)`;
                overlay.style.top = `calc(50% + ${newY}px)`;

                console.log(' Text moved to:', { x: newX, y: newY });
                showToastRecording(' Text moved', 'success', '');
            };

            previewWrapper.appendChild(overlay);

            console.log(' Text overlay applied to video:', { text, size, color });
            showToastRecording(` Text added (${size}px) - Drag to move`, 'success', '');
            closeVideoTextModal();
        }

        function openVideoTrimEditor() {
            console.log(' Opening video trim editor');
            toggleRecEditMenu(); // Close menu
            closeVideoTrimModal(); // Close any existing modal

            const video = document.getElementById('editVideoPreview');
            if (!video || !video.duration) {
                showToastRecording(' Video not ready for trimming', 'error', '');
                return;
            }

            // Initialize trim values from existing trim or full video
            const existingTrim = recordingState.videoTrim || { startPercent: 0, endPercent: 100 };

            // Show trim editor modal
            const modal = document.createElement('div');
            modal.id = 'videoTrimModal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 2px solid #4C1D95;
                border-radius: 12px;
                padding: 20px;
                z-index: 3000;
                min-width: 320px;
                color: white;
                max-height: 80vh;
                overflow-y: auto;
            `;

            modal.innerHTML = `
                <h3 style="margin-top: 0; color: #fff;"> Trim Video</h3>
                <p style="color: #aaa; font-size: 12px; margin-bottom: 15px;">Drag sliders to select keep portion</p>
                
                <div style="background: rgba(76, 29, 149, 0.2); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <label style="color: #aaa; font-size: 12px; display: block; margin-bottom: 8px;">
                         Trim Start: <span id="trimStartLabel" style="color: #fff; font-weight: bold;">0:00</span>
                    </label>
                    <input type="range" id="trimStart" min="0" max="100" value="${existingTrim.startPercent}" 
                        style="width: 100%; cursor: pointer; margin-bottom: 12px;"
                        oninput="updateVideoTrimPreview()">
                </div>
                
                <div style="background: rgba(76, 29, 149, 0.2); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <label style="color: #aaa; font-size: 12px; display: block; margin-bottom: 8px;">
                         Trim End: <span id="trimEndLabel" style="color: #fff; font-weight: bold;">0:00</span>
                    </label>
                    <input type="range" id="trimEnd" min="0" max="100" value="${existingTrim.endPercent}" 
                        style="width: 100%; cursor: pointer;"
                        oninput="updateVideoTrimPreview()">
                </div>

                <div style="background: rgba(0, 255, 0, 0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(0, 255, 0, 0.3); margin-bottom: 15px; font-size: 12px; color: #86efac;">
                     Keep Duration: <span id="trimDurationLabel">Full video</span>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button onclick="applyVideoTrim()" style="flex: 1; padding: 10px; background: #4C1D95; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Apply Trim</button>
                    <button onclick="closeVideoTrimModal()" style="flex: 1; padding: 10px; background: #333; color: white; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
                </div>
            `;
            document.body.appendChild(modal);
            updateVideoTrimPreview();
            showToastRecording(' Adjust trim points - green area will be kept', 'info', '');
        }

        function updateVideoTrimPreview() {
            const video = document.getElementById('editVideoPreview');
            if (!video || !video.duration) return;

            const startSlider = document.getElementById('trimStart');
            const endSlider = document.getElementById('trimEnd');

            const startPercent = parseFloat(startSlider.value);
            const endPercent = parseFloat(endSlider.value);

            const startTime = (startPercent / 100) * video.duration;
            const endTime = (endPercent / 100) * video.duration;
            const keepDuration = endTime - startTime;

            // Ensure valid range
            if (startPercent >= endPercent) {
                endSlider.value = Math.min(startPercent + 1, 100);
            }

            // Update labels
            document.getElementById('trimStartLabel').textContent = formatTime(startTime);
            document.getElementById('trimEndLabel').textContent = formatTime(endTime);
            document.getElementById('trimDurationLabel').textContent = formatTime(keepDuration);

            // Live preview - seek to start position
            video.currentTime = startTime;
        }

        function closeVideoTrimModal() {
            const modal = document.getElementById('videoTrimModal');
            if (modal) modal.remove();
        }

        function applyVideoTrim() {
            const video = document.getElementById('editVideoPreview');
            const startPercent = parseFloat(document.getElementById('trimStart').value);
            const endPercent = parseFloat(document.getElementById('trimEnd').value);

            if (startPercent >= endPercent) {
                showToastRecording(' Invalid trim range', 'warning', '');
                return;
            }

            // Store trim data in recording state
            recordingState.videoTrim = {
                startPercent,
                endPercent,
                startTime: (startPercent / 100) * video.duration,
                endTime: (endPercent / 100) * video.duration
            };

            // Update video playable range visually
            const startTime = recordingState.videoTrim.startTime;
            const endTime = recordingState.videoTrim.endTime;

            // Seek video to start position
            video.currentTime = startTime;

            console.log(' Video trim applied:', {
                startPercent: startPercent.toFixed(1),
                endPercent: endPercent.toFixed(1),
                duration: ((endPercent - startPercent) / 100 * video.duration).toFixed(2) + 's'
            });

            showToastRecording(
                ` Video trimmed: ${formatTime(startTime)}  ${formatTime(endTime)}`,
                'success',
                ''
            );
            closeVideoTrimModal();
        }

        function openVideoEffectsEditor() {
            toggleRecEditMenu(); // Close menu

            const effects = [
                { name: ' Sparkle', id: 'sparkle' },
                { name: ' Hearts', id: 'hearts' },
                { name: ' Stars', id: 'stars' },
                { name: ' Snow', id: 'snow' },
                { name: ' Glow', id: 'glow' },
                { name: ' Bokeh', id: 'bokeh' }
            ];

            const effectButtons = effects.map(effect =>
                `<button class="modal-btn" style="margin-bottom: 10px;" onclick="applyVideoEffect('${effect.id}')">${effect.name}</button>`
            ).join('');

            const modal = document.createElement('div');
            modal.id = 'videoEffectsModal';
            modal.className = 'modal-overlay active';
            modal.innerHTML = `
                <div class="modal" style="max-width: 400px;">
                    <button class="modal-close" onclick="closeVideoEffectsEditor()"></button>
                    <h2>Video Effects</h2>
                    <p style="color: #aaa; font-size: 12px; margin-bottom: 15px;">Choose effect to apply:</p>
                    ${effectButtons}
                    <button class="modal-btn" style="background: rgba(255, 255, 255, 0.1);" onclick="closeVideoEffectsEditor()">Close</button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function applyVideoEffect(effectId) {
            recordingState.videoEffect = effectId;
            showToastRecording(` Effect applied: ${effectId}`, 'success', '');
            closeVideoEffectsEditor();
        }

        function closeVideoEffectsEditor() {
            const modal = document.getElementById('videoEffectsModal');
            if (modal) modal.remove();
        }

        function openVideoTemplates() {
            console.log(' Opening video templates');
            toggleRecEditMenu(); // Close menu
            closeVideoTemplatesModal(); // Close any existing modal

            const templates = [
                {
                    id: 'fade-transition',
                    name: ' Fade Transition',
                    description: 'Smooth fade between clips',
                    preview: '',
                    type: 'transition'
                },
                {
                    id: 'slide-transition',
                    name: ' Slide Transition',
                    description: 'Slide from left to right',
                    preview: '',
                    type: 'transition'
                },
                {
                    id: 'zoom-transition',
                    name: ' Zoom Transition',
                    description: 'Dynamic zoom effect',
                    preview: '',
                    type: 'transition'
                },
                {
                    id: 'border-frame',
                    name: ' Border Frame',
                    description: 'Add decorative border',
                    preview: '',
                    type: 'layout'
                },
                {
                    id: 'split-screen',
                    name: ' Split Screen',
                    description: 'Multi-view layout',
                    preview: '',
                    type: 'layout'
                },
                {
                    id: 'picture-in-picture',
                    name: ' Picture in Picture',
                    description: 'Nested video view',
                    preview: '',
                    type: 'layout'
                },
                {
                    id: 'vignette',
                    name: ' Vignette',
                    description: 'Dark edges fade effect',
                    preview: '',
                    type: 'filter'
                },
                {
                    id: 'vintage-film',
                    name: ' Vintage Film',
                    description: 'Classic film look',
                    preview: '',
                    type: 'filter'
                }
            ];

            // Create modal
            const modal = document.createElement('div');
            modal.id = 'videoTemplatesModal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 2px solid #4C1D95;
                border-radius: 12px;
                padding: 20px;
                z-index: 3000;
                min-width: 350px;
                max-width: 500px;
                color: white;
                max-height: 80vh;
                overflow-y: auto;
            `;

            const templateGrid = templates.map(template => `
                <div onclick="applyVideoTemplate('${template.id}')" 
                    style="
                        background: rgba(76, 29, 149, 0.1);
                        border: 2px solid rgba(76, 29, 149, 0.3);
                        border-radius: 10px;
                        padding: 15px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        margin-bottom: 10px;
                    "
                    onmouseover="this.style.background='rgba(76, 29, 149, 0.2)'; this.style.borderColor='rgba(76, 29, 149, 0.6)'"
                    onmouseout="this.style.background='rgba(76, 29, 149, 0.1)'; this.style.borderColor='rgba(76, 29, 149, 0.3)'">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="font-size: 32px;">${template.preview}</div>
                        <div style="flex: 1;">
                            <div style="color: #fff; font-weight: 600; font-size: 14px;">${template.name}</div>
                            <div style="color: #aaa; font-size: 12px; margin-top: 3px;">${template.description}</div>
                            <div style="color: #888; font-size: 11px; margin-top: 4px;">Type: ${template.type.toUpperCase()}</div>
                        </div>
                        <div style="color: #64c8ff; font-size: 18px;"></div>
                    </div>
                </div>
            `).join('');

            modal.innerHTML = `
                <h3 style="margin-top: 0; color: #fff;"> Video Templates</h3>
                <p style="color: #aaa; font-size: 12px; margin-bottom: 15px;">Choose a template to apply:</p>
                
                ${templateGrid}
                
                <button onclick="closeVideoTemplatesModal()" style="width: 100%; padding: 10px; background: #333; color: white; border: none; border-radius: 6px; cursor: pointer; margin-top: 10px;">Close</button>
            `;

            document.body.appendChild(modal);
            showToastRecording(' Select a template to apply', 'info', '');
        }

        function applyVideoTemplate(templateId) {
            console.log(' Applying template:', templateId);

            const video = document.getElementById('editVideoPreview');
            const wrapper = document.querySelector('.edit-video-wrapper');

            if (!video || !wrapper) {
                showToastRecording(' Video not ready', 'error', '');
                return;
            }

            // Store template in recording state
            recordingState.videoTemplate = templateId;

            // Remove existing split preview if any
            const existingSplit = wrapper.querySelector('[data-split-preview]');
            if (existingSplit) {
                existingSplit.remove();
            }

            // For split-screen template: show split preview with original on both sides
            if (templateId === 'split-screen') {
                // Create split screen container
                const splitContainer = document.createElement('div');
                splitContainer.setAttribute('data-split-preview', 'true');
                splitContainer.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    display: flex;
                    background: #000;
                    overflow: hidden;
                    z-index: 1;
                `;

                // Left side - Original video
                const leftSide = document.createElement('div');
                leftSide.style.cssText = `
                    flex: 1;
                    position: relative;
                    background: #000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                const leftVideo = video.cloneNode(true);
                leftVideo.style.width = '100%';
                leftVideo.style.height = '100%';
                leftVideo.style.objectFit = 'contain';
                leftSide.appendChild(leftVideo);

                // Add label
                const leftLabel = document.createElement('div');
                leftLabel.style.cssText = `
                    position: absolute;
                    top: 10px;
                    left: 10px;
                    background: rgba(0, 0, 0, 0.7);
                    color: #aaa;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 11px;
                    z-index: 10;
                `;
                leftLabel.textContent = 'Original';
                leftSide.appendChild(leftLabel);

                // Right side - Original video (same)
                const rightSide = document.createElement('div');
                rightSide.style.cssText = `
                    flex: 1;
                    position: relative;
                    background: #000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                const rightVideo = video.cloneNode(true);
                rightVideo.style.width = '100%';
                rightVideo.style.height = '100%';
                rightVideo.style.objectFit = 'contain';
                rightSide.appendChild(rightVideo);

                // Add label
                const rightLabel = document.createElement('div');
                rightLabel.style.cssText = `
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    background: rgba(76, 29, 149, 0.9);
                    color: #fff;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 11px;
                    z-index: 10;
                `;
                rightLabel.textContent = 'Original';
                rightSide.appendChild(rightLabel);

                // Sync play/pause between both videos
                leftVideo.addEventListener('play', () => rightVideo.play());
                leftVideo.addEventListener('pause', () => rightVideo.pause());
                rightVideo.addEventListener('play', () => leftVideo.play());
                rightVideo.addEventListener('pause', () => rightVideo.pause());

                // Sync current time
                leftVideo.addEventListener('timeupdate', () => {
                    if (Math.abs(rightVideo.currentTime - leftVideo.currentTime) > 0.1) {
                        rightVideo.currentTime = leftVideo.currentTime;
                    }
                });

                // Add to wrapper
                splitContainer.appendChild(leftSide);
                splitContainer.appendChild(rightSide);
                wrapper.appendChild(splitContainer);

                // Hide original video
                video.style.display = 'none';

                showToastRecording(' Split preview - Both original sides', 'success', '');
                console.log(' Split template preview created');
                closeVideoTemplatesModal();
            } else {
                // For all other templates: apply directly to full video
                video.style.display = 'block';

                // Reset previous template styles
                video.style.filter = '';
                video.style.border = '';
                video.style.borderRadius = '';
                video.style.boxShadow = '';
                video.style.animation = '';

                // Apply template to full video
                applyTemplateToElement(video, templateId);

                const templateNames = {
                    'fade-transition': ' Fade',
                    'slide-transition': ' Slide',
                    'zoom-transition': ' Zoom',
                    'border-frame': ' Border',
                    'picture-in-picture': ' PiP',
                    'vignette': ' Vignette',
                    'vintage-film': ' Vintage'
                };

                showToastRecording(` ${templateNames[templateId] || templateId} applied`, 'success', '');
                console.log(' Template applied:', templateId);
                closeVideoTemplatesModal();
            }
        }

        function applyTemplateToElement(videoElement, templateId) {
            // Reset styles
            videoElement.style.filter = '';
            videoElement.style.border = '';
            videoElement.style.borderRadius = '';
            videoElement.style.boxShadow = '';
            videoElement.style.animation = '';

            // Apply template
            switch (templateId) {
                case 'fade-transition':
                    videoElement.style.animation = 'fadeIn 0.5s ease forwards';
                    break;
                case 'slide-transition':
                    videoElement.style.animation = 'slideInRight 0.6s ease forwards';
                    break;
                case 'zoom-transition':
                    videoElement.style.animation = 'zoomIn 0.6s ease forwards';
                    break;
                case 'border-frame':
                    videoElement.style.border = '10px solid rgba(76, 29, 149, 0.9)';
                    videoElement.style.borderRadius = '12px';
                    videoElement.style.boxShadow = '0 0 30px rgba(76, 29, 149, 0.6)';
                    break;
                case 'picture-in-picture':
                    videoElement.style.filter = 'drop-shadow(0 8px 25px rgba(76, 29, 149, 0.7))';
                    videoElement.style.borderRadius = '16px';
                    break;
                case 'vignette':
                    videoElement.style.boxShadow = 'inset 0 0 40px rgba(0, 0, 0, 0.7)';
                    break;
                case 'vintage-film':
                    videoElement.style.filter = 'sepia(0.35) contrast(0.85) brightness(0.9)';
                    break;
            }
        }

        function updateTemplateIndicator(templateId) {
            // Remove previous indicator
            const prevIndicator = document.querySelector('[data-template-indicator]');
            if (prevIndicator) prevIndicator.remove();

            // Add visual indicator showing current template
            const templates = {
                'fade-transition': ' Fade',
                'slide-transition': ' Slide',
                'zoom-transition': ' Zoom',
                'border-frame': ' Border',
                'split-screen': ' Split',
                'picture-in-picture': ' PiP',
                'vignette': ' Vignette',
                'vintage-film': ' Vintage'
            };

            const indicator = document.createElement('div');
            indicator.setAttribute('data-template-indicator', 'true');
            indicator.style.cssText = `
                position: fixed;
                bottom: 120px;
                left: 20px;
                background: rgba(76, 29, 149, 0.9);
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 12px;
                font-weight: 600;
                z-index: 1000;
                animation: slideInRight 0.3s ease forwards;
            `;
            indicator.textContent = templates[templateId] || templateId;
            document.body.appendChild(indicator);

            // Auto-remove after 2 seconds
            setTimeout(() => {
                if (indicator.parentElement) {
                    indicator.style.animation = 'slideOutRight 0.3s ease forwards';
                    setTimeout(() => indicator.remove(), 300);
                }
            }, 2000);
        }

        function closeVideoTemplatesModal() {
            const modal = document.getElementById('videoTemplatesModal');
            if (modal) modal.remove();
        }

        function openVideoSoundLibrary() {
            // Reuse existing sound library
            openSoundLibrary();
        }

        function saveVideoAsDraft() {
            showToastRecording('Video saved to drafts ', 'success', '');
        }



        // ============================================================================
        // EFFECTS
        // ============================================================================

        // ============================================================================
        // PHOTO MODE - SCREEN 5, 6, 7
        // ============================================================================

        let photoState = {
            photoStream: null,
            capturedPhotos: [],
            currentPhotoIndex: 0,
            cameraFacingMode: 'environment',  // 'environment' for back camera, 'user' for front camera
            photoSettings: {
                flash: false,
                timer: 0,
                filter: 'none',
                grid: false,
                ratio: '9:16',
                effects: []
            },
            selectedSound: null,
            canvas: null,
            ctx: null
        };

        // Initialize photo camera - request permissions once
        async function initializePhotoMode() {
            try {
                // Check if camera is already initialized
                if (photoState.photoStream && photoState.photoStream.active) {
                    console.log(' Camera already active');
                    ensureVideoElement();
                    return;
                }

                console.log(' Requesting camera access...');

                // Simple, no constraints - just ask for video and audio
                photoState.photoStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });

                console.log(' Camera access granted');

                // Log actual camera capabilities for debugging
                const videoTrack = photoState.photoStream.getVideoTracks()[0];
                if (videoTrack) {
                    const settings = videoTrack.getSettings();
                    console.log(' Camera specs:', {
                        resolution: `${settings.width}x${settings.height}`,
                        frameRate: settings.frameRate + 'fps',
                        facingMode: settings.facingMode
                    });
                }

                // Ensure video element exists and is properly set up
                ensureVideoElement();

                // Verify camera quality settings
                verifyPhotoQualitySettings();

                showToastRecording(' Camera Ready', 'success', '');
            } catch (error) {
                console.error(' Camera error:', error.name, error.message);

                if (error.name === 'NotAllowedError') {
                    alert(' Camera permission denied.\n\nFix:\n1. Click lock  in address bar\n2. Reset permissions\n3. Reload & allow camera');
                } else if (error.name === 'NotFoundError') {
                    alert(' No camera found.\n\nOn laptop: Connect USB webcam\nOn phone: Check camera permissions in system settings');
                } else if (error.name === 'NotReadableError') {
                    alert(' Camera in use.\n\nClose: Zoom, Teams, other video apps, or other browser tabs');
                } else {
                    alert(' Camera error: ' + error.message);
                }

                if (photoState.photoStream) {
                    photoState.photoStream.getTracks().forEach(track => track.stop());
                    photoState.photoStream = null;
                }
            }
        }

        // Helper: Ensure video element is created and streaming
        function ensureVideoElement() {
            console.log(' ensureVideoElement called');

            if (!photoState.photoStream || !photoState.photoStream.active) {
                console.error(' Stream not active');
                return false;
            }

            console.log(' Stream is active');

            const container = document.querySelector('#screen5 .camera-preview');
            if (!container) {
                console.error(' Screen 5 container not found');
                return false;
            }

            console.log(' Container found');

            // Check if video element already exists
            let video = document.getElementById('photoPreviewVideo');

            if (!video) {
                console.log('Creating new video element...');
                // Create new video element with PROFESSIONAL QUALITY settings
                video = document.createElement('video');
                video.id = 'photoPreviewVideo';
                video.autoplay = true;
                video.muted = true;  // IMPORTANT: Mute to allow autoplay in most browsers
                video.playsinline = true;

                // Professional quality CSS
                video.style.cssText = `
                    width: 100vw;
                    height: 100vh;
                    object-fit: cover;
                    background-color: #000;
                    display: block;
                    
                    /* Prevent quality loss from browser scaling */
                    image-rendering: -webkit-optimize-contrast;
                    image-rendering: crisp-edges;
                    
                    /* Hardware acceleration for smooth rendering */
                    transform: translate3d(0, 0, 0);
                    backface-visibility: hidden;
                    will-change: transform;
                    
                    /* Prevent flickering */
                    perspective: 1000px;
                `;

                // Clear any text content from container before adding video
                container.innerHTML = '';
                container.style.background = '#000';  // Black background
                container.appendChild(video);

                console.log(' Professional video element created');
            }

            // Assign stream to video
            console.log(' Video element srcObject before:', video.srcObject ? 'has stream' : 'no stream');
            if (video.srcObject !== photoState.photoStream) {
                video.srcObject = photoState.photoStream;
                console.log(' Stream assigned to video element');
            } else {
                console.log('Stream already assigned');
            }

            console.log(' Video element display:', window.getComputedStyle(video).display);
            console.log(' Video element dimensions:', video.offsetWidth, 'x', video.offsetHeight);

            // Ensure it's playing
            console.log(' Attempting to play video...');
            video.play().then(() => {
                console.log(' Video playing');
            }).catch(err => {
                console.error(' Video play error:', err.message);
            });

            return true;
        }

        // ============================================================================
        // VERIFY PHOTO QUALITY SETTINGS - Check console for debug info
        // ============================================================================
        function verifyPhotoQualitySettings() {
            const video = document.getElementById('photoPreviewVideo');
            if (!video) return;

            console.group(' PHOTO QUALITY VERIFICATION');
            console.log(' Camera Resolution:', `${video.videoWidth}x${video.videoHeight}`);
            console.log(' Canvas Smoothing:', 'DISABLED (crisp capture)');
            console.log(' JPEG Quality:', '100% (1.0 - maximum quality)');
            console.log(' Capture Method:', 'toBlob (optimized)');
            console.log(' Filter Mode:', photoState.photoSettings.filter || 'none');
            console.log(' Aspect Ratio:', photoState.photoSettings.ratio);
            console.log(' Camera Mode:', photoState.cameraFacingMode === 'environment' ? ' Back (Higher Quality)' : ' Front');
            console.log(' Expected Photo Size:', video.videoWidth * video.videoHeight > 2073600 ? '4K or High Resolution' : 'HD Resolution');
            console.groupEnd();
        }

        // Close photo left menu after action
        function closePhotoLeftMenu() {
            const menu = document.getElementById('recPhotoLeftMenu');
            if (menu && menu.classList.contains('show')) {
                menu.classList.remove('show');
                console.log('Photo menu closed');
            }
        }

        // Toggle photo mode menus
        function togglePhotoFlash() {
            // Cycle through flash modes: off  on  auto
            const flashModes = [false, 'on', 'auto'];
            const current = photoState.photoSettings.flash;
            const currentIdx = flashModes.indexOf(current);
            photoState.photoSettings.flash = flashModes[(currentIdx + 1) % flashModes.length];

            // Update menu if exists
            const menu = document.getElementById('recPhotoLeftMenu');
            if (menu) {
                const flashItem = menu.querySelector('.rec-menu-item:nth-child(1)');
                if (flashItem) {
                    let flashText = ' Flash';
                    if (photoState.photoSettings.flash === 'on') {
                        flashItem.style.color = '#FFD700';
                        flashText = ' Flash (ON)';
                    } else if (photoState.photoSettings.flash === 'auto') {
                        flashItem.style.color = '#FFA500';
                        flashText = ' Flash (AUTO)';
                    } else {
                        flashItem.style.color = 'white';
                    }
                    flashItem.textContent = flashText;
                }
            }

            // Update bottom button state
            updatePhotoFlashButtonState();

            let message = 'Flash off';
            if (photoState.photoSettings.flash === 'on') {
                message = ' Flash ON';
            } else if (photoState.photoSettings.flash === 'auto') {
                message = ' Flash AUTO';
            }

            showToastRecording(message, 'info', '');
            if (menu) closePhotoLeftMenu();
        }

        function updatePhotoFlashButtonState() {
            const buttons = document.querySelectorAll('.photo-control-btn');
            buttons.forEach(btn => {
                if (btn.querySelector('.rec-control-icon')?.textContent === '') {
                    if (photoState.photoSettings.flash === 'on') {
                        btn.style.background = 'rgba(255, 215, 0, 0.2)';
                        btn.style.borderColor = '#FFD700';
                    } else if (photoState.photoSettings.flash === 'auto') {
                        btn.style.background = 'rgba(255, 165, 0, 0.2)';
                        btn.style.borderColor = '#FFA500';
                    } else {
                        btn.style.background = '';
                        btn.style.borderColor = '';
                    }
                }
            });
        }

        // ============================================================================
        // SWITCH PHOTO CAMERA - Toggle between front and back camera
        // ============================================================================
        async function switchPhotoCamera() {
            try {
                console.log(' Switching camera...');
                showToastRecording(' Switching camera...', 'info', '');

                // Toggle camera facing mode
                photoState.cameraFacingMode = photoState.cameraFacingMode === 'environment' ? 'user' : 'environment';
                console.log('Camera mode switched to:', photoState.cameraFacingMode);

                // Stop current stream completely
                if (photoState.photoStream) {
                    console.log('Stopping existing stream...');
                    photoState.photoStream.getTracks().forEach(track => {
                        console.log('Stopping track:', track.kind);
                        track.stop();
                    });
                    photoState.photoStream = null;
                }

                // Get video element and clear it
                const video = document.getElementById('photoPreviewVideo');
                if (video) {
                    video.srcObject = null;
                    console.log('Cleared video element');
                }

                // Request new camera with constraints
                console.log('Requesting new camera with mode:', photoState.cameraFacingMode);

                // Try with strict constraints first
                let constraints = {
                    audio: false,
                    video: {
                        facingMode: { exact: photoState.cameraFacingMode },
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };

                try {
                    photoState.photoStream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log(' Camera requested with exact facingMode');
                } catch (strictError) {
                    console.warn(' Exact facingMode not supported, trying ideal...', strictError.message);

                    // Fallback: try without exact constraint
                    constraints = {
                        audio: false,
                        video: {
                            facingMode: photoState.cameraFacingMode,
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    };

                    try {
                        photoState.photoStream = await navigator.mediaDevices.getUserMedia(constraints);
                        console.log(' Camera requested with ideal facingMode');
                    } catch (idealError) {
                        console.warn(' Ideal facingMode not supported, using any camera...', idealError.message);

                        // Final fallback: any available camera
                        constraints = {
                            audio: false,
                            video: {
                                width: { ideal: 1280 },
                                height: { ideal: 720 }
                            }
                        };
                        photoState.photoStream = await navigator.mediaDevices.getUserMedia(constraints);
                        showToastRecording(' Camera flip not supported - using available camera', 'warning', '');
                    }
                }

                // Set stream to video element
                if (video && photoState.photoStream) {
                    video.srcObject = photoState.photoStream;
                    console.log(' Stream set to video element');
                }

                const cameraType = photoState.cameraFacingMode === 'environment' ? ' Back Camera' : ' Front Camera';
                showToastRecording(`${cameraType} activated`, 'success', '');
                console.log(' Camera switched successfully');
            } catch (error) {
                console.error(' Camera switch error:', error);
                showToastRecording(' Failed to switch camera: ' + error.message, 'error', '');
            }
        }

        // ============================================================================
        // UPDATE RATIO GUIDE - Shows real-time frame preview
        // ============================================================================
        function updateRatioGuide() {
            const video = document.getElementById('photoPreviewVideo');
            const guide = document.getElementById('ratioGuide');

            if (!video || !video.videoWidth) {
                console.log('Video not ready yet');
                return;
            }

            // Aspect ratio mappings
            const ratios = {
                '1:1': 1,
                '3:4': 0.75,
                '9:16': 0.5625,
                '16:9': 1.777
            };

            const targetRatio = ratios[photoState.photoSettings.ratio] || 1.777;
            const videoRatio = video.videoWidth / video.videoHeight;

            let frameWidth = 100;  // percentage
            let frameHeight = 100; // percentage

            // Calculate which dimension to constrain
            if (videoRatio > targetRatio) {
                // Video is wider than target ratio - constrain width
                frameWidth = (targetRatio * 100) / videoRatio;
                frameHeight = 100;
            } else {
                // Video is taller than target ratio - constrain height
                frameWidth = 100;
                frameHeight = (100 * videoRatio) / targetRatio;
            }

            // Apply to guide element
            guide.style.width = frameWidth + '%';
            guide.style.height = frameHeight + '%';
            guide.style.display = 'block';

            // Log for debugging
            console.log(` Ratio Guide Updated:`, {
                ratio: photoState.photoSettings.ratio,
                frameSize: `${frameWidth.toFixed(1)}%  ${frameHeight.toFixed(1)}%`,
                videoRes: `${video.videoWidth}${video.videoHeight}`,
                videoRatio: videoRatio.toFixed(3),
                targetRatio: targetRatio.toFixed(3)
            });
        }

        function togglePhotoTimer() {
            const currentTimer = photoState.photoSettings.timer;
            const timers = [0, 3, 5, 10];
            const nextIndex = (timers.indexOf(currentTimer) + 1) % timers.length;
            photoState.photoSettings.timer = timers[nextIndex];

            // Update menu if exists
            const menu = document.getElementById('recPhotoLeftMenu');
            if (menu) {
                const timerItem = menu.querySelector('.rec-menu-item:nth-child(2)');
                if (timerItem) {
                    if (photoState.photoSettings.timer === 0) {
                        timerItem.textContent = ' Timer';
                    } else {
                        timerItem.textContent = ` ${photoState.photoSettings.timer}s`;
                    }
                }
            }

            // Update bottom button state
            updatePhotoTimerButtonState();

            const message = photoState.photoSettings.timer === 0
                ? 'Timer OFF'
                : ` Timer: ${photoState.photoSettings.timer}s`;
            showToastRecording(message, 'info', '');
            if (menu) closePhotoLeftMenu();
        }

        function updatePhotoTimerButtonState() {
            const buttons = document.querySelectorAll('.photo-control-btn');
            buttons.forEach(btn => {
                if (btn.querySelector('.rec-control-icon')?.textContent === '') {
                    if (photoState.photoSettings.timer > 0) {
                        btn.style.background = 'rgba(100, 200, 255, 0.2)';
                        btn.style.borderColor = '#64C8FF';
                        const label = btn.querySelector('.rec-control-label');
                        if (label) label.textContent = `${photoState.photoSettings.timer}s`;
                    } else {
                        btn.style.background = '';
                        btn.style.borderColor = '';
                        const label = btn.querySelector('.rec-control-label');
                        if (label) label.textContent = 'Timer';
                    }
                }
            });
        }

        // ====== HELPER FUNCTION: Get Recording Video Element ======
        function getRecordingVideoElement() {
            // Check which screen is currently active and return the appropriate video element
            const activeScreen = document.querySelector('.recording-screen.active');

            if (activeScreen?.id === 'screen2') {
                // Screen 2 is active - return recording video preview
                const recordingVideo = document.getElementById('recordingVideoPreview');
                if (recordingVideo) return recordingVideo;
            } else if (activeScreen?.id === 'screen1') {
                // Screen 1 is active - return video preview
                const videoPreview = document.getElementById('videoPreview');
                if (videoPreview) return videoPreview;
            }

            // Fallback priority order if screen detection fails
            return document.getElementById('recordingVideoPreview') ||  // Screen 2
                document.getElementById('videoPreview') ||          // Screen 1
                document.querySelector('.recording-screen.active .camera-preview') ||
                document.querySelector('.camera-preview');          // Any camera preview
        }

        // ====== RECORDING EFFECTS - TIKTOK STYLE ======
        let effectsState = {
            canvas: null,
            ctx: null,
            animationId: null,
            sparkles: [],
            stars: [],
            ghostTrail: [],
            maskOpacity: 0.3
        };

        function toggleRecordingEffects() {
            const effectsPanel = document.querySelector('.rec-effects-panel');
            if (effectsPanel) {
                effectsPanel.classList.toggle('show');
                if (effectsPanel.classList.contains('show')) {
                    showToastRecording(' Effects Opened', 'info', '');
                } else {
                    showToastRecording(' Effects Closed', 'info', '');
                }
            }
        }

        function toggleRecordingEffect(effectName) {
            // Initialize selected effects if not exists
            if (!recordingState.selectedEffects) {
                recordingState.selectedEffects = [];
            }

            // Get effect label
            const effectLabels = {
                'sparkle': 'Sparkle',
                'star': 'Star',
                'hearts': 'Hearts',
                'confetti': 'Confetti',
                'flowers': 'Flowers',
                'snow': 'Snow',
                'glow': 'Glow',
                'bokeh': 'Bokeh',
                'rainbow': 'Rainbow',
                'sunbeam': 'Sunbeam',
                'kaleidoscope': 'Kaleidoscope',
                'pixelate': 'Pixelate',
                'wave': 'Wave',
                'fisheye': 'Fisheye',
                'vhs': 'VHS',
                'glitch': 'Glitch',
                'filmburn': 'Film Burn',
                'scanlines': 'Scanlines',
                'neon': 'Neon',
                'cyberpunk': 'Cyberpunk',
                'vaporwave': 'Vaporwave',
                'ghost': 'Ghost',
                'mask': 'Mask',
                'dreamy': 'Dreamy',
                'noir': 'Noir',
                'mirror': 'Mirror',
                'clone': 'Clone',
                'afcon': 'AFCON Face'
            };

            // Check if this effect is already active
            const isCurrentlyActive = recordingState.selectedEffects.includes(effectName);

            if (isCurrentlyActive) {
                // Deactivate the effect
                recordingState.selectedEffects = [];
                stopEffect(effectName);
                const message = ` ${effectLabels[effectName]} Removed`;
                showToastRecording(message, 'info', '');
            } else {
                // Stop previous effect and start new one (exclusive mode)
                if (recordingState.selectedEffects.length > 0) {
                    const previousEffect = recordingState.selectedEffects[0];
                    stopEffect(previousEffect);
                }
                recordingState.selectedEffects = [effectName];
                startEffect(effectName);
                const message = ` ${effectLabels[effectName]} Added`;
                showToastRecording(message, 'info', '');
            }

            // Update button active state
            const effectButtons = document.querySelectorAll('.rec-effect-circular');
            effectButtons.forEach(btn => {
                const name = btn.getAttribute('onclick').match(/'([^']+)'/)[1];
                if (recordingState.selectedEffects.includes(name)) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function startEffect(effectName) {
            const video = getRecordingVideoElement();
            if (!video) {
                console.error(' No video element found for effects');
                return;
            }

            console.log(' Starting effect:', effectName, 'Video:', video.id);

            // Create or reuse effects canvas
            if (!effectsState.canvas) {
                effectsState.canvas = document.createElement('canvas');

                // Set canvas styling BEFORE appending
                effectsState.canvas.id = 'effectsOverlayCanvas';
                effectsState.canvas.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    zIndex: 10;
                    pointerEvents: none;
                    display: block;
                    background: transparent;
                `;

                // Get the correct parent (the screen container)
                let parent = video.parentElement;

                // Ensure parent is positioned
                const currentPosition = window.getComputedStyle(parent).position;
                if (currentPosition === 'static' || !currentPosition) {
                    parent.style.position = 'relative';
                }
                parent.style.overflow = 'hidden';

                // Insert canvas right after video (so it overlays)
                video.insertAdjacentElement('afterend', effectsState.canvas);

                effectsState.ctx = effectsState.canvas.getContext('2d');

                // Set initial canvas size
                resizeEffectsCanvas();

                // Draw test rectangle to verify canvas is visible
                if (effectsState.ctx && effectsState.canvas.width > 0 && effectsState.canvas.height > 0) {
                    effectsState.ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                    effectsState.ctx.fillRect(0, 0, effectsState.canvas.width, effectsState.canvas.height);
                    console.log(' Test rectangle drawn on canvas');
                }

                // Also resize on timeout to handle any layout shifts
                setTimeout(() => {
                    resizeEffectsCanvas();
                }, 50);

                window.addEventListener('resize', resizeEffectsCanvas);

                console.log(' Effects canvas created');
                console.log(' Canvas parent:', parent.id, parent.className);
                console.log(' Canvas element:', effectsState.canvas.id);
                console.log(' Canvas dimensions:', effectsState.canvas.width, 'x', effectsState.canvas.height);
            }

            // Particle Effects
            if (effectName === 'sparkle') {
                startSparkleEffect();
            } else if (effectName === 'star') {
                startStarEffect();
            } else if (effectName === 'hearts') {
                startHeartsEffect();
            } else if (effectName === 'confetti') {
                startConfettiEffect();
            } else if (effectName === 'flowers') {
                startFlowersEffect();
            } else if (effectName === 'snow') {
                startSnowEffect();
            }
            // Light & Glow Effects
            else if (effectName === 'glow') {
                applyGlowEffect();
            } else if (effectName === 'bokeh') {
                applyBokehEffect();
            } else if (effectName === 'rainbow') {
                applyRainbowEffect();
            } else if (effectName === 'sunbeam') {
                applySunbeamEffect();
            }
            // Distortion Effects
            else if (effectName === 'kaleidoscope') {
                applyKaleidoscopeEffect();
            } else if (effectName === 'pixelate') {
                applyPixelateEffect();
            } else if (effectName === 'wave') {
                applyWaveEffect();
            } else if (effectName === 'fisheye') {
                applyFisheyeEffect();
            }
            // Retro/Film Effects
            else if (effectName === 'vhs') {
                applyVHSEffect();
            } else if (effectName === 'glitch') {
                applyGlitchEffect();
            } else if (effectName === 'filmburn') {
                applyFilmBurnEffect();
            } else if (effectName === 'scanlines') {
                applyScanLinesEffect();
            }
            // Neon & Vibrant Effects
            else if (effectName === 'neon') {
                applyNeonEffect();
            } else if (effectName === 'cyberpunk') {
                applyCyberpunkEffect();
            } else if (effectName === 'vaporwave') {
                applyVaporwaveEffect();
            }
            // Mood Effects
            else if (effectName === 'ghost') {
                startGhostEffect();
            } else if (effectName === 'mask') {
                applyMaskEffect();
            } else if (effectName === 'dreamy') {
                applyDreamyEffect();
            } else if (effectName === 'noir') {
                applyNoirEffect();
            }
            // Clone & Mirror
            else if (effectName === 'mirror') {
                applyMirrorEffect();
            } else if (effectName === 'clone') {
                startCloneEffect();
            }
            // AFCON Face Effect
            else if (effectName === 'afcon') {
                startAFCONEffect();
            }
        }

        function stopEffect(effectName) {
            const video = getRecordingVideoElement();

            // Particle & Canvas-based Effects
            const canvasEffects = ['sparkle', 'star', 'ghost', 'hearts', 'confetti', 'flowers', 'snow', 'bokeh', 'rainbow', 'clone', 'afcon'];
            if (canvasEffects.includes(effectName)) {
                if (effectsState.animationId) {
                    cancelAnimationFrame(effectsState.animationId);
                    effectsState.animationId = null;
                }
                // Clear effects canvas
                if (effectsState.canvas && effectsState.ctx) {
                    effectsState.ctx.clearRect(0, 0, effectsState.canvas.width, effectsState.canvas.height);
                }
                // Clear particles
                effectsState.sparkles = [];
                effectsState.stars = [];
                effectsState.ghostTrail = [];
            }

            // Filter-based Effects
            const filterEffects = ['glow', 'vhs', 'glitch', 'filmburn', 'scanlines', 'neon', 'cyberpunk', 'vaporwave', 'mask', 'dreamy', 'noir', 'pixelate', 'wave', 'fisheye', 'kaleidoscope', 'sunbeam', 'mirror'];
            if (filterEffects.includes(effectName)) {
                if (video) {
                    video.style.filter = '';
                }
            }
        }

        function resizeEffectsCanvas() {
            const video = getRecordingVideoElement();
            if (!video || !effectsState.canvas) return;

            // Try multiple ways to get dimensions
            let width = video.offsetWidth || video.clientWidth || video.videoWidth || window.innerWidth;
            let height = video.offsetHeight || video.clientHeight || video.videoHeight || window.innerHeight;

            // If recording canvas exists, match its dimensions
            if (recordingState.recordingCanvas) {
                width = recordingState.recordingCanvas.width;
                height = recordingState.recordingCanvas.height;
            }

            // Ensure minimum size
            if (width < 100) width = 480;
            if (height < 100) height = 360;

            effectsState.canvas.width = width;
            effectsState.canvas.height = height;
            console.log(' Effects canvas resized to:', width, 'x', height);
        }

        function startSparkleEffect() {
            let debugLogged = false;

            const animate = () => {
                if (!recordingState.selectedEffects.includes('sparkle')) return;

                const canvas = effectsState.canvas;
                const ctx = effectsState.ctx;

                // Debug log on first frame only
                if (!debugLogged) {
                    console.log(' Sparkle animation started');
                    console.log('Canvas size:', canvas.width, 'x', canvas.height);
                    console.log('Context:', ctx ? 'Ready' : 'Not ready');
                    debugLogged = true;
                }

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Add new sparkles
                if (Math.random() > 0.7) {
                    effectsState.sparkles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 3 + 1,
                        opacity: 1,
                        decay: Math.random() * 0.02 + 0.01
                    });
                }

                // Update and draw sparkles
                effectsState.sparkles = effectsState.sparkles.filter(sparkle => {
                    sparkle.opacity -= sparkle.decay;
                    sparkle.size += 0.1;

                    ctx.fillStyle = `rgba(255, 255, 255, ${sparkle.opacity})`;
                    ctx.beginPath();
                    ctx.arc(sparkle.x, sparkle.y, sparkle.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw sparkle rays
                    ctx.strokeStyle = `rgba(255, 255, 255, ${sparkle.opacity * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(sparkle.x - sparkle.size * 2, sparkle.y);
                    ctx.lineTo(sparkle.x + sparkle.size * 2, sparkle.y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(sparkle.x, sparkle.y - sparkle.size * 2);
                    ctx.lineTo(sparkle.x, sparkle.y + sparkle.size * 2);
                    ctx.stroke();

                    return sparkle.opacity > 0;
                });

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function startStarEffect() {
            const animate = () => {
                if (!recordingState.selectedEffects.includes('star')) return;

                const canvas = effectsState.canvas;
                const ctx = effectsState.ctx;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Add new stars
                if (Math.random() > 0.8) {
                    effectsState.stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 15 + 10,
                        rotation: Math.random() * Math.PI * 2,
                        opacity: 1,
                        decay: Math.random() * 0.015 + 0.01,
                        rotationSpeed: Math.random() * 0.1 - 0.05
                    });
                }

                // Update and draw stars
                effectsState.stars = effectsState.stars.filter(star => {
                    star.opacity -= star.decay;
                    star.rotation += star.rotationSpeed;

                    ctx.save();
                    ctx.translate(star.x, star.y);
                    ctx.rotate(star.rotation);
                    ctx.fillStyle = `rgba(255, 223, 0, ${star.opacity})`;
                    ctx.shadowColor = `rgba(255, 223, 0, ${star.opacity * 0.8})`;
                    ctx.shadowBlur = 10;

                    // Draw 5-pointed star
                    drawStar(ctx, 0, 0, 5, star.size / 2, star.size / 4);

                    ctx.restore();
                    return star.opacity > 0;
                });

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI / 2 * 3;
            let step = Math.PI / spikes;

            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                ctx.lineTo(cx + Math.cos(rot) * outerRadius, cy + Math.sin(rot) * outerRadius);
                rot += step;

                ctx.lineTo(cx + Math.cos(rot) * innerRadius, cy + Math.sin(rot) * innerRadius);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fill();
        }

        function startGhostEffect() {
            const animate = () => {
                if (!recordingState.selectedEffects.includes('ghost')) return;

                const canvas = effectsState.canvas;
                const ctx = effectsState.ctx;
                const video = getRecordingVideoElement();

                if (!video) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw video with ghost trail
                ctx.globalAlpha = 0.3;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;

                // Fade trail
                effectsState.ghostTrail = effectsState.ghostTrail.filter(frame => frame.opacity > 0);

                effectsState.ghostTrail.forEach(frame => {
                    ctx.globalAlpha = frame.opacity;
                    ctx.drawImage(frame.canvas, 0, 0);
                    frame.opacity -= 0.05;
                });

                // Add current frame to trail
                if (effectsState.ghostTrail.length < 5) {
                    const trailCanvas = document.createElement('canvas');
                    trailCanvas.width = canvas.width;
                    trailCanvas.height = canvas.height;
                    const trailCtx = trailCanvas.getContext('2d');
                    trailCtx.drawImage(video, 0, 0);
                    effectsState.ghostTrail.unshift({ canvas: trailCanvas, opacity: 0.6 });
                }

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function startHeartsEffect() {
            const animate = () => {
                if (!recordingState.selectedEffects.includes('hearts')) return;

                const canvas = effectsState.canvas;
                const ctx = effectsState.ctx;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Add new hearts
                if (Math.random() > 0.85) {
                    effectsState.sparkles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 20 + 15,
                        opacity: 1,
                        decay: Math.random() * 0.01 + 0.005,
                        vx: Math.random() * 2 - 1,
                        vy: Math.random() * 2 - 2
                    });
                }

                // Update and draw hearts
                effectsState.sparkles = effectsState.sparkles.filter(heart => {
                    heart.opacity -= heart.decay;
                    heart.x += heart.vx;
                    heart.y += heart.vy;

                    ctx.fillStyle = `rgba(255, 100, 150, ${heart.opacity})`;
                    ctx.font = `bold ${heart.size}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('', heart.x, heart.y);

                    return heart.opacity > 0;
                });

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function startConfettiEffect() {
            const animate = () => {
                if (!recordingState.selectedEffects.includes('confetti')) return;

                const canvas = effectsState.canvas;
                const ctx = effectsState.ctx;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Add new confetti
                if (Math.random() > 0.80) {
                    for (let i = 0; i < 3; i++) {
                        effectsState.sparkles.push({
                            x: Math.random() * canvas.width,
                            y: -10,
                            size: Math.random() * 5 + 3,
                            opacity: 1,
                            decay: Math.random() * 0.01 + 0.008,
                            vx: Math.random() * 3 - 1.5,
                            vy: Math.random() * 3 + 2,
                            rotation: Math.random() * Math.PI * 2,
                            rotationSpeed: Math.random() * 0.2 - 0.1
                        });
                    }
                }

                // Update and draw confetti
                effectsState.sparkles = effectsState.sparkles.filter(c => {
                    c.opacity -= c.decay;
                    c.x += c.vx;
                    c.y += c.vy;
                    c.rotation += c.rotationSpeed;
                    c.vy += 0.15; // gravity

                    ctx.save();
                    ctx.translate(c.x, c.y);
                    ctx.rotate(c.rotation);
                    ctx.fillStyle = `hsla(${Math.random() * 360}, 100%, 60%, ${c.opacity})`;
                    ctx.fillRect(-c.size, -c.size, c.size * 2, c.size * 2);
                    ctx.restore();

                    return c.opacity > 0 && c.y < canvas.height;
                });

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function applyGlowEffect() {
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = 'brightness(1.15) drop-shadow(0 0 20px rgba(200, 150, 255, 0.6))';
            }
        }

        function applyBokehEffect() {
            const canvas = effectsState.canvas;
            const ctx = effectsState.ctx;
            const video = getRecordingVideoElement();

            const animate = () => {
                if (!recordingState.selectedEffects.includes('bokeh')) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw bokeh circles
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const size = Math.random() * 40 + 20;
                    const opacity = Math.random() * 0.3 + 0.1;

                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function applyVHSEffect() {
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = 'contrast(1.1) brightness(0.9) hue-rotate(5deg)';
            }
        }

        function applyNeonEffect() {
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = 'brightness(1.2) saturate(1.8) contrast(1.3) hue-rotate(20deg) drop-shadow(0 0 10px rgba(0, 255, 255, 0.8))';
            }
        }

        function applyPixelateEffect() {
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = 'blur(4px)';
                video.style.imageRendering = 'pixelated';
            }
        }

        function applyKaleidoscopeEffect() {
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = 'saturate(1.5) hue-rotate(45deg) brightness(1.1) contrast(1.2)';
            }
        }

        function applyMaskEffect() {
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = 'brightness(1.1) saturate(1.2) hue-rotate(30deg) drop-shadow(0 0 15px rgba(255, 0, 255, 0.5))';
            }
        }

        // ====== NEW PARTICLE EFFECTS ======
        function startFlowersEffect() {
            const animate = () => {
                if (!recordingState.selectedEffects.includes('flowers')) return;
                const canvas = effectsState.canvas;
                const ctx = effectsState.ctx;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (Math.random() > 0.85) {
                    effectsState.sparkles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height - 50,
                        size: Math.random() * 15 + 10,
                        opacity: 1,
                        decay: Math.random() * 0.008 + 0.004,
                        vx: Math.random() * 1.5 - 0.75,
                        vy: Math.random() * 1 + 0.5,
                        rotation: Math.random() * Math.PI * 2
                    });
                }

                effectsState.sparkles = effectsState.sparkles.filter(flower => {
                    flower.opacity -= flower.decay;
                    flower.x += flower.vx;
                    flower.y += flower.vy;
                    flower.rotation += 0.02;

                    ctx.save();
                    ctx.translate(flower.x, flower.y);
                    ctx.rotate(flower.rotation);
                    ctx.fillStyle = `hsla(${340 + Math.random() * 20}, 100%, 60%, ${flower.opacity})`;
                    ctx.font = `bold ${flower.size}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('', 0, 0);
                    ctx.restore();
                    return flower.opacity > 0;
                });

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function startSnowEffect() {
            const animate = () => {
                if (!recordingState.selectedEffects.includes('snow')) return;
                const canvas = effectsState.canvas;
                const ctx = effectsState.ctx;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (Math.random() > 0.8) {
                    for (let i = 0; i < 5; i++) {
                        effectsState.sparkles.push({
                            x: Math.random() * canvas.width,
                            y: -10,
                            size: Math.random() * 4 + 2,
                            opacity: 0.8,
                            decay: Math.random() * 0.005 + 0.002,
                            vx: Math.random() * 0.5 - 0.25,
                            vy: Math.random() * 1 + 0.5
                        });
                    }
                }

                effectsState.sparkles = effectsState.sparkles.filter(snowflake => {
                    snowflake.opacity -= snowflake.decay;
                    snowflake.x += snowflake.vx;
                    snowflake.y += snowflake.vy;

                    ctx.fillStyle = `rgba(255, 255, 255, ${snowflake.opacity})`;
                    ctx.beginPath();
                    ctx.arc(snowflake.x, snowflake.y, snowflake.size, 0, Math.PI * 2);
                    ctx.fill();
                    return snowflake.opacity > 0 && snowflake.y < canvas.height;
                });

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        // ====== NEW LIGHT & GLOW EFFECTS ======
        function applyRainbowEffect() {
            const video = getRecordingVideoElement();
            if (!video) return;

            const animate = () => {
                if (!recordingState.selectedEffects.includes('rainbow')) return;
                const hue = (Date.now() / 20) % 360;
                video.style.filter = `hue-rotate(${hue}deg) saturate(1.4) brightness(1.1)`;
                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function applySunbeamEffect() {
            const canvas = effectsState.canvas;
            const ctx = effectsState.ctx;
            const video = getRecordingVideoElement();

            const animate = () => {
                if (!recordingState.selectedEffects.includes('sunbeam')) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const beamCount = 12;
                const rotation = (Date.now() / 50) % (Math.PI * 2);

                for (let i = 0; i < beamCount; i++) {
                    const angle = (i / beamCount) * Math.PI * 2 + rotation;
                    ctx.strokeStyle = `rgba(255, 200, 0, 0.1)`;
                    ctx.lineWidth = 30;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(
                        centerX + Math.cos(angle) * 500,
                        centerY + Math.sin(angle) * 500
                    );
                    ctx.stroke();
                }

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        // ====== NEW DISTORTION EFFECTS ======
        function applyWaveEffect() {
            const video = getRecordingVideoElement();
            if (!video) return;

            const animate = () => {
                if (!recordingState.selectedEffects.includes('wave')) return;
                const wave = Math.sin(Date.now() / 200) * 5;
                video.style.filter = `skewY(${wave}deg) brightness(1.05)`;
                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function applyFisheyeEffect() {
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = 'blur(1px) brightness(1.1)';
                video.style.borderRadius = '50%';
            }
        }

        // ====== NEW RETRO/FILM EFFECTS ======
        function applyGlitchEffect() {
            const canvas = effectsState.canvas;
            const ctx = effectsState.ctx;
            const video = getRecordingVideoElement();

            const animate = () => {
                if (!recordingState.selectedEffects.includes('glitch')) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (Math.random() > 0.85) {
                    const sliceHeight = Math.random() * 50 + 10;
                    const sliceY = Math.random() * canvas.height;
                    const offset = Math.random() * 20 - 10;

                    ctx.fillStyle = 'rgba(255, 0, 100, 0.15)';
                    ctx.fillRect(0, sliceY, canvas.width, sliceHeight);
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
                    ctx.fillRect(offset, sliceY, canvas.width, sliceHeight);
                }

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function applyFilmBurnEffect() {
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = 'sepia(30%) brightness(0.85) contrast(1.1) hue-rotate(15deg)';
                video.style.border = '2px solid rgba(139, 69, 19, 0.3)';
            }
        }

        function applyScanLinesEffect() {
            const canvas = effectsState.canvas;
            const ctx = effectsState.ctx;

            const animate = () => {
                if (!recordingState.selectedEffects.includes('scanlines')) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.lineWidth = 1;
                for (let y = 0; y < canvas.height; y += 4) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        // ====== NEW NEON & VIBRANT EFFECTS ======
        function applyCyberpunkEffect() {
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = 'saturate(2) hue-rotate(-30deg) brightness(1.3) contrast(1.5)';
                video.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.5)';
            }
        }

        function applyVaporwaveEffect() {
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = 'hue-rotate(260deg) saturate(1.3) brightness(1.1) contrast(1.2)';
            }
        }

        // ====== NEW MOOD EFFECTS ======
        function applyDreamyEffect() {
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = 'blur(2px) brightness(1.2) contrast(0.9) saturate(0.8)';
            }
        }

        function applyNoirEffect() {
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = 'grayscale(100%) contrast(1.3) brightness(0.95)';
            }
        }

        // ====== CLONE & MIRROR EFFECTS ======
        function applyMirrorEffect() {
            const canvas = effectsState.canvas;
            const ctx = effectsState.ctx;
            const video = getRecordingVideoElement();

            const animate = () => {
                if (!recordingState.selectedEffects.includes('mirror')) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Left half
                ctx.drawImage(video, 0, 0, video.width, video.height, 0, 0, canvas.width / 2, canvas.height);

                // Right half mirrored
                ctx.save();
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);
                ctx.drawImage(video, 0, 0, video.width, video.height, 0, 0, canvas.width / 2, canvas.height);
                ctx.restore();

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function startCloneEffect() {
            const canvas = effectsState.canvas;
            const ctx = effectsState.ctx;
            const video = getRecordingVideoElement();

            const animate = () => {
                if (!recordingState.selectedEffects.includes('clone')) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const positions = [
                    { x: 0, y: 0, scale: 1 },
                    { x: canvas.width / 2, y: 0, scale: 0.6 },
                    { x: 0, y: canvas.height / 2, scale: 0.6 },
                    { x: canvas.width / 2, y: canvas.height / 2, scale: 0.4 }
                ];

                positions.forEach((pos, index) => {
                    ctx.globalAlpha = 0.7 - (index * 0.15);
                    const w = canvas.width / 2 * pos.scale;
                    const h = canvas.height / 2 * pos.scale;
                    ctx.drawImage(video, 0, 0, video.width, video.height, pos.x, pos.y, w, h);
                });
                ctx.globalAlpha = 1;

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        // ====== AFCON FACE EFFECT ======
        const afconCountries = {
            'NG': { primary: '#008751', secondary: '#FFFFFF', accent: '#FFD700', text: '#FFFFFF', name: 'Nigeria' },
            'EG': { primary: '#CE1126', secondary: '#FFFFFF', accent: '#000000', text: '#FFFFFF', name: 'Egypt' },
            'CM': { primary: '#007A5E', secondary: '#FFFFFF', accent: '#FFD700', text: '#FFFFFF', name: 'Cameroon' },
            'RW': { primary: '#20B2AA', secondary: '#FFFFFF', accent: '#FFD700', text: '#FFFFFF', name: 'Rwanda' },
            'SN': { primary: '#007A5E', secondary: '#FFFFFF', accent: '#FFD700', text: '#FFFFFF', name: 'Senegal' },
            'CI': { primary: '#FF9900', secondary: '#FFFFFF', accent: '#008751', text: '#FFFFFF', name: 'Ivory Coast' },
            'KE': { primary: '#000000', secondary: '#FFFFFF', accent: '#FF0000', text: '#FFFFFF', name: 'Kenya' },
            'GH': { primary: '#CE1126', secondary: '#FFD700', accent: '#000000', text: '#FFFFFF', name: 'Ghana' }
        };

        let afconState = {
            currentCountry: 'NG',
            faceBox: null,
            animationTime: 0
        };

        function startAFCONEffect() {
            const canvas = effectsState.canvas;
            const ctx = effectsState.ctx;

            if (!canvas || !ctx) {
                console.error(' Canvas not initialized for AFCON effect');
                return;
            }

            showAFCONCountrySelector();

            const animate = () => {
                if (!recordingState.selectedEffects.includes('afcon')) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                renderAFCONEffect(ctx, canvas);

                effectsState.animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function renderAFCONEffect(ctx, canvas) {
            // Define face box (centered)
            const faceBox = {
                x: canvas.width * 0.3,
                y: canvas.height * 0.22,
                width: canvas.width * 0.4,
                height: canvas.height * 0.55
            };

            // Calculate landmarks
            const landmarks = {
                leftCheek: {
                    x: faceBox.x + faceBox.width * 0.25,
                    y: faceBox.y + faceBox.height * 0.58
                },
                rightCheek: {
                    x: faceBox.x + faceBox.width * 0.75,
                    y: faceBox.y + faceBox.height * 0.58
                },
                forehead: {
                    x: faceBox.x + faceBox.width * 0.5,
                    y: faceBox.y + faceBox.height * 0.08
                },
                chin: {
                    x: faceBox.x + faceBox.width * 0.5,
                    y: faceBox.y + faceBox.height * 0.95
                }
            };

            const country = afconCountries[afconState.currentCountry];

            // Draw professional face paint with gradients
            drawProfessionalFacePaint(ctx, landmarks, faceBox, country);

            // Draw professional badge/crown
            drawAFCONBadge(ctx, landmarks, country);
        }

        function drawProfessionalFacePaint(ctx, landmarks, faceBox, country) {
            const paintWidth = faceBox.width * 0.14;
            const paintHeight = faceBox.height * 0.12;

            // Left cheek paint - vertical stripes
            ctx.globalAlpha = 0.75;
            const stripeWidth = paintWidth / 3;

            // Left stripe - color 1
            ctx.fillStyle = country.primary;
            ctx.beginPath();
            ctx.ellipse(landmarks.leftCheek.x - stripeWidth, landmarks.leftCheek.y, stripeWidth * 0.8, paintHeight, -Math.PI / 6, 0, Math.PI * 2);
            ctx.fill();

            // Middle stripe - secondary
            ctx.fillStyle = country.secondary;
            ctx.beginPath();
            ctx.ellipse(landmarks.leftCheek.x, landmarks.leftCheek.y, stripeWidth * 0.8, paintHeight, 0, 0, Math.PI * 2);
            ctx.fill();

            // Right stripe - accent
            ctx.fillStyle = country.accent;
            ctx.beginPath();
            ctx.ellipse(landmarks.leftCheek.x + stripeWidth, landmarks.leftCheek.y, stripeWidth * 0.8, paintHeight, Math.PI / 6, 0, Math.PI * 2);
            ctx.fill();

            // Right cheek paint - mirror effect
            ctx.fillStyle = country.primary;
            ctx.beginPath();
            ctx.ellipse(landmarks.rightCheek.x + stripeWidth, landmarks.rightCheek.y, stripeWidth * 0.8, paintHeight, Math.PI / 6, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = country.secondary;
            ctx.beginPath();
            ctx.ellipse(landmarks.rightCheek.x, landmarks.rightCheek.y, stripeWidth * 0.8, paintHeight, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = country.accent;
            ctx.beginPath();
            ctx.ellipse(landmarks.rightCheek.x - stripeWidth, landmarks.rightCheek.y, stripeWidth * 0.8, paintHeight, -Math.PI / 6, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 1;
        }

        function drawAFCONBadge(ctx, landmarks, country) {
            const badgeWidth = landmarks.forehead.x * 0.5;
            const badgeHeight = landmarks.forehead.y * 0.4;

            // Draw badge background with shadow
            ctx.globalAlpha = 0.15;
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.roundRect(landmarks.forehead.x - badgeWidth - 8, landmarks.forehead.y - badgeHeight - 8, badgeWidth * 2 + 16, badgeHeight * 2 + 16, 12);
            ctx.fill();

            // Draw main badge
            ctx.globalAlpha = 0.95;

            // Background
            ctx.fillStyle = country.primary;
            ctx.beginPath();
            ctx.roundRect(landmarks.forehead.x - badgeWidth, landmarks.forehead.y - badgeHeight, badgeWidth * 2, badgeHeight * 2, 10);
            ctx.fill();

            // Accent border
            ctx.strokeStyle = country.accent;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(landmarks.forehead.x - badgeWidth, landmarks.forehead.y - badgeHeight, badgeWidth * 2, badgeHeight * 2, 10);
            ctx.stroke();

            // Secondary stripe
            ctx.fillStyle = country.secondary;
            ctx.fillRect(landmarks.forehead.x - badgeWidth, landmarks.forehead.y - badgeHeight * 0.3, badgeWidth * 2, badgeHeight * 0.6);

            // Country code text
            ctx.globalAlpha = 1;
            ctx.font = `bold ${badgeHeight * 0.8}px Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = country.text;
            ctx.fillText(afconState.currentCountry, landmarks.forehead.x, landmarks.forehead.y);

            // Trophy emoji decoration
            ctx.font = `${badgeHeight * 0.6}px Arial`;
            ctx.fillText('', landmarks.forehead.x - badgeWidth * 0.5, landmarks.forehead.y - badgeHeight * 0.4);
            ctx.fillText('', landmarks.forehead.x + badgeWidth * 0.5, landmarks.forehead.y - badgeHeight * 0.4);
        }

        function showAFCONCountrySelector() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 2px solid #4C1D95;
                border-radius: 12px;
                padding: 20px;
                z-index: 9999;
                color: white;
                text-align: center;
                max-height: 80vh;
                overflow-y: auto;
                width: 90%;
                max-width: 400px;
            `;

            let html = `
                <h2 style="margin-top: 0; color: white;">Select AFCON Country</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 20px 0;">
            `;

            Object.keys(afconCountries).forEach(code => {
                const country = afconCountries[code];
                html += `
                    <button onclick="selectAFCONCountry('${code}'); this.closest('div').parentElement.remove();" style="
                        padding: 15px;
                        background: linear-gradient(135deg, ${country.primary}, ${country.secondary});
                        border: 2px solid ${country.primary};
                        border-radius: 8px;
                        color: white;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.3s;
                    ">${code}<br><small>${country.name}</small></button>
                `;
            });

            html += `
                </div>
                <button onclick="this.closest('div').remove();" style="
                    padding: 10px 20px;
                    background: #333;
                    border: 1px solid #555;
                    border-radius: 6px;
                    color: white;
                    cursor: pointer;
                    margin-top: 10px;
                ">Close</button>
            `;

            modal.innerHTML = html;
            document.body.appendChild(modal);

            // Add backdrop
            const backdrop = document.createElement('div');
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 9998;
            `;
            backdrop.onclick = () => backdrop.remove() && modal.remove();
            document.body.insertBefore(backdrop, modal);
        }

        function selectAFCONCountry(countryCode) {
            afconState.currentCountry = countryCode;
            showToastRecording(` ${afconCountries[countryCode].name} Selected`, 'info', '');
        }

        function renderAFCONEffectToCanvas(ctx, canvas) {
            // Define face box (centered)
            const faceBox = {
                x: canvas.width * 0.3,
                y: canvas.height * 0.22,
                width: canvas.width * 0.4,
                height: canvas.height * 0.55
            };

            // Calculate landmarks
            const landmarks = {
                leftCheek: {
                    x: faceBox.x + faceBox.width * 0.25,
                    y: faceBox.y + faceBox.height * 0.58
                },
                rightCheek: {
                    x: faceBox.x + faceBox.width * 0.75,
                    y: faceBox.y + faceBox.height * 0.58
                },
                forehead: {
                    x: faceBox.x + faceBox.width * 0.5,
                    y: faceBox.y + faceBox.height * 0.08
                },
                chin: {
                    x: faceBox.x + faceBox.width * 0.5,
                    y: faceBox.y + faceBox.height * 0.95
                }
            };

            const country = afconCountries[afconState.currentCountry];

            // Draw professional face paint
            const paintWidth = faceBox.width * 0.14;
            const paintHeight = faceBox.height * 0.12;
            const stripeWidth = paintWidth / 3;

            // Left cheek paint - vertical stripes
            ctx.globalAlpha = 0.75;

            // Left stripe
            ctx.fillStyle = country.primary;
            ctx.beginPath();
            ctx.ellipse(landmarks.leftCheek.x - stripeWidth, landmarks.leftCheek.y, stripeWidth * 0.8, paintHeight, -Math.PI / 6, 0, Math.PI * 2);
            ctx.fill();

            // Middle stripe
            ctx.fillStyle = country.secondary;
            ctx.beginPath();
            ctx.ellipse(landmarks.leftCheek.x, landmarks.leftCheek.y, stripeWidth * 0.8, paintHeight, 0, 0, Math.PI * 2);
            ctx.fill();

            // Right stripe
            ctx.fillStyle = country.accent;
            ctx.beginPath();
            ctx.ellipse(landmarks.leftCheek.x + stripeWidth, landmarks.leftCheek.y, stripeWidth * 0.8, paintHeight, Math.PI / 6, 0, Math.PI * 2);
            ctx.fill();

            // Right cheek paint - mirror effect
            ctx.fillStyle = country.primary;
            ctx.beginPath();
            ctx.ellipse(landmarks.rightCheek.x + stripeWidth, landmarks.rightCheek.y, stripeWidth * 0.8, paintHeight, Math.PI / 6, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = country.secondary;
            ctx.beginPath();
            ctx.ellipse(landmarks.rightCheek.x, landmarks.rightCheek.y, stripeWidth * 0.8, paintHeight, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = country.accent;
            ctx.beginPath();
            ctx.ellipse(landmarks.rightCheek.x - stripeWidth, landmarks.rightCheek.y, stripeWidth * 0.8, paintHeight, -Math.PI / 6, 0, Math.PI * 2);
            ctx.fill();

            // Draw badge with shadow
            const badgeWidth = landmarks.forehead.x * 0.5;
            const badgeHeight = landmarks.forehead.y * 0.4;

            ctx.globalAlpha = 0.15;
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.roundRect(landmarks.forehead.x - badgeWidth - 8, landmarks.forehead.y - badgeHeight - 8, badgeWidth * 2 + 16, badgeHeight * 2 + 16, 12);
            ctx.fill();

            // Badge main
            ctx.globalAlpha = 0.95;
            ctx.fillStyle = country.primary;
            ctx.beginPath();
            ctx.roundRect(landmarks.forehead.x - badgeWidth, landmarks.forehead.y - badgeHeight, badgeWidth * 2, badgeHeight * 2, 10);
            ctx.fill();

            // Accent border
            ctx.strokeStyle = country.accent;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(landmarks.forehead.x - badgeWidth, landmarks.forehead.y - badgeHeight, badgeWidth * 2, badgeHeight * 2, 10);
            ctx.stroke();

            // Secondary stripe
            ctx.fillStyle = country.secondary;
            ctx.fillRect(landmarks.forehead.x - badgeWidth, landmarks.forehead.y - badgeHeight * 0.3, badgeWidth * 2, badgeHeight * 0.6);

            // Country code text
            ctx.globalAlpha = 1;
            ctx.font = `bold ${badgeHeight * 0.8}px Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = country.text;
            ctx.fillText(afconState.currentCountry, landmarks.forehead.x, landmarks.forehead.y);

            // Trophy emoji decoration
            ctx.font = `${badgeHeight * 0.6}px Arial`;
            ctx.fillText('', landmarks.forehead.x - badgeWidth * 0.5, landmarks.forehead.y - badgeHeight * 0.4);
            ctx.fillText('', landmarks.forehead.x + badgeWidth * 0.5, landmarks.forehead.y - badgeHeight * 0.4);

            ctx.globalAlpha = 1;
        }

        // ====== RECORDING FILTERS FUNCTIONS ======
        function toggleRecordingFilters() {
            const filtersPanel = document.querySelector('.rec-filters-panel');
            if (filtersPanel) {
                filtersPanel.classList.toggle('show');
                if (filtersPanel.classList.contains('show')) {
                    showToastRecording(' Filters Opened', 'info', '');
                } else {
                    showToastRecording(' Filters Closed', 'info', '');
                }
            }
        }

        function applyRecordingFilter(filterName) {
            // Update recordingState with selected filter
            recordingState.currentFilter = filterName;

            let filter = '';
            let filterString = filterName;

            switch (filterName) {
                case 'none':
                    filter = 'none';
                    filterString = 'Original';
                    break;
                case 'bw':
                    filter = 'grayscale(100%)';
                    filterString = 'Black & White';
                    break;
                case 'sepia':
                    filter = 'sepia(100%)';
                    filterString = 'Sepia';
                    break;
                case 'vintage':
                    filter = 'sepia(50%) contrast(0.9) brightness(0.9)';
                    filterString = 'Vintage';
                    break;
                case 'vivid':
                    filter = 'saturate(1.5) contrast(1.1)';
                    filterString = 'Vivid';
                    break;
                case 'warm':
                    filter = 'brightness(1.1) saturate(1.3) hue-rotate(10deg)';
                    filterString = 'Warm';
                    break;
                case 'cool':
                    filter = 'hue-rotate(-20deg) saturate(1.2) brightness(0.95)';
                    filterString = 'Cool';
                    break;
                default:
                    filter = 'none';
                    filterString = 'Original';
            }

            // Update ALL video elements that show preview
            const videoPreview = document.getElementById('videoPreview');
            if (videoPreview) {
                videoPreview.style.filter = filter;
            }

            const recordingVideoPreview = document.getElementById('recordingVideoPreview');
            if (recordingVideoPreview) {
                recordingVideoPreview.style.filter = filter;
            }

            // Get the appropriate video element
            const video = getRecordingVideoElement();
            if (video) {
                video.style.filter = filter;
            }

            // Also apply to any video element with camera-preview class
            document.querySelectorAll('.camera-preview').forEach(el => {
                el.style.filter = filter;
            });

            // Trigger callback if it exists
            if (recordingState.previewFilterCallback) {
                recordingState.previewFilterCallback();
            }

            console.log(` Filter applied: ${filterString}`);

            // Determine which screen is active
            const activeScreen = document.querySelector('.recording-screen.active');
            let activePanelId = 'recFiltersPanel'; // Default to Screen 1
            if (activeScreen?.id === 'screen2') {
                activePanelId = 'recScreen2FiltersPanel';
            }

            // Update active button state - only in the active panel
            const activePanel = document.getElementById(activePanelId);
            if (activePanel) {
                activePanel.querySelectorAll('.rec-filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                });

                // Mark current filter as active - try multiple ways to be sure
                const filterButton = activePanel.querySelector(`button[onclick*="applyRecordingFilter('${filterName}')"]`) ||
                    activePanel.querySelector(`button[onclick*="applyRecordingFilter\\('${filterName}'\\)"]`);

                if (filterButton) {
                    filterButton.classList.add('active');
                    console.log(' Updated button active state for filter:', filterName);
                } else {
                    console.warn(' Could not find filter button for:', filterName);
                }
            }

            // Log for debugging
            console.log(' Filter applied:', filterName, 'to screen:', activeScreen?.id);
            showToastRecording(` ${filterString} Applied`, 'info', '');

            // Update button label
            const label = document.getElementById('recFiltersLabel');
            if (label) {
                label.textContent = filterString;
            }

            // Update button style
            const filterBtn = document.querySelector('[onclick="toggleRecordingFilters()"]');
            if (filterBtn) {
                if (filterName !== 'none') {
                    filterBtn.style.background = 'rgba(150, 100, 200, 0.2)';
                    filterBtn.style.borderColor = '#9664C8';
                } else {
                    filterBtn.style.background = '';
                    filterBtn.style.borderColor = '';
                }
            }

            // Show notification
            const message = ` Filter: ${filterString}`;
            showToastRecording(message, 'info', '');

            // Auto-close filters panel after selection
            setTimeout(() => {
                const filtersPanel = document.querySelector('.rec-filters-panel');
                if (filtersPanel && filtersPanel.classList.contains('show')) {
                    filtersPanel.classList.remove('show');
                }
            }, 300);
        }

        // ====== RECORDING SOUND LIBRARY ======
        function openRecordingSoundLibrary() {
            if (recordingState.isRecording) {
                showToastRecording(' Stop recording to add sound', 'warning', '');
                return;
            }
            // Reuse existing sound library
            openSoundLibrary();
        }

        // Remove selected sound from Screen 1
        function removeRecordingSound() {
            recordingState.selectedSound = null;

            const display = document.getElementById('recSoundDisplay');
            if (display) {
                display.style.display = 'none';
            }

            showToastRecording(' Sound removed', 'info', '');
            console.log(' Sound removed from recording');
        }

        // ====== RECORDING TIMER FUNCTIONS ======
        function toggleRecordingTimer() {
            const timers = [0, 3, 5, 10];
            const currentTimer = recordingState.recordingTimer;
            const nextIndex = (timers.indexOf(currentTimer) + 1) % timers.length;
            recordingState.recordingTimer = timers[nextIndex];

            // Update button label
            const label = document.getElementById('recTimerLabel');
            if (label) {
                if (recordingState.recordingTimer === 0) {
                    label.textContent = 'Off';
                } else {
                    label.textContent = `${recordingState.recordingTimer}s`;
                }
            }

            // Update button style
            const timerBtn = document.querySelector('.rec-timer-btn');
            if (timerBtn) {
                if (recordingState.recordingTimer > 0) {
                    timerBtn.style.background = 'rgba(100, 200, 255, 0.2)';
                    timerBtn.style.borderColor = '#64C8FF';
                } else {
                    timerBtn.style.background = '';
                    timerBtn.style.borderColor = '';
                }
            }

            // Show notification
            const message = recordingState.recordingTimer === 0
                ? 'Recording Timer: OFF'
                : ` Recording Timer: ${recordingState.recordingTimer}s`;
            showToastRecording(message, 'info', '');
        }

        async function showRecordingCountdown() {
            return new Promise((resolve) => {
                let remaining = recordingState.recordingTimer;

                // Create countdown overlay
                const overlay = document.createElement('div');
                overlay.id = 'recordingCountdownOverlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 9999;
                `;

                const number = document.createElement('div');
                number.style.cssText = `
                    font-size: 120px;
                    font-weight: bold;
                    color: #FFD700;
                    text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
                    animation: recordingCountdownPulse 1s ease-in-out;
                `;
                number.textContent = remaining;

                overlay.appendChild(number);
                document.body.appendChild(overlay);

                // Add CSS animation if not exists
                if (!document.getElementById('recordingCountdownStyle')) {
                    const style = document.createElement('style');
                    style.id = 'recordingCountdownStyle';
                    style.textContent = `
                        @keyframes recordingCountdownPulse {
                            0% { transform: scale(1); opacity: 1; }
                            50% { transform: scale(1.2); opacity: 0.8; }
                            100% { transform: scale(1); opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }

                const interval = setInterval(() => {
                    remaining--;
                    if (remaining > 0) {
                        number.textContent = remaining;
                        number.style.animation = 'none';
                        setTimeout(() => {
                            number.style.animation = 'recordingCountdownPulse 1s ease-in-out';
                        }, 10);
                    } else {
                        clearInterval(interval);
                        overlay.remove();
                        performRecording();
                        resolve();
                    }
                }, 1000);
            });
        }

        // Photo filters state
        let photoFiltersState = {
            allFilters: [],
            currentFilters: [],
            isLoading: false,
            lastRefresh: 0,
            refreshInterval: 600000 // 10 minutes
        };

        // Default filters (if API fails)
        const defaultPhotoFilters = [
            {
                id: 'none',
                name: 'Original',
                cssFilter: 'none',
                category: 'Basic'
            },
            {
                id: 'bw',
                name: 'Black & White',
                cssFilter: 'grayscale(100%)',
                category: 'Basic'
            },
            {
                id: 'sepia',
                name: 'Sepia',
                cssFilter: 'sepia(100%)',
                category: 'Vintage'
            },
            {
                id: 'vintage',
                name: 'Vintage',
                cssFilter: 'sepia(50%) contrast(0.9) brightness(0.9)',
                category: 'Vintage'
            },
            {
                id: 'vivid',
                name: 'Vivid',
                cssFilter: 'saturate(1.5) contrast(1.1)',
                category: 'Enhanced'
            },
            {
                id: 'warm',
                name: 'Warm',
                cssFilter: 'brightness(1.1) saturate(1.3) hue-rotate(10deg)',
                category: 'Mood'
            },
            {
                id: 'cool',
                name: 'Cool',
                cssFilter: 'hue-rotate(-20deg) saturate(1.2) brightness(0.95)',
                category: 'Mood'
            },
            {
                id: 'bright',
                name: 'Bright',
                cssFilter: 'brightness(1.2) contrast(1.05)',
                category: 'Enhanced'
            },
            {
                id: 'dark',
                name: 'Dark',
                cssFilter: 'brightness(0.85) contrast(1.1)',
                category: 'Mood'
            },
            {
                id: 'saturate',
                name: 'Saturate',
                cssFilter: 'saturate(2)',
                category: 'Enhanced'
            }
        ];

        function togglePhotoFilters() {
            const filtersPanel = document.querySelector('.photo-filters-panel');
            if (filtersPanel) {
                filtersPanel.classList.toggle('show');
                if (filtersPanel.classList.contains('show')) {
                    // Load filters if not already loaded
                    if (photoFiltersState.currentFilters.length === 0) {
                        loadPhotoFilters();
                    }
                    showToastRecording(' Filters Opened', 'info', '');
                } else {
                    showToastRecording(' Filters Closed', 'info', '');
                }
            }
            closePhotoLeftMenu();
        }

        // Load photo filters (can be from API or default)
        async function loadPhotoFilters() {
            try {
                console.log(' Loading photo filters...');
                photoFiltersState.isLoading = true;

                // Try to fetch from a filter API endpoint
                // For now, using default filters with possibility to expand
                const filters = await fetchPhotoFiltersFromAPI();

                if (filters && filters.length > 0) {
                    photoFiltersState.allFilters = filters;
                    photoFiltersState.currentFilters = filters.slice(0, 10);
                    console.log(' Loaded', filters.length, 'filters from API');
                } else {
                    console.warn(' Using default filters');
                    photoFiltersState.allFilters = defaultPhotoFilters;
                    photoFiltersState.currentFilters = defaultPhotoFilters;
                }

                // Render filters
                renderPhotoFilters();
                photoFiltersState.lastRefresh = Date.now();
                photoFiltersState.isLoading = false;

            } catch (error) {
                console.error(' Error loading filters:', error);
                photoFiltersState.allFilters = defaultPhotoFilters;
                photoFiltersState.currentFilters = defaultPhotoFilters;
                renderPhotoFilters();
                photoFiltersState.isLoading = false;
            }
        }

        // Fetch photo filters from API
        async function fetchPhotoFiltersFromAPI() {
            try {
                // Create a custom filter API call
                // Using a pattern service or filter database
                const response = await fetch('https://api.pexels.com/v1/collections/featured?per_page=1&page=1', {
                    headers: {
                        'Authorization': 'K4hN9bQzJjDf5mXpL2wRtYvKzGhJ8nPq' // Public Pexels API key (limited)
                    }
                });

                if (!response.ok) throw new Error(`API error: ${response.status}`);

                // Since we can't get filter presets from a public API easily,
                // we'll generate them dynamically with variations
                const dynamicFilters = generateDynamicFilters();
                return dynamicFilters;

            } catch (error) {
                console.warn(' API fetch failed, will use defaults:', error.message);
                return null;
            }
        }

        // Generate dynamic filters with variations
        function generateDynamicFilters() {
            const generatedFilters = [
                ...defaultPhotoFilters,
                {
                    id: 'hdr',
                    name: 'HDR',
                    cssFilter: 'contrast(1.3) saturate(1.2) brightness(1.05)',
                    category: 'Pro'
                },
                {
                    id: 'noir',
                    name: 'Noir',
                    cssFilter: 'grayscale(100%) brightness(0.8) contrast(1.3)',
                    category: 'Vintage'
                },
                {
                    id: 'sunset',
                    name: 'Sunset',
                    cssFilter: 'hue-rotate(-10deg) saturate(1.4) brightness(1.1)',
                    category: 'Mood'
                },
                {
                    id: 'forest',
                    name: 'Forest',
                    cssFilter: 'hue-rotate(120deg) saturate(1.3) brightness(0.95)',
                    category: 'Mood'
                },
                {
                    id: 'retro',
                    name: 'Retro',
                    cssFilter: 'sepia(30%) hue-rotate(10deg) saturate(0.8)',
                    category: 'Vintage'
                }
            ];
            return generatedFilters;
        }

        // Render photo filters dynamically
        function renderPhotoFilters() {
            const scrollContainer = document.querySelector('.photo-filters-scroll');
            if (!scrollContainer) return;

            scrollContainer.innerHTML = '';

            photoFiltersState.currentFilters.forEach(filter => {
                const btn = document.createElement('button');
                btn.className = 'photo-filter-btn';
                btn.onclick = () => applyPhotoFilter(filter.id);
                btn.title = filter.name;
                btn.innerHTML = `
                    <div class="photo-filter-preview" style="filter: ${filter.cssFilter === 'none' ? '' : filter.cssFilter};"></div>
                    <span>${filter.name}</span>
                `;
                scrollContainer.appendChild(btn);
            });

            console.log(' Rendered', photoFiltersState.currentFilters.length, 'filters');
        }

        function togglePhotoGrid() {
            photoState.photoSettings.grid = !photoState.photoSettings.grid;
            const menu = document.getElementById('recPhotoLeftMenu');
            const gridItem = menu.querySelector('.rec-menu-item:nth-child(4)');

            if (photoState.photoSettings.grid) {
                gridItem.style.color = '#FFD700';
                showGridOverlay('grid-overlay-photo');
            } else {
                gridItem.style.color = 'white';
                hideGridOverlay();
            }

            showToastRecording(photoState.photoSettings.grid ? 'Grid on' : 'Grid off', 'info', '');
            closePhotoLeftMenu();
        }

        function togglePhotoRatio() {
            const ratios = ['1:1', '3:4', '9:16', '16:9'];
            const currentIdx = ratios.indexOf(photoState.photoSettings.ratio);
            photoState.photoSettings.ratio = ratios[(currentIdx + 1) % ratios.length];

            const menu = document.getElementById('recPhotoLeftMenu');
            const ratioItem = menu.querySelector('.rec-menu-item:nth-child(5)');
            ratioItem.textContent = ` ${photoState.photoSettings.ratio}`;

            // Update live ratio guide frame in preview
            updateRatioGuide();

            showToastRecording(` ${photoState.photoSettings.ratio} -  100% Quality JPEG`, 'info', '');
            closePhotoLeftMenu();
        }

        // Toggle effects
        function toggleEffect(effect) {
            const idx = photoState.photoSettings.effects.indexOf(effect);
            if (idx > -1) {
                photoState.photoSettings.effects.splice(idx, 1);
            } else {
                photoState.photoSettings.effects.push(effect);
            }

            const effectIcons = {
                'sparkle': '',
                'mask': '',
                'ghost': '',
                'star': ''
            };

            showToastRecording(`${effectIcons[effect]} effect ${idx > -1 ? 'removed' : 'added'}`, 'info', effectIcons[effect]);
        }

        function applyPhotoFilter(filterName) {
            const video = document.getElementById('photoPreviewVideo');
            if (!video) return;

            // Update photoState with selected filter
            photoState.photoSettings.filter = filterName;

            let filter = '';
            let filterString = filterName;

            switch (filterName) {
                case 'none':
                    filter = 'none';
                    filterString = 'Original';
                    break;
                case 'bw':
                    filter = 'grayscale(100%)';
                    filterString = 'Black & White';
                    break;
                case 'sepia':
                    filter = 'sepia(100%)';
                    filterString = 'Sepia';
                    break;
                case 'vintage':
                    filter = 'sepia(50%) contrast(0.9) brightness(0.9)';
                    filterString = 'Vintage';
                    break;
                case 'vivid':
                    filter = 'saturate(1.5) contrast(1.1)';
                    filterString = 'Vivid';
                    break;
                case 'warm':
                    filter = 'brightness(1.1) saturate(1.3) hue-rotate(10deg)';
                    filterString = 'Warm';
                    break;
                case 'cool':
                    filter = 'hue-rotate(-20deg) saturate(1.2) brightness(0.95)';
                    filterString = 'Cool';
                    break;
                default:
                    filter = 'none';
                    filterString = 'Original';
            }

            // Apply filter to video
            video.style.filter = filter;

            // Update active button state in filters panel (right side)
            document.querySelectorAll('.photo-filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Update active button state in bottom filters panel
            document.querySelectorAll('.photo-filter-btn-bottom').forEach(btn => {
                btn.classList.remove('active');
            });

            // Find and mark the clicked button as active (right side)
            const activeBtn = document.querySelector(`[onclick="applyPhotoFilter('${filterName}')"]`);
            if (activeBtn && activeBtn.classList.contains('photo-filter-btn')) {
                activeBtn.classList.add('active');
            }

            // Find and mark the clicked button as active (bottom panel)
            const activeBtnBottom = document.querySelector(`.photo-filter-btn-bottom[onclick="applyPhotoFilter('${filterName}')"]`);
            if (activeBtnBottom) {
                activeBtnBottom.classList.add('active');
            }

            // Show toast feedback
            showToastRecording(` ${filterString}`, 'info', '');

            console.log(' Filter applied:', filterName);
        }

        // Toggle Filters Panel Collapse
        function togglePhotoPanelCollapse() {
            const panel = document.getElementById('photoFiltersPanel');
            if (!panel) return;

            // Toggle show class to make panel visible/hidden
            const isShown = panel.classList.toggle('show');

            // Also toggle collapsed state
            if (!isShown) {
                panel.classList.add('collapsed');
            } else {
                panel.classList.remove('collapsed');
            }

            // Save state to localStorage
            localStorage.setItem('photoPanelCollapsed', !isShown);

            console.log(' Filters panel:', isShown ? 'opened' : 'closed');
        }

        // Initialize filters panel state on load
        function initPhotoPanelState() {
            const panel = document.getElementById('photoFiltersPanel');
            if (!panel) return;

            // Default to collapsed (closed) - don't add 'show' class
            panel.classList.remove('show');
            panel.classList.add('collapsed');
        }

        // Toggle Bottom Filters Panel Open/Close
        function togglePhotoFiltersBottom() {
            const panel = document.getElementById('photoFiltersBottomPanel');
            if (!panel) return;

            panel.classList.toggle('open');

            // Save state to localStorage
            const isOpen = panel.classList.contains('open');
            localStorage.setItem('photoFiltersBottomOpen', isOpen);

            console.log(' Bottom filters:', isOpen ? 'opened' : 'closed');
        }

        // Initialize bottom filters panel state
        function initPhotoFiltersBottomState() {
            const panel = document.getElementById('photoFiltersBottomPanel');
            if (!panel) return;

            const isOpen = localStorage.getItem('photoFiltersBottomOpen') === 'true';
            if (isOpen) {
                panel.classList.add('open');
            } else {
                panel.classList.remove('open');
            }
        }

        // ============================================================================
        // PHOTO CAPTURE HELPER FUNCTIONS
        // ============================================================================

        // Show countdown timer with visual feedback
        async function showPhotoCountdown(seconds) {
            return new Promise((resolve) => {
                let remaining = seconds;

                // Create countdown overlay
                const overlay = document.createElement('div');
                overlay.id = 'photoCountdownOverlay';
                overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    `;

                const number = document.createElement('div');
                number.style.cssText = `
      font-size: 120px;
      font-weight: bold;
      color: #FFD700;
      text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
      animation: photoCountdownPulse 1s ease-in-out;
    `;
                number.textContent = remaining;

                overlay.appendChild(number);
                document.body.appendChild(overlay);

                // Add CSS animation if not exists
                if (!document.getElementById('photoCountdownStyle')) {
                    const style = document.createElement('style');
                    style.id = 'photoCountdownStyle';
                    style.textContent = `
        @keyframes photoCountdownPulse {
          0% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.2); opacity: 0.8; }
          100% { transform: scale(1); opacity: 1; }
        }
      `;
                    document.head.appendChild(style);
                }

                const interval = setInterval(() => {
                    remaining--;
                    if (remaining > 0) {
                        number.textContent = remaining;
                        number.style.animation = 'none';
                        setTimeout(() => {
                            number.style.animation = 'photoCountdownPulse 1s ease-in-out';
                        }, 10);
                    } else {
                        clearInterval(interval);
                        overlay.remove();
                        resolve();
                    }
                }, 1000);
            });
        }

        // Calculate canvas size based on selected aspect ratio
        function calculateCanvasSize(videoWidth, videoHeight) {
            const ratio = photoState.photoSettings.ratio;
            let canvasWidth, canvasHeight, offsetX = 0, offsetY = 0;

            const ratioMap = {
                '1:1': 1,
                '3:4': 3 / 4,
                '9:16': 9 / 16,
                '16:9': 16 / 9
            };

            const targetRatio = ratioMap[ratio] || 1;
            const currentRatio = videoWidth / videoHeight;

            if (currentRatio > targetRatio) {
                // Video is wider, crop sides
                canvasHeight = videoHeight;
                canvasWidth = Math.floor(videoHeight * targetRatio);
                offsetX = Math.floor((videoWidth - canvasWidth) / 2);
                offsetY = 0;
            } else {
                // Video is taller, crop top/bottom
                canvasWidth = videoWidth;
                canvasHeight = Math.floor(videoWidth / targetRatio);
                offsetX = 0;
                offsetY = Math.floor((videoHeight - canvasHeight) / 2);
            }

            return { canvasWidth, canvasHeight, offsetX, offsetY };
        }

        // Apply flash effect to captured image
        function applyFlashEffectToCanvas(ctx, width, height) {
            const flashMode = photoState.photoSettings.flash;

            // Skip if flash is off
            if (!flashMode) return;

            // For auto mode, we could check image brightness, but for now just apply normal flash
            const isAutoMode = flashMode === 'auto';
            const opacity = isAutoMode ? 0.08 : 0.15; // Lighter effect for auto mode

            // Create bright white overlay for flash effect
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.fillRect(0, 0, width, height);

            // Add subtle glow at edges
            const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height));
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
        }

        // ============================================================================

        function showGridOverlay(gridId) {
            let grid = document.getElementById(gridId);
            if (!grid) {
                grid = document.createElement('div');
                grid.id = gridId;
                grid.style.cssText = `
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 0;
      pointer-events: none;
      z-index: 10;
    `;

                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.style.cssText = 'border: 1px solid rgba(255,255,255,0.3);';
                    grid.appendChild(cell);
                }

                const preview = document.querySelector('#screen5 .camera-preview');
                if (preview) {
                    preview.style.position = 'relative';
                    preview.appendChild(grid);
                }
            }
            grid.style.display = 'grid';
        }

        function hideGridOverlay() {
            const grid = document.getElementById('grid-overlay-photo');
            if (grid) {
                grid.style.display = 'none';
            }
        }


        // ============================================================================
        // PHOTO CAPTURE WITH ADVANCED FEATURES (Timer, Grid, Flash, Gallery)
        // ============================================================================

        // Capture photo with timer support
        async function capturePhoto() {
            // Check if stream is available
            if (!photoState.photoStream || !photoState.photoStream.active) {
                alert(' Camera not initialized. Please wait a moment and try again.');
                await initializePhotoMode();
                return;
            }

            const video = document.getElementById('photoPreviewVideo');
            if (!video || !video.videoWidth || !video.videoHeight) {
                alert(' Camera not ready. Please wait for video stream to load.');
                return;
            }

            try {
                // STEP 1: Hide grid overlay before capturing (it should not appear in final photo)
                if (photoState.photoSettings.grid) {
                    hideGridOverlay();
                }

                // STEP 2: Handle timer with visual countdown
                if (photoState.photoSettings.timer > 0) {
                    await showPhotoCountdown(photoState.photoSettings.timer);
                }

                // STEP 3: Create canvas with NATIVE resolution for maximum quality
                if (!photoState.canvas) {
                    photoState.canvas = document.createElement('canvas');
                    // Professional quality context settings
                    photoState.ctx = photoState.canvas.getContext('2d', {
                        alpha: false,              // No transparency = better performance
                        desynchronized: true       // Faster rendering
                    });
                }

                // Set canvas dimensions to NATIVE video resolution (not CSS dimensions!)
                // This is critical: use video.videoWidth/Height, NOT offsetWidth/offsetHeight
                const { canvasWidth, canvasHeight, offsetX, offsetY } = calculateCanvasSize(video.videoWidth, video.videoHeight);
                photoState.canvas.width = canvasWidth;
                photoState.canvas.height = canvasHeight;

                // Disable image smoothing for crisp, sharp capture
                photoState.ctx.imageSmoothingEnabled = false;

                // STEP 4: Apply filter to canvas context
                if (photoState.photoSettings.filter !== 'none') {
                    photoState.ctx.filter = photoState.getPhotoFilterString(photoState.photoSettings.filter);
                } else {
                    photoState.ctx.filter = 'none';
                }

                // STEP 5: Draw video frame at NATIVE resolution with proper cropping for aspect ratio
                // Draw directly from video stream (no interpolation)
                photoState.ctx.drawImage(video, offsetX, offsetY, canvasWidth, canvasHeight, 0, 0, canvasWidth, canvasHeight);

                // STEP 6: Apply flash effect if enabled (brightness boost to capture)
                if (photoState.photoSettings.flash) {
                    applyFlashEffectToCanvas(photoState.ctx, canvasWidth, canvasHeight);
                }

                // STEP 7: Save photo with MAXIMUM quality and all settings
                // Convert canvas to JPEG at 100% quality (no compression artifacts)
                // Using toBlob for better performance than toDataURL
                const blob = await new Promise(resolve => {
                    photoState.canvas.toBlob(resolve, 'image/jpeg', 1.0);
                });

                // Convert to data URL for display
                const photoUrl = URL.createObjectURL(blob);

                // Log actual dimensions for verification
                console.log(' Photo captured at native resolution:', {
                    width: photoState.canvas.width,
                    height: photoState.canvas.height,
                    size: Math.round(blob.size / 1024) + 'KB',
                    blobSize: blob.size,
                    compression: '100% (lossless quality)'
                });

                const photoData = {
                    url: photoUrl,
                    blob: blob,  // Store blob for Firebase upload
                    timestamp: Date.now(),
                    resolution: `${photoState.canvas.width}x${photoState.canvas.height}`,
                    settings: { ...photoState.photoSettings }
                };

                photoState.capturedPhotos.push(photoData);
                photoState.currentPhotoIndex = photoState.capturedPhotos.length - 1;

                showToastRecording(' Photo captured!', 'success', '');
                console.log('Photo captured with settings:', photoState.photoSettings);

                // Stop camera after capturing (user won't need it in edit screen)
                stopPhotoMode();

                // Show photo in screen 6
                setTimeout(() => {
                    showScreen('screen6');
                    displayCapturedPhoto();
                }, 500);
            } catch (error) {
                console.error('Capture error:', error);
                alert(' Failed to capture photo: ' + error.message);
            }
        }

        // Display captured photo in preview
        function displayCapturedPhoto() {
            if (photoState.capturedPhotos.length === 0) return;

            const photo = photoState.capturedPhotos[photoState.currentPhotoIndex];
            const preview = document.querySelector('#screen6 .camera-preview');

            if (preview) {
                // Use edited URL if available, otherwise use original
                const photoUrl = photo.editedUrl || photo.url;
                let imgHTML = `<img src="${photoUrl}" id="screen6PhotoImg" style="width:100%; height:100%; object-fit:cover;">`;
                preview.innerHTML = imgHTML;

                // Apply any stored effects
                if (photo.effect) {
                    applyStoredEffectToScreen6(photo.effect);
                }
            }
        }

        function applyStoredEffectToScreen6(effect) {
            const photoImg = document.getElementById('screen6PhotoImg');
            if (!photoImg) return;

            switch (effect) {
                case 'none':
                    photoImg.style.filter = 'none';
                    break;
                case 'blur':
                    photoImg.style.filter = 'blur(8px)';
                    break;
                case 'grayscale':
                    photoImg.style.filter = 'grayscale(1)';
                    break;
                case 'sepia':
                    photoImg.style.filter = 'sepia(0.8)';
                    break;
                case 'invert':
                    photoImg.style.filter = 'invert(1)';
                    break;
                case 'brighten':
                    photoImg.style.filter = 'brightness(1.4)';
                    break;
                case 'contrast':
                    photoImg.style.filter = 'contrast(1.5)';
                    break;
                case 'saturate':
                    photoImg.style.filter = 'saturate(2)';
                    break;
            }
            console.log(' Applied stored effect to screen6:', effect);
        }

        // Gallery function - select photo from device
        function openPhotoGallery() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const photoData = {
                            url: event.target.result,
                            timestamp: Date.now(),
                            settings: { ...photoState.photoSettings }
                        };
                        photoState.capturedPhotos.push(photoData);
                        photoState.currentPhotoIndex = photoState.capturedPhotos.length - 1;

                        // Stop camera when moving to edit screen
                        stopPhotoMode();

                        showToastRecording('Photo added from gallery', 'success', '');
                        setTimeout(() => {
                            showScreen('screen6');
                            displayCapturedPhoto();
                        }, 300);
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }

        // Show discard confirmation modal
        function showDiscardPhotoModal() {
            const modal = document.getElementById('discardPhotoModal');
            if (modal) {
                modal.classList.add('active');
            }
        }

        // Close discard modal (stay on screen 6)
        function closeDiscardModal() {
            const modal = document.getElementById('discardPhotoModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        // Confirm discard and go back to screen 5
        function confirmDiscardPhoto() {
            closeDiscardModal();

            // Clear current photo from state
            if (photoState.currentPhotoIndex >= 0) {
                photoState.capturedPhotos.splice(photoState.currentPhotoIndex, 1);
                photoState.currentPhotoIndex = Math.max(0, photoState.currentPhotoIndex - 1);
            }

            // Go back to camera screen
            showScreen('screen5');

            // Reinitialize camera
            initializePhotoMode().then(() => {
                showToastRecording(' Photo discarded, camera ready', 'info', '');
            });
        }

        // Download photo to device
        // Show Photo Download Options
        function showPhotoDownloadOptions() {
            const modal = document.getElementById('photoDownloadModal');
            if (!modal) return;

            modal.classList.add('active');
        }

        // Close Photo Download Modal
        function closePhotoDownloadModal() {
            const modal = document.getElementById('photoDownloadModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        // Download Photo Only
        function downloadPhotoOnly() {
            try {
                if (photoState.capturedPhotos.length === 0 || photoState.currentPhotoIndex < 0) {
                    showToastRecording(' No photo to download', 'error', '');
                    return;
                }

                const photo = photoState.capturedPhotos[photoState.currentPhotoIndex];

                // Create download link
                const link = document.createElement('a');
                link.href = photo.url;

                // Generate filename with timestamp
                const timestamp = new Date(photo.timestamp).toISOString().slice(0, 19).replace(/:/g, '-');
                const filterName = photo.settings.filter || 'original';
                link.download = `pose_photo_${timestamp}_${filterName}.jpg`;

                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                showToastRecording(' Photo downloading...', 'success', '');
                console.log(' Photo download started:', link.download);
                closePhotoDownloadModal();

            } catch (error) {
                console.error('Download error:', error);
                showToastRecording(' Download failed: ' + error.message, 'error', '');
            }
        }

        // Download Photo With Sound
        async function downloadPhotoWithSound() {
            try {
                if (photoState.capturedPhotos.length === 0 || photoState.currentPhotoIndex < 0) {
                    showToastRecording(' No photo to download', 'error', '');
                    return;
                }

                if (!photoState.selectedSound) {
                    showToastRecording(' No sound added. Download picture only', 'error', '');
                    closePhotoDownloadModal();
                    return;
                }

                const photo = photoState.capturedPhotos[photoState.currentPhotoIndex];
                const timestamp = new Date(photo.timestamp).toISOString().slice(0, 19).replace(/:/g, '-');
                const filterName = photo.settings.filter || 'original';
                const videoFileName = `pose_${timestamp}_${filterName}.mp4`;

                showToastRecording(' Creating video from photo + sound...', 'info', '');
                closePhotoDownloadModal();

                await createVideoFromPhotoAndSound(photo, videoFileName);

            } catch (error) {
                console.error('Download error:', error);
                showToastRecording(' Download failed: ' + error.message, 'error', '');
            }
        }





        // Legacy function for backward compatibility
        function downloadCapturedPhoto() {
            showPhotoDownloadOptions();
        }

        // Update back button for screen 6 to show discard modal
        function backToScreen5() {
            showDiscardPhotoModal();
        }



        // Switch to video mode
        function switchToVideoMode() {
            // Stop camera before switching modes
            stopPhotoMode();

            showToastRecording('Switching to video mode...', 'info', '');
            setTimeout(() => {
                showScreen('screen3');
            }, 300);
        }

        // Photo edit functions
        function closePhotoModal() {
            const modal = document.getElementById('photoEditModal');
            if (modal) {
                modal.remove();
                console.log('Modal closed');
            }
        }

        function photoAddText() {
            console.log(' Opening text editor');
            closePhotoModal(); // Close any existing modal

            // Create text overlay modal with full controls
            const modal = document.createElement('div');
            modal.id = 'photoEditModal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 2px solid #4C1D95;
                border-radius: 12px;
                padding: 20px;
                z-index: 3000;
                min-width: 320px;
                color: white;
            `;

            modal.innerHTML = `
                <h3 style="margin-top: 0; color: #fff;">Add Text to Photo</h3>
                
                <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;"> Text</label>
                <input type="text" id="photoTextInput" placeholder="Enter text..." style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 6px; margin-bottom: 15px; font-size: 14px;">
                
                <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;"> Color</label>
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; margin-bottom: 15px;">
                    <button onclick="setTextColor('#ffffff')" style="padding: 15px; background: white; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="White"></button>
                    <button onclick="setTextColor('#000000')" style="padding: 15px; background: black; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Black"></button>
                    <button onclick="setTextColor('#ff0000')" style="padding: 15px; background: red; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Red"></button>
                    <button onclick="setTextColor('#ffff00')" style="padding: 15px; background: yellow; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Yellow"></button>
                    <button onclick="setTextColor('#00ff00')" style="padding: 15px; background: lime; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Green"></button>
                    <button onclick="setTextColor('#4C1D95')" style="padding: 15px; background: #4C1D95; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Purple"></button>
                </div>
                
                <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;"> Size: <span id="textSizeDisplay">24</span>px</label>
                <input type="range" id="photoTextSize" min="12" max="72" value="24" style="width: 100%; margin-bottom: 15px; cursor: pointer;" oninput="document.getElementById('textSizeDisplay').textContent = this.value">
                
                <div style="display: flex; gap: 10px;">
                    <button onclick="applyPhotoText()" style="flex: 1; padding: 10px; background: #4C1D95; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Apply</button>
                    <button onclick="closePhotoModal()" style="flex: 1; padding: 10px; background: #333; color: white; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
                </div>
            `;

            document.body.appendChild(modal);
            document.getElementById('photoTextInput').focus();
            showToastRecording(' Enter text, select color & size', 'info', '');
        }

        function setTextColor(color) {
            photoState.photoSettings.textColor = color;
            console.log('Text color set to:', color);
        }

        function applyPhotoText() {
            const text = document.getElementById('photoTextInput').value.trim();
            const size = document.getElementById('photoTextSize')?.value || 24;
            const color = photoState.photoSettings.textColor || '#ffffff';

            if (!text) {
                showToastRecording(' Please enter some text', 'warning', '');
                return;
            }

            // Store text settings in photoState
            photoState.photoSettings.textOverlay = {
                text: text,
                size: size,
                color: color,
                offsetX: 0,
                offsetY: 0,
                timestamp: Date.now()
            };

            // Apply text overlay to screen 6 (photo editing screen)
            const screen6 = document.getElementById('screen6');
            const cameraPreview = screen6?.querySelector('.camera-preview');

            if (!cameraPreview) {
                console.error(' Camera preview not found in screen 6');
                showToastRecording(' Photo preview not found', 'error', '');
                return;
            }

            // Ensure container is positioned relatively
            if (window.getComputedStyle(cameraPreview).position === 'static') {
                cameraPreview.style.position = 'relative';
            }

            // Remove old overlay if exists
            const oldOverlay = cameraPreview.querySelector('#photoTextOverlay');
            if (oldOverlay) oldOverlay.remove();

            // Create and add new overlay to camera-preview
            const overlay = document.createElement('div');
            overlay.id = 'photoTextOverlay';
            overlay.style.cssText = `
                position: absolute;
                top: calc(50% + ${photoState.photoSettings.textOverlay.offsetY}px);
                left: calc(50% + ${photoState.photoSettings.textOverlay.offsetX}px);
                transform: translate(-50%, -50%);
                color: ${color};
                font-size: ${size}px;
                font-weight: bold;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), -2px -2px 4px rgba(0,0,0,0.8);
                cursor: move;
                z-index: 100;
                white-space: nowrap;
                max-width: 90%;
                word-wrap: break-word;
                text-align: center;
                padding: 8px 12px;
                border: 2px dashed rgba(76, 29, 149, 0.5);
                border-radius: 6px;
                background: rgba(0,0,0,0.3);
            `;
            overlay.textContent = text;

            // Make text interactive
            overlay.draggable = true;
            overlay.onclick = (e) => {
                e.stopPropagation();
                openTextEditDialog();
            };

            overlay.ondragstart = (e) => {
                e.dataTransfer.effectAllowed = 'move';
                photoState.textDragStartX = e.clientX;
                photoState.textDragStartY = e.clientY;
            };

            cameraPreview.ondragover = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            cameraPreview.ondrop = (e) => {
                e.preventDefault();
                const rect = cameraPreview.getBoundingClientRect();
                const newX = e.clientX - rect.left - (rect.width / 2);
                const newY = e.clientY - rect.top - (rect.height / 2);

                // Update position
                photoState.photoSettings.textOverlay.offsetX = Math.round(newX);
                photoState.photoSettings.textOverlay.offsetY = Math.round(newY);

                // Update overlay position
                overlay.style.left = `calc(50% + ${newX}px)`;
                overlay.style.top = `calc(50% + ${newY}px)`;

                console.log(' Text moved to:', { x: newX, y: newY });
                showToastRecording(' Text moved', 'success', '');
            };

            cameraPreview.appendChild(overlay);

            console.log(' Text overlay applied to camera-preview:', { text, size, color });
            showToastRecording(' Text added! Click to edit | Drag to move', 'success', '');
            closePhotoModal();

            // Close modal
            const modal = document.querySelector('div[style*="position: fixed"][style*="min-width: 320px"]');
            if (modal) modal.remove();
        }

        function openTextEditDialog() {
            const textData = photoState.photoSettings.textOverlay;
            if (!textData) return;

            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 2px solid #4C1D95;
                border-radius: 12px;
                padding: 20px;
                z-index: 3001;
                min-width: 320px;
                color: white;
            `;

            modal.innerHTML = `
                <h3 style="margin-top: 0; color: #fff;"> Edit Text</h3>
                
                <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;"> Text</label>
                <input type="text" id="editPhotoTextInput" value="${textData.text}" style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; color: white; border-radius: 6px; margin-bottom: 15px; font-size: 14px;">
                
                <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;"> Color</label>
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; margin-bottom: 15px;">
                    <button onclick="updateTextColor('#ffffff')" style="padding: 15px; background: white; border: 2px solid ${textData.color === '#ffffff' ? '#4C1D95' : 'transparent'}; border-radius: 6px; cursor: pointer;" title="White"></button>
                    <button onclick="updateTextColor('#000000')" style="padding: 15px; background: black; border: 2px solid ${textData.color === '#000000' ? '#4C1D95' : 'transparent'}; border-radius: 6px; cursor: pointer;" title="Black"></button>
                    <button onclick="updateTextColor('#ff0000')" style="padding: 15px; background: red; border: 2px solid ${textData.color === '#ff0000' ? '#4C1D95' : 'transparent'}; border-radius: 6px; cursor: pointer;" title="Red"></button>
                    <button onclick="updateTextColor('#ffff00')" style="padding: 15px; background: yellow; border: 2px solid ${textData.color === '#ffff00' ? '#4C1D95' : 'transparent'}; border-radius: 6px; cursor: pointer;" title="Yellow"></button>
                    <button onclick="updateTextColor('#00ff00')" style="padding: 15px; background: lime; border: 2px solid ${textData.color === '#00ff00' ? '#4C1D95' : 'transparent'}; border-radius: 6px; cursor: pointer;" title="Green"></button>
                    <button onclick="updateTextColor('#4C1D95')" style="padding: 15px; background: #4C1D95; border: 2px solid ${textData.color === '#4C1D95' ? '#fff' : 'transparent'}; border-radius: 6px; cursor: pointer;" title="Purple"></button>
                </div>
                
                <label style="display: block; color: #aaa; font-size: 12px; margin-bottom: 5px;"> Size: <span id="editTextSizeDisplay">${textData.size}</span>px</label>
                <input type="range" id="editPhotoTextSize" min="12" max="72" value="${textData.size}" style="width: 100%; margin-bottom: 15px; cursor: pointer;" oninput="document.getElementById('editTextSizeDisplay').textContent = this.value; updateTextSize(this.value)">
                
                <div style="display: flex; gap: 10px;">
                    <button onclick="saveTextEdits()" style="flex: 1; padding: 10px; background: #4C1D95; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;"> Save</button>
                    <button onclick="this.closest('div').remove()" style="flex: 1; padding: 10px; background: #333; color: white; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
                </div>
            `;

            document.body.appendChild(modal);
            document.getElementById('editPhotoTextInput').focus();
        }

        function updateTextColor(color) {
            photoState.photoSettings.textOverlay.color = color;
            updateTextOverlay();
        }

        function updateTextSize(size) {
            photoState.photoSettings.textOverlay.size = size;
            updateTextOverlay();
        }

        function updateTextOverlay() {
            const overlay = document.getElementById('photoTextOverlay');
            if (overlay) {
                const textData = photoState.photoSettings.textOverlay;
                overlay.style.color = textData.color;
                overlay.style.fontSize = textData.size + 'px';
            }
        }

        function saveTextEdits() {
            const newText = document.getElementById('editPhotoTextInput').value.trim();
            const newSize = document.getElementById('editPhotoTextSize').value;

            if (!newText) {
                showToastRecording(' Please enter some text', 'warning', '');
                return;
            }

            // Update stored data
            photoState.photoSettings.textOverlay.text = newText;
            photoState.photoSettings.textOverlay.size = newSize;

            // Update overlay
            const overlay = document.getElementById('photoTextOverlay');
            if (overlay) {
                overlay.textContent = newText;
                overlay.style.fontSize = newSize + 'px';
                overlay.style.color = photoState.photoSettings.textOverlay.color;
            }

            // Close modal
            const modal = document.querySelector('div[style*="position: fixed"][style*="min-width: 320px"]');
            if (modal && modal !== document.querySelector('[style*="top: 50%"]')) modal.remove();

            showToastRecording(' Text updated', 'success', '');
        }

        // ====== TIKTOK-STYLE CROP SYSTEM ======
        let cropState = {
            isDragging: false,
            startX: 0,
            startY: 0,
            currentRatio: '9:16',
            zoom: 1,
            panX: 0,
            panY: 0,
            canvas: null,
            ctx: null,
            image: null,
            croppedData: null
        };

        function photoCrop() {
            console.log(' Opening professional crop editor');

            // Get current photo from photoState
            if (!photoState.capturedPhotos || photoState.capturedPhotos.length === 0) {
                showToastRecording(' No photo to crop', 'error', '');
                return;
            }

            const currentPhoto = photoState.capturedPhotos[photoState.currentPhotoIndex];
            if (!currentPhoto) {
                showToastRecording(' No photo to crop', 'error', '');
                return;
            }

            // Create main overlay
            const overlay = document.createElement('div');
            overlay.id = 'tiktokCropOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(135deg, rgba(26, 26, 26, 0.98) 0%, rgba(10, 10, 10, 0.98) 100%);
                z-index: 3000;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 0;
                margin: 0;
                animation: fadeIn 0.3s ease-out;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;

            overlay.innerHTML = `
                <div style="width: 100%; height: 100%; display: flex; flex-direction: column; background: transparent; max-height: 100vh;">
                    <!-- Top Bar -->
                    <div style="background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, transparent 100%); padding: max(12px, 1vh) max(16px, 2vw); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;">
                        <button onclick="closeCropEditor()" style="background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.15); color: white; font-size: clamp(20px, 5vw, 28px); cursor: pointer; padding: clamp(8px, 2vh, 12px); width: clamp(40px, 10vw, 50px); height: clamp(40px, 10vw, 50px); border-radius: 12px; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; hover: background rgba(255,255,255,0.15);"></button>
                        <h2 style="margin: 0; color: white; font-size: clamp(18px, 4vw, 24px); font-weight: 700; flex: 1; text-align: center; letter-spacing: -0.5px;">Crop Your Photo</h2>
                        <div style="width: clamp(40px, 10vw, 50px);"></div>
                    </div>
                    
                    <!-- Crop Canvas Area -->
                    <div style="flex: 1; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; width: 100%; padding: max(12px, 1vh) max(16px, 2vw); min-height: 0;">
                        <div style="position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; border-radius: 16px; overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                            <canvas id="cropCanvas" style="max-width: 100%; max-height: 100%; cursor: grab; touch-action: none; display: block; border-radius: 12px;"></canvas>
                            <!-- Grid Overlay -->
                            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; border: 2px solid rgba(76, 29, 149, 0.4); border-radius: 12px;">
                                <div style="position: absolute; width: 100%; height: 100%; background-image: linear-gradient(0deg, transparent 32%, rgba(76, 29, 149, 0.15) 33%, rgba(76, 29, 149, 0.15) 34%, transparent 35%, transparent 65%, rgba(76, 29, 149, 0.15) 66%, rgba(76, 29, 149, 0.15) 67%, transparent 68%), linear-gradient(90deg, transparent 32%, rgba(76, 29, 149, 0.15) 33%, rgba(76, 29, 149, 0.15) 34%, transparent 35%, transparent 65%, rgba(76, 29, 149, 0.15) 66%, rgba(76, 29, 149, 0.15) 67%, transparent 68%); background-size: 33.33% 33.33%; border-radius: 12px;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Control Panel -->
                    <div style="background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.6) 100%); padding: max(16px, 2vh) max(16px, 2vw); width: 100%; border-top: 1px solid rgba(255,255,255,0.1); flex-shrink: 0; max-height: 45vh; overflow-y: auto;">
                        
                        <!-- Aspect Ratios Section -->
                        <div style="margin-bottom: clamp(16px, 2vh, 24px);">
                            <label style="display: block; color: rgba(255,255,255,0.6); font-size: clamp(11px, 1.5vw, 13px); margin: 0 0 clamp(8px, 1vh, 12px) 0; text-transform: uppercase; letter-spacing: 1.5px; font-weight: 700;">Aspect Ratio</label>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(clamp(50px, 15vw, 70px), 1fr)); gap: clamp(8px, 1.5vw, 12px); width: 100%;">
                                <button onclick="setCropRatio('1:1')" class="ratio-btn" title="Square 1:1" style="aspect-ratio: 1; background: rgba(100,100,100,0.4); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; font-size: clamp(10px, 1.5vw, 13px); cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; padding: clamp(6px, 1vh, 10px);">1:1</button>
                                <button onclick="setCropRatio('3:4')" class="ratio-btn" title="Portrait 3:4" style="aspect-ratio: 0.75; background: rgba(100,100,100,0.4); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; font-size: clamp(10px, 1.5vw, 13px); cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; padding: clamp(6px, 1vh, 10px);">3:4</button>
                                <button onclick="setCropRatio('9:16')" class="ratio-btn active-ratio" title="Vertical 9:16 (TikTok/Reels)" style="aspect-ratio: 0.5625; background: linear-gradient(135deg, rgba(76, 29, 149, 0.8), rgba(109, 40, 217, 0.8)); border: 2px solid rgba(109, 40, 217, 0.8); border-radius: 12px; color: white; font-size: clamp(10px, 1.5vw, 13px); cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; padding: clamp(6px, 1vh, 10px); box-shadow: 0 0 15px rgba(76, 29, 149, 0.4);">9:16</button>
                                <button onclick="setCropRatio('16:9')" class="ratio-btn" title="Landscape 16:9" style="aspect-ratio: 1.78; background: rgba(100,100,100,0.4); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; font-size: clamp(10px, 1.5vw, 13px); cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; padding: clamp(6px, 1vh, 10px);">16:9</button>
                                <button onclick="setCropRatio('free')" class="ratio-btn" title="Free crop (no ratio)" style="aspect-ratio: 1; background: rgba(100,100,100,0.4); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; font-size: clamp(10px, 1.5vw, 13px); cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; padding: clamp(6px, 1vh, 10px);">Free</button>
                            </div>
                        </div>
                        
                        <!-- Zoom Control -->
                        <div style="margin-bottom: clamp(16px, 2vh, 24px);">
                            <label style="display: block; color: rgba(255,255,255,0.6); font-size: clamp(11px, 1.5vw, 13px); margin: 0 0 clamp(8px, 1vh, 12px) 0; text-transform: uppercase; letter-spacing: 1.5px; font-weight: 700;">Zoom</label>
                            <div style="display: flex; gap: clamp(8px, 2vw, 12px); align-items: center; flex-wrap: wrap;">
                                <button onclick="adjustZoom(-0.1)" title="Zoom out" style="background: rgba(100,100,100,0.5); border: 1px solid rgba(255,255,255,0.2); color: white; width: clamp(38px, 8vw, 44px); height: clamp(38px, 8vw, 44px); border-radius: 10px; cursor: pointer; font-size: clamp(14px, 2vw, 18px); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; font-weight: 600;"></button>
                                <input type="range" id="zoomSlider" min="1" max="3" step="0.1" value="1" oninput="setZoom(this.value)" style="flex: 1; min-width: 80px; height: 6px; border-radius: 3px; background: linear-gradient(90deg, rgba(76,29,149,0.3) 0%, rgba(76,29,149,0.6) 100%); outline: none; -webkit-appearance: none; appearance: none; cursor: pointer;">
                                <button onclick="adjustZoom(0.1)" title="Zoom in" style="background: rgba(100,100,100,0.5); border: 1px solid rgba(255,255,255,0.2); color: white; width: clamp(38px, 8vw, 44px); height: clamp(38px, 8vw, 44px); border-radius: 10px; cursor: pointer; font-size: clamp(14px, 2vw, 18px); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; font-weight: 600;">+</button>
                                <span id="zoomValue" style="color: rgba(255,255,255,0.7); font-size: clamp(12px, 1.5vw, 14px); min-width: clamp(40px, 10vw, 50px); text-align: right; font-weight: 600; font-variant-numeric: tabular-nums;">100%</span>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: clamp(8px, 2vw, 12px); width: 100%;">
                            <button onclick="resetCrop()" title="Reset crop to original" style="background: rgba(100,100,100,0.5); border: 1px solid rgba(255,255,255,0.2); color: white; padding: clamp(11px, 2vh, 14px); border-radius: 12px; cursor: pointer; font-weight: 700; font-size: clamp(13px, 1.5vw, 15px); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; gap: 6px;"> Reset</button>
                            <button onclick="applyCropTikTok()" title="Apply crop changes" style="background: linear-gradient(135deg, #4C1D95, #6D28D9); border: none; color: white; padding: clamp(11px, 2vh, 14px); border-radius: 12px; cursor: pointer; font-weight: 700; font-size: clamp(13px, 1.5vw, 15px); transition: all 0.3s ease; box-shadow: 0 8px 20px rgba(76, 29, 149, 0.4); display: flex; align-items: center; justify-content: center; gap: 6px;"> Apply</button>
                        </div>
                    </div>
                </div>
            `;

            // Add range slider styling
            const style = document.createElement('style');
            style.textContent = `
                #zoomSlider::-webkit-slider-thumb {
                    -webkit-appearance: none;
                    appearance: none;
                    width: 18px;
                    height: 18px;
                    border-radius: 50%;
                    background: linear-gradient(135deg, #4C1D95, #6D28D9);
                    cursor: pointer;
                    box-shadow: 0 2px 8px rgba(76, 29, 149, 0.5);
                    border: 2px solid white;
                }
                
                #zoomSlider::-moz-range-thumb {
                    width: 18px;
                    height: 18px;
                    border-radius: 50%;
                    background: linear-gradient(135deg, #4C1D95, #6D28D9);
                    cursor: pointer;
                    box-shadow: 0 2px 8px rgba(76, 29, 149, 0.5);
                    border: 2px solid white;
                }
                
                .ratio-btn:hover {
                    background: rgba(100,100,100,0.6) !important;
                    border-color: rgba(255,255,255,0.4) !important;
                    transform: translateY(-2px);
                }
                
                @keyframes fadeIn {
                    from {
                        opacity: 0;
                    }
                    to {
                        opacity: 1;
                    }
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(overlay);

            // Initialize crop canvas
            setTimeout(() => {
                initCropCanvas(currentPhoto.url);
            }, 100);

            showToastRecording(' Drag to move, wheel to zoom', 'info', '');
        }

        function initCropCanvas(photoUrl) {
            const canvas = document.getElementById('cropCanvas');
            const container = canvas.parentElement;

            if (!canvas || !container) {
                console.error('Canvas or container not found');
                return;
            }

            // Load image
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = function () {
                cropState.image = img;

                // Set canvas size based on aspect ratio
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;

                let canvasWidth = containerWidth * 0.9;
                let canvasHeight = (canvasWidth / 16) * 9; // Default 9:16

                if (canvasHeight > containerHeight * 0.8) {
                    canvasHeight = containerHeight * 0.8;
                    canvasWidth = (canvasHeight / 9) * 16;
                }

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                cropState.canvas = canvas;
                cropState.ctx = canvas.getContext('2d');

                drawCropCanvas();
                attachCropControls();

                console.log(' Crop canvas initialized');
            };

            img.onerror = function () {
                console.error('Failed to load image for crop');
                showToastRecording(' Failed to load photo', 'error', '');
                closeCropEditor();
            };

            img.src = photoUrl;
        }

        function drawCropCanvas() {
            const { ctx, canvas, image, zoom, panX, panY } = cropState;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!image) return;

            ctx.save();

            // Draw image with zoom and pan
            const imgWidth = canvas.width * zoom;
            const imgHeight = canvas.height * zoom;
            const x = (canvas.width - imgWidth) / 2 + panX;
            const y = (canvas.height - imgHeight) / 2 + panY;

            ctx.drawImage(image, x, y, imgWidth, imgHeight);
            ctx.restore();
        }

        function attachCropControls() {
            const canvas = cropState.canvas;

            // Mouse events
            canvas.addEventListener('mousedown', (e) => {
                cropState.isDragging = true;
                cropState.startX = e.clientX;
                cropState.startY = e.clientY;
                canvas.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (cropState.isDragging) {
                    const deltaX = e.clientX - cropState.startX;
                    const deltaY = e.clientY - cropState.startY;

                    cropState.panX += deltaX;
                    cropState.panY += deltaY;
                    cropState.startX = e.clientX;
                    cropState.startY = e.clientY;

                    drawCropCanvas();
                }
            });

            document.addEventListener('mouseup', () => {
                cropState.isDragging = false;
                canvas.style.cursor = 'grab';
            });

            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    cropState.isDragging = true;
                    cropState.startX = e.touches[0].clientX;
                    cropState.startY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    cropState.isDragging = false;
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && cropState.isDragging) {
                    const deltaX = e.touches[0].clientX - cropState.startX;
                    const deltaY = e.touches[0].clientY - cropState.startY;

                    cropState.panX += deltaX;
                    cropState.panY += deltaY;
                    cropState.startX = e.touches[0].clientX;
                    cropState.startY = e.touches[0].clientY;

                    drawCropCanvas();
                }
            });

            canvas.addEventListener('touchend', () => {
                cropState.isDragging = false;
            });

            // Wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
                setZoom(Math.max(1, Math.min(3, cropState.zoom + zoomDelta)));
            });
        }

        function setCropRatio(ratio) {
            console.log(' Crop ratio set to:', ratio);
            cropState.currentRatio = ratio;

            // Update button states
            document.querySelectorAll('.ratio-btn').forEach(btn => {
                btn.classList.remove('active-ratio');
                btn.style.background = '#333';
                btn.style.borderColor = '#444';
            });

            event.target.classList.add('active-ratio');
            event.target.style.background = '#4C1D95';
            event.target.style.borderColor = '#6D28D9';

            // Update canvas ratio
            if (cropState.canvas && ratio !== 'free') {
                const container = cropState.canvas.parentElement;
                const containerWidth = container.clientWidth;
                let newHeight;

                const [w, h] = ratio.split(':').map(Number);
                newHeight = (containerWidth * 0.9 / w) * h;

                if (newHeight > container.clientHeight * 0.8) {
                    const newWidth = (container.clientHeight * 0.8 / h) * w;
                    cropState.canvas.width = newWidth;
                    cropState.canvas.height = container.clientHeight * 0.8;
                } else {
                    cropState.canvas.width = containerWidth * 0.9;
                    cropState.canvas.height = newHeight;
                }

                drawCropCanvas();
            }
        }

        function setZoom(value) {
            cropState.zoom = parseFloat(value);
            document.getElementById('zoomSlider').value = value;
            document.getElementById('zoomValue').textContent = Math.round(value * 100) + '%';
            drawCropCanvas();
        }

        function adjustZoom(delta) {
            const newZoom = Math.max(1, Math.min(3, cropState.zoom + delta));
            setZoom(newZoom);
        }

        function resetCrop() {
            cropState.panX = 0;
            cropState.panY = 0;
            cropState.zoom = 1;
            document.getElementById('zoomSlider').value = 1;
            document.getElementById('zoomValue').textContent = '100%';
            drawCropCanvas();
            showToastRecording(' Reset complete', 'info', '');
        }

        function applyCropTikTok() {
            console.log(' Applying TikTok crop');
            const canvas = cropState.canvas;
            cropState.croppedData = canvas.toDataURL('image/jpeg', 0.95);

            // Update the captured photo in photoState
            if (photoState.capturedPhotos && photoState.capturedPhotos[photoState.currentPhotoIndex]) {
                photoState.capturedPhotos[photoState.currentPhotoIndex].editedUrl = cropState.croppedData;
                photoState.capturedPhotos[photoState.currentPhotoIndex].hasEdits = true;

                // Update preview in screen6 using displayCapturedPhoto
                displayCapturedPhoto();
                console.log(' Screen6 preview updated with cropped image');
            }

            closeCropEditor();
            showToastRecording(' Crop applied successfully', 'success', '');
        }

        function closeCropEditor() {
            const overlay = document.getElementById('tiktokCropOverlay');
            if (overlay) {
                overlay.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => overlay.remove(), 300);
            }
        }

        function photoAddEffects() {
            console.log(' Opening professional effects editor');

            // Create main overlay
            const overlay = document.createElement('div');
            overlay.id = 'tiktokEffectsOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(135deg, rgba(26, 26, 26, 0.98) 0%, rgba(10, 10, 10, 0.98) 100%);
                z-index: 3000;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 0;
                margin: 0;
                animation: fadeIn 0.3s ease-out;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            `;

            overlay.innerHTML = `
                <div style="width: 100%; height: 100%; display: flex; flex-direction: column; background: transparent; max-height: 100vh;">
                    <!-- Top Bar -->
                    <div style="background: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, transparent 100%); padding: max(12px, 1vh) max(16px, 2vw); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;">
                        <button onclick="closeEffectsEditor()" style="background: rgba(255,255,255,0.1); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.15); color: white; font-size: clamp(20px, 5vw, 28px); cursor: pointer; padding: clamp(8px, 2vh, 12px); width: clamp(40px, 10vw, 50px); height: clamp(40px, 10vw, 50px); border-radius: 12px; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease;"></button>
                        <h2 style="margin: 0; color: white; font-size: clamp(18px, 4vw, 24px); font-weight: 700; flex: 1; text-align: center; letter-spacing: -0.5px;">Photo Effects</h2>
                        <div style="width: clamp(40px, 10vw, 50px);"></div>
                    </div>
                    
                    <!-- Preview Area -->
                    <div style="flex: 1; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; width: 100%; padding: max(12px, 1vh) max(16px, 2vw); min-height: 0; background: rgba(0,0,0,0.3);">
                        <div style="position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; border-radius: 16px; overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                            <div id="effectPreviewContainer" style="width: 100%; height: 100%; position: relative; border-radius: 12px; overflow: hidden; display: flex; align-items: center; justify-content: center; background: #000;">
                                <!-- Placeholder for preview -->
                                <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; color: rgba(255,255,255,0.4); gap: 12px; font-size: clamp(14px, 2vw, 16px);">
                                    <span style="font-size: clamp(28px, 5vw, 48px);"></span>
                                    <span>Select an effect to preview</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Effects Panel -->
                    <div style="background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.7) 100%); padding: max(16px, 2vh) max(16px, 2vw); width: 100%; border-top: 1px solid rgba(255,255,255,0.1); flex-shrink: 0; max-height: 40vh; overflow-y: auto;">
                        
                        <!-- Effects Grid -->
                        <div style="margin-bottom: clamp(16px, 2vh, 24px);">
                            <label style="display: block; color: rgba(255,255,255,0.6); font-size: clamp(11px, 1.5vw, 13px); margin: 0 0 clamp(12px, 2vh, 16px) 0; text-transform: uppercase; letter-spacing: 1.5px; font-weight: 700;">Available Effects</label>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(clamp(70px, 20vw, 90px), 1fr)); gap: clamp(10px, 2vw, 14px); width: 100%;">
                                
                                <!-- Original Effect -->
                                <button onclick="previewEffect('none')" class="effect-btn effect-none" title="No effect - Original" style="aspect-ratio: 1; background: rgba(100,100,100,0.4); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px; padding: clamp(8px, 1.5vh, 12px); font-size: clamp(9px, 1vw, 11px);">
                                    <span style="font-size: clamp(18px, 3vw, 24px);"></span>
                                    <span>Original</span>
                                </button>
                                
                                <!-- Blur Effect -->
                                <button onclick="previewEffect('blur')" class="effect-btn effect-blur" title="Soft blur effect" style="aspect-ratio: 1; background: rgba(100,100,100,0.4); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px; padding: clamp(8px, 1.5vh, 12px); font-size: clamp(9px, 1vw, 11px);">
                                    <span style="font-size: clamp(18px, 3vw, 24px);"></span>
                                    <span>Blur</span>
                                </button>
                                
                                <!-- Grayscale Effect -->
                                <button onclick="previewEffect('grayscale')" class="effect-btn effect-grayscale" title="Black & white" style="aspect-ratio: 1; background: rgba(100,100,100,0.4); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px; padding: clamp(8px, 1.5vh, 12px); font-size: clamp(9px, 1vw, 11px);">
                                    <span style="font-size: clamp(18px, 3vw, 24px);"></span>
                                    <span>B&W</span>
                                </button>
                                
                                <!-- Sepia Effect -->
                                <button onclick="previewEffect('sepia')" class="effect-btn effect-sepia" title="Warm vintage tone" style="aspect-ratio: 1; background: rgba(100,100,100,0.4); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px; padding: clamp(8px, 1.5vh, 12px); font-size: clamp(9px, 1vw, 11px);">
                                    <span style="font-size: clamp(18px, 3vw, 24px);"></span>
                                    <span>Sepia</span>
                                </button>
                                
                                <!-- Invert Effect -->
                                <button onclick="previewEffect('invert')" class="effect-btn effect-invert" title="Color inversion" style="aspect-ratio: 1; background: rgba(100,100,100,0.4); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px; padding: clamp(8px, 1.5vh, 12px); font-size: clamp(9px, 1vw, 11px);">
                                    <span style="font-size: clamp(18px, 3vw, 24px);"></span>
                                    <span>Invert</span>
                                </button>
                                
                                <!-- Brighten Effect -->
                                <button onclick="previewEffect('brighten')" class="effect-btn effect-brighten" title="Increase brightness" style="aspect-ratio: 1; background: rgba(100,100,100,0.4); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px; padding: clamp(8px, 1.5vh, 12px); font-size: clamp(9px, 1vw, 11px);">
                                    <span style="font-size: clamp(18px, 3vw, 24px);"></span>
                                    <span>Bright</span>
                                </button>
                                
                                <!-- Contrast Effect -->
                                <button onclick="previewEffect('contrast')" class="effect-btn effect-contrast" title="Enhance contrast" style="aspect-ratio: 1; background: rgba(100,100,100,0.4); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px; padding: clamp(8px, 1.5vh, 12px); font-size: clamp(9px, 1vw, 11px);">
                                    <span style="font-size: clamp(18px, 3vw, 24px);"></span>
                                    <span>Contrast</span>
                                </button>
                                
                                <!-- Saturate Effect -->
                                <button onclick="previewEffect('saturate')" class="effect-btn effect-saturate" title="Boost color" style="aspect-ratio: 1; background: rgba(100,100,100,0.4); border: 2px solid rgba(255,255,255,0.2); border-radius: 12px; color: white; cursor: pointer; font-weight: 700; transition: all 0.3s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 6px; padding: clamp(8px, 1.5vh, 12px); font-size: clamp(9px, 1vw, 11px);">
                                    <span style="font-size: clamp(18px, 3vw, 24px);"></span>
                                    <span>Saturate</span>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Info Message -->
                        <div style="background: rgba(76, 29, 149, 0.2); border: 1px solid rgba(76, 29, 149, 0.4); border-radius: 10px; padding: clamp(10px, 1.5vh, 14px) clamp(12px, 2vw, 16px); margin-bottom: clamp(12px, 2vh, 16px); text-align: center;">
                            <p style="margin: 0; color: rgba(255,255,255,0.7); font-size: clamp(12px, 1.5vw, 14px); line-height: 1.5;">
                                <span id="effectStatus" style="font-weight: 600;">Select an effect to preview in real-time</span>
                            </p>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: clamp(8px, 2vw, 12px); width: 100%;">
                            <button onclick="closeEffectsEditor()" style="background: rgba(100,100,100,0.5); border: 1px solid rgba(255,255,255,0.2); color: white; padding: clamp(11px, 2vh, 14px); border-radius: 12px; cursor: pointer; font-weight: 700; font-size: clamp(13px, 1.5vw, 15px); transition: all 0.3s ease; display: flex; align-items: center; justify-content: center; gap: 6px;"> Cancel</button>
                            <button onclick="applyCurrentEffect()" style="background: linear-gradient(135deg, #4C1D95, #6D28D9); border: none; color: white; padding: clamp(11px, 2vh, 14px); border-radius: 12px; cursor: pointer; font-weight: 700; font-size: clamp(13px, 1.5vw, 15px); transition: all 0.3s ease; box-shadow: 0 8px 20px rgba(76, 29, 149, 0.4); display: flex; align-items: center; justify-content: center; gap: 6px;"> Apply</button>
                        </div>
                    </div>
                </div>
            `;

            // Add effect button styling
            const style = document.createElement('style');
            style.textContent = `
                .effect-btn {
                    position: relative;
                    overflow: hidden;
                }
                
                .effect-btn:hover {
                    background: rgba(100,100,100,0.6) !important;
                    border-color: rgba(255,255,255,0.4) !important;
                    transform: translateY(-2px) scale(1.05);
                }
                
                .effect-btn.active {
                    background: linear-gradient(135deg, rgba(76, 29, 149, 0.8), rgba(109, 40, 217, 0.8)) !important;
                    border-color: rgba(109, 40, 217, 0.8) !important;
                    box-shadow: 0 0 20px rgba(76, 29, 149, 0.6) !important;
                }
            `;
            document.head.appendChild(style);

            document.body.appendChild(overlay);

            // Load and display the photo in preview
            setTimeout(() => {
                loadPhotoToEffectsPreview();
            }, 100);

            showToastRecording(' Tap effects to preview', 'info', '');
        }

        function loadPhotoToEffectsPreview() {
            // Get current photo
            if (!photoState.capturedPhotos || photoState.capturedPhotos.length === 0) {
                console.error('No photo to preview');
                return;
            }

            const currentPhoto = photoState.capturedPhotos[photoState.currentPhotoIndex];
            if (!currentPhoto) {
                console.error('Current photo not found');
                return;
            }

            const container = document.getElementById('effectPreviewContainer');
            if (!container) {
                console.error('Preview container not found');
                return;
            }

            // Create preview image
            const previewImg = document.createElement('img');
            previewImg.id = 'effectPreviewImage';
            previewImg.src = currentPhoto.url;
            previewImg.style.cssText = `
                width: 100%;
                height: 100%;
                object-fit: contain;
                display: block;
                background: #000;
            `;

            previewImg.onload = function () {
                // Clear placeholder and add image
                container.innerHTML = '';
                container.appendChild(previewImg);
                console.log(' Photo loaded to effects preview');

                // Apply any previously selected effect
                if (photoState.currentEffectPreview) {
                    applyEffectToPreview(photoState.currentEffectPreview);
                }
            };

            previewImg.onerror = function () {
                console.error('Failed to load photo for effects');
                container.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; color: rgba(255,255,255,0.4); gap: 12px; font-size: clamp(14px, 2vw, 16px);">
                        <span style="font-size: clamp(28px, 5vw, 48px);"></span>
                        <span>Failed to load photo</span>
                    </div>
                `;
            };
        }

        function applyEffectToPreview(effect) {
            const previewImg = document.getElementById('effectPreviewImage');
            if (!previewImg) return;

            switch (effect) {
                case 'none':
                    previewImg.style.filter = 'none';
                    break;
                case 'blur':
                    previewImg.style.filter = 'blur(8px)';
                    break;
                case 'grayscale':
                    previewImg.style.filter = 'grayscale(1)';
                    break;
                case 'sepia':
                    previewImg.style.filter = 'sepia(0.8)';
                    break;
                case 'invert':
                    previewImg.style.filter = 'invert(1)';
                    break;
                case 'brighten':
                    previewImg.style.filter = 'brightness(1.4)';
                    break;
                case 'contrast':
                    previewImg.style.filter = 'contrast(1.5)';
                    break;
                case 'saturate':
                    previewImg.style.filter = 'saturate(2)';
                    break;
            }
        }

        function previewEffect(effect) {
            console.log(' Previewing effect:', effect);
            photoState.currentEffectPreview = effect;

            // Apply effect to preview image in the effects editor
            applyEffectToPreview(effect);

            // Update effect status message
            const statusEl = document.getElementById('effectStatus');
            if (statusEl) {
                const effectNames = {
                    'none': ' Original - No effect',
                    'blur': ' Blur - Soft focus effect',
                    'grayscale': ' Black & White - Classic B&W',
                    'sepia': ' Sepia - Warm vintage tone',
                    'invert': ' Invert - Negative colors',
                    'brighten': ' Brighten - Increase brightness',
                    'contrast': ' Contrast - Enhanced detail',
                    'saturate': ' Saturate - Vivid colors'
                };
                statusEl.textContent = effectNames[effect] || 'Effect preview';
            }

            // Update active button state
            document.querySelectorAll('.effect-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event?.target?.closest('.effect-btn')?.classList.add('active');

            // Brief visual feedback
            const button = event?.target?.closest('.effect-btn');
            if (button) {
                button.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    button.style.transform = '';
                }, 100);
            }
        }

        function applyCurrentEffect() {
            const effect = photoState.currentEffectPreview;

            if (!effect) {
                showToastRecording(' No effect selected', 'warning', '');
                return;
            }

            console.log(' Applied effect:', effect);
            photoState.photoSettings.effect = effect;

            // Update the stored photo with effect
            if (photoState.capturedPhotos && photoState.capturedPhotos[photoState.currentPhotoIndex]) {
                photoState.capturedPhotos[photoState.currentPhotoIndex].effect = effect;
                console.log(' Saved effect to photo data:', effect);
            }

            // Apply effect to screen6 preview immediately
            applyStoredEffectToScreen6(effect);

            closeEffectsEditor();
            showToastRecording(` ${effect} effect applied`, 'success', '');
        }

        function closeEffectsEditor() {
            const overlay = document.getElementById('tiktokEffectsOverlay');
            if (overlay) {
                overlay.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => overlay.remove(), 300);
            }
        }

        function clearEffectPreview() {
            const screen6 = document.getElementById('screen6');
            const cameraPreview = screen6?.querySelector('.camera-preview img');
            if (cameraPreview) {
                cameraPreview.style.filter = 'none';
            }
            photoState.currentEffectPreview = null;
        }

        function photoDraw() {
            console.log(' Opening drawing tool');
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 2px solid #4C1D95;
                border-radius: 12px;
                padding: 20px;
                z-index: 3000;
                min-width: 320px;
                color: white;
            `;

            modal.innerHTML = `
                <h3 style="margin-top: 0; color: #fff;"> Drawing Tool</h3>
                <p style="color: #aaa; margin: 10px 0; font-size: 12px;"> Pen Color:</p>
                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; margin-bottom: 15px;">
                    <button onclick="setDrawColor('#ffffff')" style="padding: 15px; background: white; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="White"></button>
                    <button onclick="setDrawColor('#000000')" style="padding: 15px; background: black; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Black"></button>
                    <button onclick="setDrawColor('#ff0000')" style="padding: 15px; background: red; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Red"></button>
                    <button onclick="setDrawColor('#ffff00')" style="padding: 15px; background: yellow; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Yellow"></button>
                    <button onclick="setDrawColor('#00ff00')" style="padding: 15px; background: lime; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Green"></button>
                    <button onclick="setDrawColor('#4C1D95')" style="padding: 15px; background: #4C1D95; border: 2px solid transparent; border-radius: 6px; cursor: pointer;" title="Purple"></button>
                </div>
                <p style="color: #aaa; margin: 10px 0; font-size: 12px;"> Pen Size: <span id="drawSizeDisplay">5</span>px</p>
                <input type="range" id="drawSize" min="2" max="30" value="5" style="width: 100%; margin-bottom: 15px; cursor: pointer;" oninput="document.getElementById('drawSizeDisplay').textContent = this.value">
                
                <p style="color: #aaa; margin: 10px 0; font-size: 12px;"> Tools:</p>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button onclick="setDrawTool('pen')" style="flex: 1; padding: 10px; background: #4C1D95; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;"> Pen</button>
                    <button onclick="setDrawTool('eraser')" style="flex: 1; padding: 10px; background: #333; color: white; border: none; border-radius: 6px; cursor: pointer;"> Eraser</button>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button onclick="enableDrawingMode()" style="flex: 1; padding: 10px; background: #22c55e; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;"> Start Drawing</button>
                    <button onclick="this.closest('div').remove()" style="flex: 1; padding: 10px; background: #333; color: white; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
                </div>
            `;

            document.body.appendChild(modal);
            photoState.photoSettings.drawColor = '#ffffff';
            showToastRecording(' Select pen color and size', 'info', '');
        }

        function setDrawColor(color) {
            photoState.photoSettings.drawColor = color;
            console.log('Draw color set to:', color);
            showToastRecording(' Color: ' + color, 'success', '');
        }

        function setDrawTool(tool) {
            photoState.photoSettings.drawTool = tool;
            console.log('Draw tool set to:', tool);
            showToastRecording('Tool: ' + (tool === 'pen' ? ' Pen' : ' Eraser'), 'success', '');
        }

        function enableDrawingMode() {
            const modal = document.querySelector('[style*="position: fixed"]');
            if (modal) modal.remove();

            const drawColor = photoState.photoSettings.drawColor || '#ffffff';
            const drawSize = document.getElementById('drawSize')?.value || 5;

            // Create drawing overlay canvas
            const video = document.getElementById('photoPreviewVideo');
            if (!video) {
                showToastRecording(' Photo not loaded', 'error', '');
                return;
            }

            let drawCanvas = document.getElementById('photoDrawCanvas');
            if (!drawCanvas) {
                drawCanvas = document.createElement('canvas');
                drawCanvas.id = 'photoDrawCanvas';
                drawCanvas.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    cursor: crosshair;
                    z-index: 20;
                `;
                video.parentElement.appendChild(drawCanvas);

                // Set canvas size to match video
                const rect = video.getBoundingClientRect();
                drawCanvas.width = rect.width;
                drawCanvas.height = rect.height;
            }

            const ctx = drawCanvas.getContext('2d');
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;

            // Drawing mouse events
            drawCanvas.onmousedown = (e) => {
                isDrawing = true;
                const rect = drawCanvas.getBoundingClientRect();
                lastX = e.clientX - rect.left;
                lastY = e.clientY - rect.top;
            };

            drawCanvas.onmousemove = (e) => {
                if (!isDrawing) return;

                const rect = drawCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                ctx.strokeStyle = drawColor;
                ctx.lineWidth = drawSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();

                lastX = x;
                lastY = y;
            };

            drawCanvas.onmouseup = () => {
                isDrawing = false;
            };

            drawCanvas.onmouseleave = () => {
                isDrawing = false;
            };

            photoState.photoSettings.hasDrawing = true;
            showToastRecording(' Drawing mode - draw on photo (click anywhere)', 'success', '');
        }

        // Post photo
        async function saveDraftPhoto() {
            if (!currentUser || photoState.capturedPhotos.length === 0) {
                alert('Please login and capture a photo first');
                return;
            }

            const photo = photoState.capturedPhotos[photoState.currentPhotoIndex];

            try {
                showTiktokCountdown(5, async () => {
                    setTimeout(() => {
                        showUploadResultModal(true, ' Saving Draft...', 'Your photo draft is being saved');
                    }, 1000);

                    await savePhotoToFirebase(photo, 'draft');
                });
            } catch (error) {
                console.error('Error saving photo draft:', error);
                alert('Failed to save photo draft');
            }
        }

        async function publishPhotoPost() {
            if (!currentUser || photoState.capturedPhotos.length === 0) {
                alert('Please login and capture a photo first');
                return;
            }

            const caption = document.getElementById('photoCaption')?.value || '';
            const hashtags = document.querySelector('#screen7 input[placeholder*="hashtags"]')?.value || '';
            const tags = document.querySelector('#screen7 input[placeholder*="Tag people"]')?.value || '';
            const privacy = document.querySelector('#screen7 select')?.value || 'Everyone';
            const photo = photoState.capturedPhotos[photoState.currentPhotoIndex];

            try {
                showTiktokCountdown(5, async () => {
                    setTimeout(() => {
                        showUploadResultModal(true, ' Publishing Photo...', 'Uploading to Cloudinary...');
                    }, 1000);

                    // Upload to Cloudinary first, then save to Firebase
                    await uploadPhotoToCloudinaryAndFirebase(photo, 'post', {
                        caption: caption,
                        hashtags: hashtags,
                        tags: tags,
                        privacy: privacy,
                        sound: photoState.selectedSound
                    });

                    // Reset will happen in savePhotoUrlToFirebase callback
                });
            } catch (error) {
                console.error('Error publishing photo:', error);
                showUploadResultModal(false, ' Publish Failed', error.message);
            }
        }

        async function postPhotoStory() {
            if (!currentUser || photoState.capturedPhotos.length === 0) {
                alert('Please login and capture a photo first');
                return;
            }

            const caption = document.getElementById('photoCaption')?.value || '';
            const photo = photoState.capturedPhotos[photoState.currentPhotoIndex];

            try {
                showTiktokCountdown(5, async () => {
                    setTimeout(() => {
                        showUploadResultModal(true, ' Posting Story...', 'Uploading to Cloudinary...');
                    }, 1000);

                    // Upload to Cloudinary first, then save to Firebase
                    await uploadPhotoToCloudinaryAndFirebase(photo, 'story', {
                        caption: caption,
                        sound: photoState.selectedSound
                    });
                });
            } catch (error) {
                console.error('Error posting photo story:', error);
                showUploadResultModal(false, ' Story Failed', error.message);
            }
        }

        async function saveDraftPhoto() {
            console.log(' Draft button clicked');
            console.log('Current user:', currentUser?.uid);
            console.log('Photos captured:', photoState.capturedPhotos.length);

            if (!currentUser) {
                console.error(' No user logged in');
                alert('Please login first');
                return;
            }

            if (photoState.capturedPhotos.length === 0) {
                console.error(' No photos captured');
                alert('Please capture a photo first');
                return;
            }

            const caption = document.getElementById('photoCaption')?.value || '';
            const hashtags = document.querySelector('#screen7 input[placeholder*="hashtags"]')?.value || '';
            const tags = document.querySelector('#screen7 input[placeholder*="Tag people"]')?.value || '';
            const privacy = document.querySelector('#screen7 select')?.value || 'Everyone';
            const photo = photoState.capturedPhotos[photoState.currentPhotoIndex];

            console.log(' Saving draft with data:', { caption, hashtags, tags, privacy });

            try {
                showTiktokCountdown(5, async () => {
                    setTimeout(() => {
                        showUploadResultModal(true, ' Saving Draft...', 'Processing your photo...');
                    }, 1000);

                    // For drafts, save all metadata with Cloudinary upload
                    console.log(' Starting Cloudinary & Firebase upload...');
                    await uploadPhotoToCloudinaryAndFirebase(photo, 'draft', {
                        caption: caption,
                        hashtags: hashtags,
                        tags: tags,
                        privacy: privacy,
                        sound: photoState.selectedSound
                    });
                    console.log(' Upload complete');

                    // Reset will happen in savePhotoUrlToFirebase callback
                });
            } catch (error) {
                console.error(' Error saving draft:', error);
                showUploadResultModal(false, ' Draft Failed', error.message);
            }
        }

        // ============================================================================
        // CLOUDINARY + FIREBASE UPLOAD PIPELINE
        // ============================================================================

        async function uploadPhotoToCloudinaryAndFirebase(photo, type, metadata = {}) {
            try {
                // STEP 0: Log all saved edits
                console.log(' Edits Summary:');
                console.log('   Cropped:', photo.hasEdits ? 'Yes' : 'No');
                console.log('   Effect:', photo.effect || 'None');
                console.log('   Text Overlay:', photoState.photoSettings.textOverlay ? 'Yes' : 'No');
                console.log('   Sound:', metadata.sound ? 'Yes' : 'No');
                console.log('   Caption:', metadata.caption ? 'Yes' : 'No');

                // STEP 1: Get the photo blob (use edited version if available)
                console.log(' Step 1: Preparing photo for upload...');

                // Use edited URL (cropped version) if available
                const photoUrl = photo.editedUrl || photo.url;
                console.log(' Using photo URL:', photo.editedUrl ? ' Edited (Cropped)' : ' Original');

                const photoBlob = await (await fetch(photoUrl)).blob();
                console.log(` Photo size: ${(photoBlob.size / 1024).toFixed(2)} KB`);

                // STEP 2: Upload to Cloudinary
                console.log(' Step 2: Uploading to Cloudinary...');
                const cloudinaryUrl = await uploadPhotoToCloudinary(photoBlob, type);

                // STEP 3: Save all metadata to Firebase
                console.log(' Step 3: Saving to Firebase with all edits...');

                // Add edit info to metadata
                const fullMetadata = {
                    ...metadata,
                    edits: {
                        cropped: photo.hasEdits || false,
                        effect: photo.effect || 'none',
                        textOverlay: photoState.photoSettings.textOverlay || null,
                        resolution: photo.resolution || 'unknown'
                    },
                    timestamp: Date.now()
                };

                await savePhotoUrlToFirebase(cloudinaryUrl, type, fullMetadata, photo.settings);

                // STEP 4: Success!
                console.log(' Photo upload complete with all edits!');
                console.log(' Your edited photo has been saved successfully');

            } catch (error) {
                console.error(' Upload pipeline error:', error);
                throw new Error(`Upload failed: ${error.message}`);
            }
        }

        async function uploadPhotoToCloudinary(photoBlob, type) {
            return new Promise((resolve, reject) => {
                const formData = new FormData();
                formData.append('file', photoBlob);
                formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
                formData.append('tags', `photo,${type},${currentUser.uid}`);
                formData.append('folder', `photos/${type}`);

                const xhr = new XMLHttpRequest();

                // Timeout after 60 seconds
                const timeoutId = setTimeout(() => {
                    xhr.abort();
                    reject(new Error('Upload timeout - took too long'));
                }, 60000);

                // Track progress
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percentComplete = (e.loaded / e.total) * 100;
                        console.log(` Cloudinary upload: ${Math.round(percentComplete)}%`);

                        // Update modal with progress
                        const resultMessage = document.getElementById('uploadResultMessage');
                        if (resultMessage) {
                            resultMessage.textContent = `Uploading... ${Math.round(percentComplete)}%`;
                        }
                    }
                });

                xhr.addEventListener('load', () => {
                    clearTimeout(timeoutId);

                    if (xhr.status === 200) {
                        try {
                            const data = JSON.parse(xhr.responseText);
                            console.log(' Cloudinary upload successful:', data.secure_url);
                            resolve(data.secure_url);
                        } catch (parseError) {
                            console.error(' JSON parse error:', parseError);
                            reject(new Error('Invalid response from Cloudinary'));
                        }
                    } else {
                        console.error(` Cloudinary upload failed: ${xhr.status}`, xhr.responseText);
                        reject(new Error(`Cloudinary error: ${xhr.status}`));
                    }
                });

                xhr.addEventListener('error', () => {
                    clearTimeout(timeoutId);
                    console.error(' Network error during Cloudinary upload');
                    reject(new Error('Network error - check your connection'));
                });

                xhr.addEventListener('abort', () => {
                    clearTimeout(timeoutId);
                    console.error(' Cloudinary upload aborted');
                    reject(new Error('Upload was cancelled'));
                });

                console.log(' Starting Cloudinary upload');
                xhr.open('POST', CLOUDINARY_API_URL, true);
                xhr.send(formData);
            });
        }

        async function savePhotoUrlToFirebase(cloudinaryUrl, type, metadata = {}, settings = {}) {
            try {
                const today = getTodayDate();
                const docId = generateDocId();
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                const userData = userDoc.data() || {};

                // Save metadata to database with Cloudinary URL and all user data
                const firebaseData = {
                    uid: currentUser.uid,
                    userName: userData.name || '',
                    username: userData.username || '',
                    userProfilePic: userData.profilePicUrl || null,
                    imageUrl: cloudinaryUrl,  // Cloudinary URL
                    caption: metadata.caption || '',
                    hashtags: metadata.hashtags || '',
                    tags: metadata.tags || '',
                    privacy: metadata.privacy || 'Everyone',
                    sound: metadata.sound ? {
                        title: metadata.sound.title,
                        artist: metadata.sound.artist || metadata.sound.author,
                        url: metadata.sound.url || metadata.sound.audioUrl
                    } : null,
                    timestamp: Date.now(),
                    type: type,
                    settings: settings,
                    status: type === 'draft' ? 'draft' : 'posted',
                    views: 0,
                    likes: 0,
                    comments: 0,
                    cloudinary: true  // Flag to indicate this is from Cloudinary
                };

                // Save to Firestore
                const docRef = await db.collection('photos').add(firebaseData);

                console.log(' Photo metadata saved to Firebase:', docRef.id);

                // Update modal and close
                setTimeout(() => {
                    const resultMessage = document.getElementById('uploadResultMessage');
                    if (resultMessage) {
                        resultMessage.textContent = ' Photo posted successfully!';
                        resultMessage.className = 'upload-result-message success';
                    }
                }, 500);

                // Auto-close after 3 seconds and reset UI
                setTimeout(() => {
                    // Reset all form inputs
                    document.getElementById('photoCaption').value = '';
                    document.querySelectorAll('#screen7 input[placeholder*="hashtags"], #screen7 input[placeholder*="Tag people"]').forEach(input => {
                        input.value = '';
                    });

                    // Reset sound selection
                    photoState.selectedSound = null;

                    // Reset photo mode
                    resetPhotoMode();

                    // Close modal and return to screen 1
                    closeUploadResultModal();
                    showScreen('screen1');

                    // Switch to video mode
                    recordingState.selectedMode = 'video';
                    document.querySelectorAll('.rec-mode-tab').forEach((tab, index) => {
                        tab.classList.remove('active');
                        if (index === 0) tab.classList.add('active'); // First tab is video
                    });
                }, 3000);

            } catch (error) {
                console.error(' Firebase save error:', error);
                throw error;
            }
        }

        async function savePhotoToFirebase(photo, type, caption = '') {
            try {
                const today = getTodayDate();
                const docId = generateDocId();

                const photoRef = ref(database, `photos/${today}/${type}/${docId}`);

                // Convert image to blob and upload to storage
                const photoBlob = await (await fetch(photo.url)).blob();
                const storageRef = ref(storage, `photos/${currentUser.uid}/${today}/${docId}.jpg`);
                const uploadResult = await uploadBytes(storageRef, photoBlob);
                const downloadUrl = await getDownloadURL(uploadResult.ref);

                // Save metadata to database
                await set(photoRef, {
                    uid: currentUser.uid,
                    imageUrl: downloadUrl,
                    caption: caption,
                    timestamp: Date.now(),
                    type: type,
                    settings: photo.settings
                });

                console.log('Photo saved:', docId);
                setTimeout(() => {
                    closeUploadResultModal();
                    resetPhotoMode();
                    showScreen('screen1');
                }, 3000);
            } catch (error) {
                console.error('Firebase error:', error);
                throw error;
            }
        }

        // Stop photo mode and release camera
        function stopPhotoMode() {
            console.log('Stopping photo mode - releasing camera');

            // Stop all media tracks
            if (photoState.photoStream) {
                photoState.photoStream.getTracks().forEach(track => {
                    console.log('Stopping track:', track.kind);
                    track.stop();
                });
                photoState.photoStream = null;
            }

            // Remove video element
            const video = document.getElementById('photoPreviewVideo');
            if (video) {
                video.srcObject = null;
                video.remove();
            }

            showToastRecording(' Camera released', 'info', '');
        }

        // Full reset - clears all photo data and stops camera
        function resetPhotoMode() {
            console.log('Resetting photo mode completely');

            photoState.capturedPhotos = [];
            photoState.currentPhotoIndex = 0;
            photoState.photoSettings = {
                flash: false,
                timer: 0,
                filter: 'none',
                grid: false,
                ratio: '1:1',
                effects: []
            };

            // Stop camera
            stopPhotoMode();
        }

        // Helper method
        // Complete filter mapping - ALL FILTERS
        photoState.getPhotoFilterString = function (filterName) {
            const filters = {
                'none': 'none',
                'bw': 'grayscale(100%)',
                'sepia': 'sepia(100%)',
                'vintage': 'sepia(50%) contrast(0.9) brightness(0.9)',
                'vivid': 'saturate(1.5) contrast(1.1)',
                'warm': 'brightness(1.1) saturate(1.3) hue-rotate(10deg)',
                'cool': 'hue-rotate(-20deg) saturate(1.2) brightness(0.95)'
            };
            const result = filters[filterName] || 'none';
            console.log(' Filter mapping:', filterName, '', result);
            return result;
        };

        function goToPhotoPostSettings() {
            console.log(' Capturing edited photo...');

            // Capture the edited photo from camera-preview (screen 6)
            const screen6 = document.getElementById('screen6');
            const cameraPreview = screen6?.querySelector('.camera-preview');

            if (cameraPreview) {
                // Convert camera preview to canvas
                html2canvas(cameraPreview, {
                    allowTaint: true,
                    useCORS: true,
                    backgroundColor: null
                }).then(canvas => {
                    // Save the edited version
                    canvas.toBlob((blob) => {
                        const editedUrl = URL.createObjectURL(blob);
                        const currentPhoto = photoState.capturedPhotos[photoState.currentPhotoIndex];

                        if (currentPhoto) {
                            currentPhoto.editedUrl = editedUrl;
                            currentPhoto.hasEdits = true;
                            console.log(' Edited photo captured');
                        }

                        showScreen('screen7');
                        displayPhotoPreview();
                    });
                }).catch(err => {
                    console.warn(' Could not capture edits (html2canvas not available), using original', err);
                    showScreen('screen7');
                    displayPhotoPreview();
                });
            } else {
                showScreen('screen7');
                displayPhotoPreview();
            }
        }

        function displayPhotoPreview() {
            if (photoState.capturedPhotos.length === 0) {
                console.warn('No photos captured');
                return;
            }

            const photo = photoState.capturedPhotos[photoState.currentPhotoIndex];

            // Display image (use edited version if available)
            const previewImg = document.getElementById('photoPostPreviewImage');
            if (previewImg) {
                previewImg.src = photo.editedUrl || photo.url;
                console.log(' Displaying photo:', photo.hasEdits ? 'with edits' : 'original');
            }

            // Display sound if selected
            displayPhotoPostSound();

            // Recreate text overlay if it exists
            if (photoState.photoSettings.textOverlay) {
                setTimeout(() => {
                    reapplyTextOverlay();
                }, 300);
            }

            // Reapply effects if they exist
            if (photoState.photoSettings.effect || photo.effect) {
                applyStoredEffect();
            }

            // Show what's being saved
            displayPhotoEditsInfo();
        }

        function displayPhotoEditsInfo() {
            const photo = photoState.capturedPhotos[photoState.currentPhotoIndex];
            if (!photo) return;

            const editsInfo = [];
            const editsContainer = document.getElementById('photoEditsListContainer');
            const editsSection = document.getElementById('photoPostEditsInfo');
            const editsDisplay = document.getElementById('photoEditsDisplayInfo');

            // Check for crop
            if (photo.hasEdits) {
                editsInfo.push({ icon: '', label: 'Cropped' });
            }

            // Check for effect
            if (photo.effect && photo.effect !== 'none') {
                const effectName = {
                    'blur': 'Blur',
                    'grayscale': 'B&W',
                    'sepia': 'Sepia',
                    'invert': 'Invert',
                    'brighten': 'Brighten',
                    'contrast': 'Contrast',
                    'saturate': 'Saturate'
                }[photo.effect];
                editsInfo.push({ icon: '', label: effectName });
            }

            // Check for text
            if (photoState.photoSettings.textOverlay) {
                editsInfo.push({ icon: '', label: 'Text Added' });
            }

            // Check for sound
            if (photoState.selectedSound) {
                editsInfo.push({ icon: '', label: photoState.selectedSound.title || 'Sound' });
            }

            // Update UI
            if (editsInfo.length > 0) {
                // Populate badges
                editsContainer.innerHTML = editsInfo.map(edit =>
                    `<span class="photo-edit-badge">${edit.icon} ${edit.label}</span>`
                ).join('');

                // Show edits section
                editsSection.style.display = 'block';

                // Update header info
                editsDisplay.textContent = `${editsInfo.length} edit${editsInfo.length > 1 ? 's' : ''}`;

                console.log(' Photo Edits:', editsInfo.map(e => `${e.icon} ${e.label}`).join('  '));
                console.log(' All edits will be saved when you post!');
            } else {
                // Hide edits section
                editsSection.style.display = 'none';
                editsDisplay.textContent = 'No edits';
                console.log(' No edits applied - posting original photo');
            }
        }

        function reapplyTextOverlay() {
            const textData = photoState.photoSettings.textOverlay;
            if (!textData) return;

            const photoContainer = document.getElementById('photoPostPreviewContainer');
            if (!photoContainer) return;

            // Remove old overlay
            const oldOverlay = document.getElementById('photoTextOverlay');
            if (oldOverlay) oldOverlay.remove();

            // Recreate overlay
            const overlay = document.createElement('div');
            overlay.id = 'photoTextOverlay';
            overlay.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: ${textData.color};
                font-size: ${textData.size}px;
                font-weight: bold;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), -2px -2px 4px rgba(0,0,0,0.8);
                pointer-events: none;
                z-index: 100;
                white-space: nowrap;
                max-width: 90%;
                word-wrap: break-word;
                text-align: center;
            `;
            overlay.textContent = textData.text;

            // Ensure container is positioned
            if (photoContainer.style.position !== 'relative' && photoContainer.style.position !== 'absolute') {
                photoContainer.style.position = 'relative';
            }

            photoContainer.appendChild(overlay);
            console.log(' Text overlay reapplied:', textData.text);
        }

        function applyStoredEffect() {
            // Get effect from photo data, fallback to photoSettings
            const photo = photoState.capturedPhotos?.[photoState.currentPhotoIndex];
            const effect = photo?.effect || photoState.photoSettings.effect;
            const previewImg = document.getElementById('photoPostPreviewImage');

            if (!previewImg || !effect) return;

            // Apply effect filter
            switch (effect) {
                case 'none':
                    previewImg.style.filter = 'none';
                    break;
                case 'blur':
                    previewImg.style.filter = 'blur(8px)';
                    break;
                case 'grayscale':
                    previewImg.style.filter = 'grayscale(1)';
                    break;
                case 'sepia':
                    previewImg.style.filter = 'sepia(0.8)';
                    break;
                case 'invert':
                    previewImg.style.filter = 'invert(1)';
                    break;
                case 'brighten':
                    previewImg.style.filter = 'brightness(1.4)';
                    break;
                case 'contrast':
                    previewImg.style.filter = 'contrast(1.5)';
                    break;
                case 'saturate':
                    previewImg.style.filter = 'saturate(2)';
                    break;
            }

            console.log(' Effect reapplied on screen7:', effect);
        }

        function displayPhotoPostSound() {
            const soundDisplay = document.getElementById('photoPostSoundDisplay');
            if (!soundDisplay) return;

            if (photoState.selectedSound) {
                console.log(' Photo post has sound:', photoState.selectedSound.title);

                // Show sound display
                soundDisplay.style.display = 'block';

                // Update sound info
                const titleEl = document.getElementById('photoPostSoundTitle');
                const artistEl = document.getElementById('photoPostSoundArtist');

                if (titleEl) titleEl.textContent = photoState.selectedSound.title || 'Untitled';
                if (artistEl) artistEl.textContent = photoState.selectedSound.artist || photoState.selectedSound.author || 'Unknown';
            } else {
                console.log(' No sound selected for this photo post');
                soundDisplay.style.display = 'none';
            }
        }

        function removePhotoPostSound() {
            photoState.selectedSound = null;
            displayPhotoPostSound();
            showToastRecording('Sound removed', 'success', '');
        }

        // LEGACY: Display effects/settings
        function displayPhotoEffectsInfo() {
            const effectsInfo = document.getElementById('photoEffectsInfo');
            if (effectsInfo) {
                const photo = photoState.capturedPhotos[photoState.currentPhotoIndex];
                if (photo && photo.settings) {
                    const effects = [];
                    if (photo.settings.flash) effects.push(`Flash: ${photo.settings.flash}`);
                    if (photo.settings.timer > 0) effects.push(`Timer: ${photo.settings.timer}s`);
                    if (photo.settings.filter && photo.settings.filter !== 'none') effects.push(`Filter: ${photo.settings.filter}`);
                    if (photo.settings.grid) effects.push('Grid');

                    effectsInfo.textContent = effects.length > 0 ? effects.join(', ') : 'None';
                }
            }
        }

        // ============================================================================
        // TEXT MODE
        // ============================================================================

        function changeTextBg(element) {
            const bg = window.getComputedStyle(element).background;
            recordingState.textBgGradient = bg;

            // Update active color
            document.querySelectorAll('.rec-color-option').forEach(el => {
                el.classList.remove('active');
            });
            element.classList.add('active');

            const textCanvas = document.getElementById('textEditorBg');
            if (textCanvas) {
                textCanvas.style.background = bg;
            }
        }

        function changeTextAlign(align) {
            recordingState.textAlign = align;

            // Update active button
            document.querySelectorAll('.rec-text-tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.closest('.rec-text-tool-btn').classList.add('active');

            const textInput = document.getElementById('textInput');
            if (textInput) {
                textInput.style.textAlign = align;
            }
        }

        function toggleBold() {
            recordingState.isBold = !recordingState.isBold;
            event.target.closest('.rec-text-tool-btn').classList.toggle('active');

            const textInput = document.getElementById('textInput');
            if (textInput) {
                textInput.style.fontWeight = recordingState.isBold ? 'bold' : 'normal';
            }
        }

        function changeTextColor() {
            const color = prompt('Enter text color (hex or name):', recordingState.textColor);
            if (color) {
                recordingState.textColor = color;
                const textInput = document.getElementById('textInput');
                if (textInput) {
                    textInput.style.color = color;
                }
                showToastRecording('Text color changed', 'success', '');
            }
        }

        function goToTextPostSettings() {
            const textInput = document.getElementById('textInput');
            const textPreview = document.getElementById('textPreview');

            if (textPreview && textInput) {
                textPreview.innerHTML = `<span>${textInput.value || 'Your Text'}</span>`;
            }

            showScreen('screen9');
        }

        // ============================================================================
        // CAPTION COUNTERS
        // ============================================================================

        function updateCaptionCounter() {
            const captionInput = document.getElementById('recCaption');
            const counter = document.getElementById('captionCounter');

            if (captionInput && counter) {
                const length = captionInput.value.length;
                counter.textContent = `${length}/300`;
            }
        }

        function updatePhotoCaptionCounter() {
            const captionInput = document.getElementById('photoCaption');
            const counter = document.getElementById('photoCaptionCounter');

            if (captionInput && counter) {
                const length = captionInput.value.length;
                counter.textContent = `${length}/300`;
            }
        }

        function updateTextPostCaptionCounter() {
            const captionInput = document.getElementById('textPostCaption');
            const counter = document.getElementById('textPostCaptionCounter');

            if (captionInput && counter) {
                const length = captionInput.value.length;
                counter.textContent = `${length}/300`;
            }
        }

        // ============================================================================
        // POST SETTINGS NAVIGATION
        // ============================================================================

        // ============================================================================
        // VIDEO PREVIEW CONTROLS (Screen 3 - Edit)
        // ============================================================================

        function initEditVideoControls() {
            const video = document.getElementById('editVideoPreview');
            const playBtn = document.getElementById('editVideoPausePlay');
            const centerPlayBtn = document.getElementById('videoCenterPlay');
            const progressSlider = document.getElementById('videoProgressSlider');
            const progressFill = document.getElementById('videoProgressFill');
            const currentTimeEl = document.getElementById('videoCurrentTime');
            const durationEl = document.getElementById('videoDuration');

            if (!video || !playBtn || !progressSlider) return;

            console.log(' Initializing video controls...');
            console.log('Video duration:', video.duration);
            console.log('Video src:', video.src);

            // Helper to set duration
            const updateDuration = () => {
                if (video.duration && !isNaN(video.duration)) {
                    durationEl.textContent = formatTime(video.duration);
                    progressSlider.max = Math.floor(video.duration);
                    console.log(' Video duration updated:', formatTime(video.duration));
                }
            };

            // Update duration when metadata loads
            video.addEventListener('loadedmetadata', updateDuration);

            // If metadata is already loaded, update immediately
            if (video.duration && !isNaN(video.duration)) {
                updateDuration();
            }

            // Update progress bar and time display
            video.addEventListener('timeupdate', function () {
                if (!isNaN(video.duration) && video.duration > 0) {
                    const percent = (video.currentTime / video.duration) * 100;
                    progressFill.style.width = percent + '%';
                    currentTimeEl.textContent = formatTime(video.currentTime);
                    progressSlider.value = Math.floor(video.currentTime);
                }
            });

            // Update play/pause button icons (both top button and center)
            video.addEventListener('play', function () {
                playBtn.innerHTML = '<i class="fas fa-pause"></i>';
                if (centerPlayBtn) centerPlayBtn.classList.add('hidden');
            });

            video.addEventListener('pause', function () {
                playBtn.innerHTML = '<i class="fas fa-play"></i>';
                if (centerPlayBtn) centerPlayBtn.classList.remove('hidden');
            });

            video.addEventListener('ended', function () {
                playBtn.innerHTML = '<i class="fas fa-play"></i>';
                if (centerPlayBtn) centerPlayBtn.classList.remove('hidden');
            });

            // Handle progress slider drag
            progressSlider.addEventListener('input', function () {
                video.currentTime = parseFloat(progressSlider.value);
            });

            // Click on progress bar to seek
            const progressBar = document.querySelector('.video-progress-bar');
            if (progressBar) {
                const seekVideo = (e) => {
                    if (video.duration && !isNaN(video.duration)) {
                        const rect = progressBar.getBoundingClientRect();
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const percent = (clientX - rect.left) / rect.width;
                        video.currentTime = percent * video.duration;
                    }
                };

                progressBar.addEventListener('click', seekVideo);
                progressBar.addEventListener('touchstart', seekVideo, false);
                progressBar.addEventListener('touchmove', seekVideo, false);
            }

            // Mobile: Show controls on tap
            const videoWrapper = document.querySelector('.edit-video-wrapper');
            if (videoWrapper) {
                let controlsTimeout;
                const showControls = () => {
                    const controls = document.querySelector('.edit-video-controls');
                    if (controls) {
                        controls.classList.add('visible');
                        clearTimeout(controlsTimeout);
                        controlsTimeout = setTimeout(() => {
                            controls.classList.remove('visible');
                        }, 5000);
                    }
                };

                videoWrapper.addEventListener('touchstart', showControls, false);
                videoWrapper.addEventListener('click', showControls);
            }

            console.log(' Video controls initialized with touch support');
        }

        function toggleEditVideoPlayPause() {
            const video = document.getElementById('editVideoPreview');
            const audio = document.getElementById('editVideoSoundAudio');
            if (!video) {
                console.error(' Video element not found');
                return;
            }

            console.log(' Toggling play/pause. Current state:', video.paused ? 'paused' : 'playing');
            console.log(' Video duration:', video.duration, '| Current time:', video.currentTime);

            if (video.paused) {
                const promise = video.play();
                if (promise !== undefined) {
                    promise.catch(error => {
                        console.error(' Play error:', error);
                    });
                }

                // Play audio if sound is selected
                if (audio && recordingState.selectedSound) {
                    // Set audio to video position
                    audio.currentTime = video.currentTime;

                    // Set loop to match video duration
                    if (video.duration && video.duration > 0) {
                        audio.loop = false;
                    }

                    audio.play().catch(err => console.log('Audio auto-play prevented:', err));
                    console.log(' Sound playing with video');
                    console.log(' Audio duration:', audio.duration);
                }
            } else {
                video.pause();

                // Pause audio
                if (audio) {
                    audio.pause();
                    console.log(' Sound paused with video');
                }
            }
        }

        function toggleEditVideoFullscreen() {
            const wrapper = document.querySelector('.edit-video-wrapper');
            if (!document.fullscreenElement) {
                if (wrapper.requestFullscreen) {
                    wrapper.requestFullscreen();
                } else if (wrapper.webkitRequestFullscreen) {
                    wrapper.webkitRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }

        function goToPostSettings() {
            showScreen('screen4');
        }

        // ============================================================================
        // FIREBASE HELPER FUNCTIONS
        // ============================================================================

        function getTodayDate() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function generateDocId() {
            return `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

        // ============================================================================
        // PUBLISHING & SAVING
        // ============================================================================

        function saveDraftRecording() {
            const caption = document.getElementById('recCaption')?.value || '';
            const draft = {
                type: 'video',
                caption: caption,
                blob: recordingState.recordedBlob,
                timestamp: new Date().toISOString()
            };

            // Save to localStorage
            let drafts = JSON.parse(localStorage.getItem('recordingDrafts') || '[]');
            drafts.push(draft);
            localStorage.setItem('recordingDrafts', JSON.stringify(drafts));

            showToastRecording('Draft saved', 'success', '');
            closeRecordingUI();
        }

        function publishRecordingPost() {
            const caption = document.getElementById('recCaption')?.value || '';
            const post = {
                type: 'video',
                caption: caption,
                timestamp: new Date().toISOString(),
                privacy: document.querySelector('select').value
            };

            console.log('Publishing video post:', post);
            showToastRecording('Video posted successfully', 'success', '');
            closeRecordingUI();
        }

        function postStory() {
            showToastRecording('Added to your story', 'success', '');
            closeRecordingUI();
        }

        // Note: saveDraftPhoto, publishPhotoPost, and postPhotoStory are now located
        // in the PHOTO MODE section above with Firebase integration

        async function saveDraftText() {
            if (!currentUser) {
                alert(' Please login to save drafts');
                return;
            }

            const textInput = document.getElementById('textInput')?.value || '';
            const caption = document.getElementById('textPostCaption')?.value || '';

            if (!textInput.trim()) {
                alert(' Please enter some text');
                return;
            }

            try {
                // Show TikTok-style countdown
                showTiktokCountdown(5, async () => {
                    // Show success message 1 second after countdown
                    setTimeout(() => {
                        showUploadResultModal(true, ' Saving Draft...', 'Your text draft is being saved');
                    }, 1000);

                    // Save to Firebase
                    await saveDraftToFirebase(textInput, caption);
                });
            } catch (error) {
                console.error('Error saving draft:', error);
                hideTiktokCountdown();
                alert(' Failed to save draft: ' + error.message);
            }
        }

        async function saveDraftToFirebase(textInput, caption) {
            try {
                const todayDate = getTodayDate();
                const docId = generateDocId();
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                const userData = userDoc.data();

                const draftData = {
                    id: docId,
                    userId: currentUser.uid,
                    userName: userData?.name || 'Anonymous',
                    username: userData?.username || 'user',
                    userProfilePic: userData?.profilePicUrl || null,
                    textContent: textInput,
                    caption: caption,
                    backgroundGradient: recordingState.textBgGradient || 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    textAlign: recordingState.textAlign || 'center',
                    isBold: recordingState.isBold || false,
                    textColor: recordingState.textColor || '#fff',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    timestamp: Date.now(),
                    isDraft: true,
                    type: 'text'
                };

                await db.collection('textposts').doc(todayDate).collection('drafts').doc(docId).set(draftData);

                console.log(`Draft saved: /textposts/${todayDate}/drafts/${docId}`);

                // Update success modal
                document.getElementById('uploadResultTitle').textContent = ' Draft Saved!';
                document.getElementById('uploadResultMessage').textContent = 'Your draft was saved successfully!';

                // Reset form after 5 seconds
                setTimeout(() => {
                    closeUploadResultModal();
                    resetTextTab();
                    closeUploadPage();
                }, 5000);

            } catch (error) {
                console.error('Upload error:', error);
                showUploadResultModal(false, ' Save Failed', error.message);
            }
        }

        async function publishTextPost() {
            if (!currentUser) {
                alert(' Please login to post');
                return;
            }

            const textInput = document.getElementById('textInput')?.value || '';
            const caption = document.getElementById('textPostCaption')?.value || '';
            const privacySelect = document.querySelector('select');
            const privacy = privacySelect ? privacySelect.value : 'Everyone';

            if (!textInput.trim()) {
                alert(' Please enter some text');
                return;
            }

            try {
                // Show TikTok-style countdown
                showTiktokCountdown(5, async () => {
                    // Show success message 1 second after countdown
                    setTimeout(() => {
                        showUploadResultModal(true, ' Posting...', 'Your text is being processed');
                    }, 1000);

                    // Save to Firebase
                    await saveTextPostToFirebase(textInput, caption, privacy);
                });
            } catch (error) {
                console.error('Error posting text:', error);
                hideTiktokCountdown();
                alert(' Failed to post: ' + error.message);
            }
        }

        async function saveTextPostToFirebase(textInput, caption, privacy) {
            try {
                const todayDate = getTodayDate();
                const docId = generateDocId();
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                const userData = userDoc.data();

                const postData = {
                    id: docId,
                    userId: currentUser.uid,
                    userName: userData?.name || 'Anonymous',
                    username: userData?.username || 'user',
                    userProfilePic: userData?.profilePicUrl || null,
                    textContent: textInput,
                    caption: caption,
                    privacy: privacy,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    timestamp: Date.now(),
                    type: 'text',
                    likes: 0,
                    comments: 0,
                    shares: 0,
                    backgroundGradient: recordingState.textBgGradient || 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    textAlign: recordingState.textAlign || 'center',
                    isBold: recordingState.isBold || false,
                    textColor: recordingState.textColor || '#fff'
                };

                await db.collection('textposts').doc(todayDate).collection('posts').doc(docId).set(postData);

                console.log(`Text post saved: /textposts/${todayDate}/posts/${docId}`);

                // Update success modal
                document.getElementById('uploadResultTitle').textContent = ' Text Posted!';
                document.getElementById('uploadResultMessage').textContent = 'Your text was posted successfully!';

                // Reset form after 5 seconds
                setTimeout(() => {
                    closeUploadResultModal();
                    resetTextTab();
                    closeUploadPage();
                }, 5000);

            } catch (error) {
                console.error('Upload error:', error);
                showUploadResultModal(false, ' Upload Failed', error.message);
            }
        }

        function resetTextTab() {
            document.getElementById('textInput').value = '';
            document.getElementById('textPostCaption').value = '';
        }

        async function postTextStory() {
            if (!currentUser) {
                alert(' Please login to post story');
                return;
            }

            const textInput = document.getElementById('textInput')?.value || '';

            if (!textInput.trim()) {
                alert(' Please enter some text');
                return;
            }

            try {
                // Show TikTok-style countdown
                showTiktokCountdown(5, async () => {
                    // Show success message 1 second after countdown
                    setTimeout(() => {
                        showUploadResultModal(true, ' Adding to Story...', 'Your story is being posted');
                    }, 1000);

                    // Save to Firebase
                    await saveTextStoryToFirebase(textInput);
                });
            } catch (error) {
                console.error('Error posting to story:', error);
                hideTiktokCountdown();
                alert(' Failed to post story: ' + error.message);
            }
        }

        async function saveTextStoryToFirebase(textInput) {
            try {
                const todayDate = getTodayDate();
                const docId = generateDocId();
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                const userData = userDoc.data();

                const storyData = {
                    id: docId,
                    userId: currentUser.uid,
                    userName: userData?.name || 'Anonymous',
                    username: userData?.username || 'user',
                    userProfilePic: userData?.profilePicUrl || null,
                    textContent: textInput,
                    backgroundGradient: recordingState.textBgGradient || 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    textAlign: recordingState.textAlign || 'center',
                    isBold: recordingState.isBold || false,
                    textColor: recordingState.textColor || '#fff',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    timestamp: Date.now(),
                    expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
                    type: 'text',
                    views: 0
                };

                await db.collection('stories').doc(todayDate).collection('posts').doc(docId).set(storyData);

                console.log(`Story posted: /stories/${todayDate}/posts/${docId}`);

                // Update success modal
                document.getElementById('uploadResultTitle').textContent = ' Story Posted!';
                document.getElementById('uploadResultMessage').textContent = 'Your story will expire in 24 hours!';

                // Reset form after 5 seconds
                setTimeout(() => {
                    closeUploadResultModal();
                    resetTextTab();
                    closeUploadPage();
                }, 5000);

            } catch (error) {
                console.error('Story error:', error);
                showUploadResultModal(false, ' Story Failed', error.message);
            }
        }

        // ============================================================================
        // POPUP MANAGEMENT
        // ============================================================================

        function closeRecPopup(popupId) {
            const popup = document.getElementById(popupId);
            if (popup) {
                popup.style.display = 'none';
            }
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        document.addEventListener('DOMContentLoaded', () => {
            // Set initial styles
            const textCanvas = document.getElementById('textEditorBg');
            if (textCanvas) {
                textCanvas.style.background = recordingState.textBgGradient;
            }

            const textInput = document.getElementById('textInput');
            if (textInput) {
                textInput.style.textAlign = 'center';
            }

            // Add event listeners to menu items for demo
            document.querySelectorAll('.rec-menu-item').forEach(item => {
                item.addEventListener('click', function () {
                    showToastRecording(`${this.textContent} selected`, 'info', '');
                });
            });
        });

        function openRecordingUI() {
            const overlay = document.getElementById('recordingUIOverlay');
            overlay.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            // Show screen 1 and initialize video camera
            showScreen('screen1');
        }

        function closeRecordingUI() {
            const overlay = document.getElementById('recordingUIOverlay');
            overlay.classList.remove('active');
            overlay.style.display = 'none';
            document.body.style.overflow = '';

            // Stop all video/photo cameras when closing
            stopVideoCamera();
            stopPhotoMode();

            // Reset state
            recordingUIState = {
                currentScreen: 1,
                isRecording: false,
                recordingTime: 0,
                caption: '',
                videoBlob: null
            };

            console.log(' Recording UI closed - Camera streams stopped');
        }
        // ============================================================================
        // SOUND LIBRARY FUNCTIONALITY
        // ============================================================================

        const soundLibraryState = {
            currentTab: 'favourite',
            selectedSound: null,
            isPlaying: false,
            currentAudio: null,
            bannerInterval: null,
            currentBannerIndex: 0,
            voiceRecorder: null,
            voiceRecordingBlob: null,
            voiceRecordingTime: 0,
            voiceTimerInterval: null,
            searchResults: {},
            currentSearchQuery: '',
            filters: {
                genre: '',
                country: '',
                year: ''
            },
            allSounds: {
                favourite: [],
                yourMusic: [],
                poseMusic: []
            }
        };

        // Banner Ads Data
        const bannerAds = [
            {
                type: 'image',
                url: 'https://images.unsplash.com/photo-1511379938547-c1f69419868d?w=800',
                title: ' Trending Music',
                subtitle: 'Discover the hottest tracks'
            },
            {
                type: 'video',
                url: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4',
                title: ' New Releases',
                subtitle: 'Fresh sounds daily'
            },
            {
                type: 'image',
                url: 'https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=800',
                title: ' Premium Collection',
                subtitle: 'Exclusive tracks for creators'
            },
            {
                type: 'image',
                url: 'https://images.unsplash.com/photo-1514320291840-2e0a9bf2a9ae?w=800',
                title: ' Editor\'s Pick',
                subtitle: 'Hand-picked sounds'
            }
        ];

        // ============================================================================
        // AFROBEAT MUSIC LIBRARY - Real Artists & Dynamic Loading
        // ============================================================================

        // Main Pose Music Library (loaded from Firebase)
        let poseMusicLibrary = [];

        // Music library state for rotation
        let musicLibraryState = {
            lastRefresh: 0,
            refreshInterval: 300000, // 5 minutes in milliseconds
            initialDelay: 10000, // 10 seconds before first rotation
            currentIndex: 0,
            allLoadedSongs: [],
            isLoading: false
        };

        // Hardcoded Fallback Songs (if Firebase is empty)
        const fallbackSongs = [
            {
                id: 'afro1',
                title: 'Essence',
                artist: 'Wizkid ft. Tems',
                duration: '2:55',
                uses: '45M',
                thumbnail: 'https://is1-ssl.mzstatic.com/image/thumb/Music116/v4/d6/2f/69/d62f69eb-fce9-72ac-e7c7-e1f47d14b1ed/source/400x400bb.jpg',
                audioUrl: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3',
                category: 'Trending',
                trending: true
            },
            {
                id: 'afro2',
                title: 'Ye',
                artist: 'Burna Boy',
                duration: '3:30',
                uses: '38M',
                thumbnail: 'https://is1-ssl.mzstatic.com/image/thumb/Music113/v4/8f/c3/e7/8fc3e7e9-c2ed-6cc9-b15b-fae7e2e2a77f/source/400x400bb.jpg',
                audioUrl: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3',
                category: 'Trending',
                trending: true
            },
            {
                id: 'afro3',
                title: 'Blinding Lights (Afrobeat Remix)',
                artist: 'The Weeknd ft. Wizkid',
                duration: '3:20',
                uses: '52M',
                thumbnail: 'https://is1-ssl.mzstatic.com/image/thumb/Music126/v4/cb/d8/5c/cbd85c4b-ba16-6b1b-c4f1-21ab5d8c86be/source/400x400bb.jpg',
                audioUrl: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3',
                category: 'Trending',
                trending: true
            },
            {
                id: 'afro4',
                title: 'Calm Down',
                artist: 'Rema & Selena Gomez',
                duration: '3:08',
                uses: '40M',
                thumbnail: 'https://is1-ssl.mzstatic.com/image/thumb/Music126/v4/d1/5e/0f/d15e0fc1-65b8-3f4a-83db-29b67db04f98/source/400x400bb.jpg',
                audioUrl: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3',
                category: 'Trending',
                trending: true
            },
            {
                id: 'afro5',
                title: 'Sunroof',
                artist: 'Nicky Youre ft. Afrobeat',
                duration: '2:50',
                uses: '35M',
                thumbnail: 'https://is1-ssl.mzstatic.com/image/thumb/Music116/v4/a2/e4/e0/a2e4e0e7-79ba-e52e-2c72-1f8c53f01f37/source/400x400bb.jpg',
                audioUrl: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3',
                category: 'Trending',
                trending: true
            },
            {
                id: 'afro6',
                title: 'Flowers',
                artist: 'Miley Cyrus (Afrobeat Version)',
                duration: '3:18',
                uses: '48M',
                thumbnail: 'https://is1-ssl.mzstatic.com/image/thumb/Music116/v4/a6/21/3a/a6213a94-f825-fa06-b97e-5b4e3289c4d9/source/400x400bb.jpg',
                audioUrl: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3',
                category: 'Trending',
                trending: true
            },
            {
                id: 'afro7',
                title: 'Terminator',
                artist: 'Zinoleisky',
                duration: '3:25',
                uses: '28M',
                thumbnail: 'https://is1-ssl.mzstatic.com/image/thumb/Music116/v4/c9/f1/96/c9f196d2-6da1-c89e-80d4-8e3e7b5e0d2a/source/400x400bb.jpg',
                audioUrl: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-7.mp3',
                category: 'Trending',
                trending: true
            },
            {
                id: 'afro8',
                title: 'Unavailable',
                artist: 'Davido ft. Musa Keys',
                duration: '3:42',
                uses: '42M',
                thumbnail: 'https://is1-ssl.mzstatic.com/image/thumb/Music126/v4/4d/f8/f4/4df8f4c9-f1e0-6c2a-83db-1f5e8c9d3e2f/source/400x400bb.jpg',
                audioUrl: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-8.mp3',
                category: 'Trending',
                trending: true
            },
            {
                id: 'afro9',
                title: 'Aseju',
                artist: 'Asake',
                duration: '3:15',
                uses: '32M',
                thumbnail: 'https://is1-ssl.mzstatic.com/image/thumb/Music126/v4/9f/2d/c3/9f2dc3e5-6d9e-8f4a-92b8-3c4f5e6d7a8b/source/400x400bb.jpg',
                audioUrl: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-9.mp3',
                category: 'Trending',
                trending: true
            },
            {
                id: 'afro10',
                title: 'Ye Her',
                artist: 'Olamide',
                duration: '2:58',
                uses: '26M',
                thumbnail: 'https://is1-ssl.mzstatic.com/image/thumb/Music116/v4/7b/8c/9d/7b8c9d4e-5f6a-7b8c-9d0e-1f2a3b4c5d6e/source/400x400bb.jpg',
                audioUrl: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3',
                category: 'Trending',
                trending: true
            }
        ];

        // Load Pose Music from Firebase
        async function loadPoseMusicFromFirebase() {
            try {
                console.log(' Loading Pose Music from Firebase...');
                musicLibraryState.isLoading = true;

                if (!currentUser) {
                    console.warn(' User not authenticated, using fallback');
                    musicLibraryState.allLoadedSongs = fallbackSongs;
                    rotatePoseMusicLibrary();
                    musicLibraryState.isLoading = false;
                    return;
                }

                let allSongs = [];

                // Query NEW structure (songs_by_date)
                const newSnapshot = await db.collection('users')
                    .doc(currentUser.uid)
                    .collection('songs_by_date')
                    .orderBy('date', 'desc')
                    .limit(100)
                    .get();

                newSnapshot.forEach(dateDoc => {
                    const dateData = dateDoc.data();
                    if (dateData.songs && Array.isArray(dateData.songs)) {
                        dateData.songs.forEach(song => {
                            allSongs.push({
                                id: song.id || `song_${allSongs.length}`,
                                title: song.title || 'Unknown',
                                artist: song.artist || 'Unknown Artist',
                                duration: song.duration || '0:00',
                                uses: `${song.plays || 0} plays`,
                                thumbnail: song.imageUrl || 'https://via.placeholder.com/200',
                                audioUrl: song.audioUrl,
                                category: song.genre || 'Music',
                                trending: (song.plays || 0) > 5,
                                country: song.country,
                                genre: song.genre
                            });
                        });
                    }
                });

                // Query LEGACY structure (songs) for backwards compatibility
                const oldSnapshot = await db.collection('users')
                    .doc(currentUser.uid)
                    .collection('songs')
                    .limit(50)
                    .get();

                oldSnapshot.forEach(doc => {
                    const song = doc.data();
                    allSongs.push({
                        id: song.id || doc.id,
                        title: song.title || 'Unknown',
                        artist: song.artist || 'Unknown Artist',
                        duration: song.duration || '0:00',
                        uses: `${song.plays || 0} plays`,
                        thumbnail: song.imageUrl || song.thumbnail || 'https://via.placeholder.com/200',
                        audioUrl: song.audioUrl,
                        category: song.genre || 'Music',
                        trending: (song.plays || 0) > 5,
                        isLegacy: true
                    });
                });

                if (allSongs.length === 0) {
                    console.warn(' No songs found in Firebase, using fallback');
                    musicLibraryState.allLoadedSongs = fallbackSongs;
                } else {
                    console.log(` Loaded ${allSongs.length} songs from Firebase`);
                    allSongs.sort((a, b) => b.trending - a.trending);
                    musicLibraryState.allLoadedSongs = allSongs;
                }

                rotatePoseMusicLibrary();
                musicLibraryState.lastRefresh = Date.now();
                musicLibraryState.isLoading = false;

                console.log(' Music library state:', {
                    totalSongs: musicLibraryState.allLoadedSongs.length,
                    currentBatch: poseMusicLibrary.length
                });

            } catch (error) {
                console.error(' Error loading Firebase music:', error);
                musicLibraryState.allLoadedSongs = fallbackSongs;
                rotatePoseMusicLibrary();
                musicLibraryState.isLoading = false;
            }
        }

        // Search Firebase Music Library
        async function searchFirebaseMusicLibrary(searchTerm = null, genre = null, country = null) {
            try {
                if (!currentUser) {
                    showToastRecording('Sign in to search music', 'error', '');
                    return;
                }

                console.log(' Searching Firebase music:', { searchTerm, genre, country });
                musicLibraryState.isLoading = true;

                let searchResults = [];

                // Query from NEW structure
                const newSnapshot = await db.collection('users')
                    .doc(currentUser.uid)
                    .collection('songs_by_date')
                    .orderBy('date', 'desc')
                    .get();

                newSnapshot.forEach(dateDoc => {
                    const dateData = dateDoc.data();
                    if (dateData.songs && Array.isArray(dateData.songs)) {
                        dateData.songs.forEach(song => {
                            let matches = true;

                            if (searchTerm) {
                                const lowerSearch = searchTerm.toLowerCase();
                                const titleMatch = (song.title || '').toLowerCase().includes(lowerSearch);
                                const artistMatch = (song.artist || '').toLowerCase().includes(lowerSearch);
                                matches = matches && (titleMatch || artistMatch);
                            }

                            if (genre && song.genre !== genre) {
                                matches = false;
                            }

                            if (country && song.country !== country) {
                                matches = false;
                            }

                            if (matches) {
                                searchResults.push({
                                    id: song.id || `song_${searchResults.length}`,
                                    title: song.title || 'Unknown',
                                    artist: song.artist || 'Unknown Artist',
                                    duration: song.duration || '0:00',
                                    uses: `${song.plays || 0} plays`,
                                    thumbnail: song.imageUrl || 'https://via.placeholder.com/200',
                                    audioUrl: song.audioUrl,
                                    category: song.genre || 'Music',
                                    trending: (song.plays || 0) > 5,
                                    country: song.country,
                                    genre: song.genre
                                });
                            }
                        });
                    }
                });

                if (searchResults.length === 0) {
                    console.warn(' No matching songs found');
                    showToastRecording('No songs found', 'warning', '');
                    musicLibraryState.isLoading = false;
                    return;
                }

                poseMusicLibrary = searchResults;
                musicLibraryState.searchResults = searchResults;
                musicLibraryState.isLoading = false;

                loadPoseMusicLibrary();
                showToastRecording(`Found ${searchResults.length} songs!`, 'success', '');
                console.log(` Displayed ${searchResults.length} search results`);

            } catch (error) {
                console.error(' Error searching music:', error);
                musicLibraryState.isLoading = false;
                showToastRecording('Search error', 'error', '');
            }
        }

        // Handle Song/Artist Name Search - Real-time
        function handleSongArtistSearch() {
            const searchInput = document.getElementById('iTunesSongArtistSearch').value.trim();

            if (searchInput.length < 2) {
                console.log(' Search input too short, showing default library');
                if (musicLibraryState.allLoadedSongs.length > 0) {
                    rotatePoseMusicLibrary();
                    loadPoseMusicLibrary();
                }
                return;
            }

            console.log(` Searching for song/artist: ${searchInput}`);
            searchFirebaseMusicLibrary(searchInput, null, null);
        }

        // Handle Genre Filter Change - Auto-search
        function handleGenreFilterChange() {
            const genre = document.getElementById('iTunesGenreFilter').value;
            const country = document.getElementById('iTunesCountryFilter').value;

            console.log(` Genre selected: ${genre || 'Any'}`);

            if (genre === '') {
                console.log(' No genre selected, using default library');
                if (musicLibraryState.allLoadedSongs.length > 0) {
                    rotatePoseMusicLibrary();
                    loadPoseMusicLibrary();
                }
                return;
            }

            searchFirebaseMusicLibrary(null, genre, country || null);
        }

        // Handle Country Filter Change - Auto-search
        function handleCountryFilterChange() {
            const genre = document.getElementById('iTunesGenreFilter').value;
            const country = document.getElementById('iTunesCountryFilter').value;

            console.log(` Country selected: ${country || 'Any'}`);

            if (country === '') {
                console.log(' No country selected, using default library');
                if (musicLibraryState.allLoadedSongs.length > 0) {
                    rotatePoseMusicLibrary();
                    loadPoseMusicLibrary();
                }
                return;
            }

            searchFirebaseMusicLibrary(null, genre || null, country);
        }

        // Rotate Pose Music Library every 20 minutes
        function rotatePoseMusicLibrary() {
            const songsPerBatch = 10;
            const startIndex = musicLibraryState.currentIndex % (musicLibraryState.allLoadedSongs.length - songsPerBatch + 1);

            poseMusicLibrary = musicLibraryState.allLoadedSongs.slice(startIndex, startIndex + songsPerBatch);

            // Mark some songs as trending
            poseMusicLibrary.forEach((song, index) => {
                song.trending = index < 3 || (Math.random() > 0.7);
            });

            musicLibraryState.currentIndex += 3; // Rotate offset
            console.log(` Music library rotated - showing songs ${startIndex} to ${startIndex + songsPerBatch}`);
        }

        // Schedule music rotation: 10 sec initial delay, then every 5 minutes
        function scheduleMusicsLibraryRotation() {
            console.log(` Music library rotation: ${musicLibraryState.initialDelay}ms initial delay, then every ${musicLibraryState.refreshInterval}ms (5 minutes)`);

            // First rotation after 10 seconds
            setTimeout(() => {
                console.log(' First music rotation after initial delay...');
                if (musicLibraryState.allLoadedSongs.length > 0) {
                    rotatePoseMusicLibrary();

                    // Reload if sound library is open
                    const container = document.getElementById('poseMusicSoundList');
                    if (container && container.innerHTML !== '') {
                        loadPoseMusicLibrary();
                        showToastRecording(' Music library refreshed!', 'success', '');
                        console.log(' Library reloaded with rotated songs');
                    }
                }

                // Then repeat every 5 minutes
                setInterval(() => {
                    console.log(' Rotating music library...');
                    if (musicLibraryState.allLoadedSongs.length > 0) {
                        rotatePoseMusicLibrary();

                        // Reload if sound library is open
                        const container = document.getElementById('poseMusicSoundList');
                        if (container && container.innerHTML !== '') {
                            loadPoseMusicLibrary();
                            showToastRecording(' Music library refreshed!', 'success', '');
                            console.log(' Library reloaded with rotated songs');
                        }
                    }
                }, musicLibraryState.refreshInterval);

            }, musicLibraryState.initialDelay);
        }

        // Open Sound Library
        async function openSoundLibrary() {
            try {
                const modal = document.getElementById('soundLibraryModal');
                if (!modal) {
                    console.error(' Sound library modal not found');
                    return;
                }

                modal.classList.add('active');
                document.body.style.overflow = 'hidden';

                // Initialize
                initializeBannerAds();

                // Load music from Firebase if not already loaded
                if (musicLibraryState.allLoadedSongs.length === 0) {
                    console.log(' Loading music library from Firebase...');
                    await loadPoseMusicFromFirebase();
                    scheduleMusicsLibraryRotation();
                } else {
                    console.log(' Using cached music library:', musicLibraryState.allLoadedSongs.length, 'songs');
                }

                loadPoseMusicLibrary();
                loadFavouriteSounds();
                loadYourMusic();

                console.log(' Sound library opened');
            } catch (error) {
                console.error(' Error opening sound library:', error);
                showToastRecording('Error opening sound library', 'error', '');
            }
        }

        // Close Sound Library
        function closeSoundLibrary() {
            const modal = document.getElementById('soundLibraryModal');
            modal.classList.remove('active');
            document.body.style.overflow = 'auto';

            // Stop any playing audio
            stopCurrentAudio();

            // Clear banner interval
            if (soundLibraryState.bannerInterval) {
                clearInterval(soundLibraryState.bannerInterval);
            }

            console.log(' Sound library closed');
        }

        // Initialize Banner Ads with Auto-Scroll
        function initializeBannerAds() {
            const slider = document.getElementById('bannerAdsSlider');
            const indicators = document.getElementById('bannerIndicators');

            // Clear existing
            slider.innerHTML = '';
            indicators.innerHTML = '';

            // Create banner items
            bannerAds.forEach((ad, index) => {
                const item = document.createElement('div');
                item.className = 'banner-ad-item';

                if (ad.type === 'image') {
                    item.innerHTML = `
                <img src="${ad.url}" alt="${ad.title}">
                <div class="banner-ad-overlay">
                    <div class="banner-ad-title">${ad.title}</div>
                    <div class="banner-ad-subtitle">${ad.subtitle}</div>
                </div>
            `;
                } else if (ad.type === 'video') {
                    item.innerHTML = `
                <video src="${ad.url}" autoplay muted loop></video>
                <div class="banner-ad-overlay">
                    <div class="banner-ad-title">${ad.title}</div>
                    <div class="banner-ad-subtitle">${ad.subtitle}</div>
                </div>
            `;
                }

                slider.appendChild(item);

                // Create indicator
                const indicator = document.createElement('div');
                indicator.className = `banner-indicator ${index === 0 ? 'active' : ''}`;
                indicator.onclick = () => goToBannerSlide(index);
                indicators.appendChild(indicator);
            });

            // Start auto-scroll
            startBannerAutoScroll();
        }

        // Auto-scroll banner ads
        function startBannerAutoScroll() {
            soundLibraryState.bannerInterval = setInterval(() => {
                const nextIndex = (soundLibraryState.currentBannerIndex + 1) % bannerAds.length;
                goToBannerSlide(nextIndex);
            }, 4000); // Change every 4 seconds
        }

        // Go to specific banner slide
        function goToBannerSlide(index) {
            const slider = document.getElementById('bannerAdsSlider');
            const indicators = document.querySelectorAll('.banner-indicator');

            soundLibraryState.currentBannerIndex = index;
            slider.style.transform = `translateX(-${index * 100}%)`;

            // Update indicators
            indicators.forEach((ind, i) => {
                ind.classList.toggle('active', i === index);
            });
        }

        // Switch Sound Tab
        function switchSoundTab(tabName) {
            soundLibraryState.currentTab = tabName;

            // Update tab buttons
            document.querySelectorAll('.sound-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.sound-tab-content').forEach(content => {
                content.classList.remove('active');
            });

            const tabMap = {
                'favourite': 'favouriteTab',
                'yourMusic': 'yourMusicTab',
                'poseMusic': 'poseMusicTab',
                'voiceOver': 'voiceOverTab'
            };

            document.getElementById(tabMap[tabName]).classList.add('active');

            console.log(' Switched to tab:', tabName);
        }

        // Load Pose Music Library
        function loadPoseMusicLibrary() {
            const container = document.getElementById('poseMusicSoundList');
            container.innerHTML = '';

            if (poseMusicLibrary.length === 0) {
                container.innerHTML = `
            <div class="sound-empty">
                <div class="sound-empty-icon"></div>
                <div class="sound-empty-title">No sounds available</div>
                <div class="sound-empty-text">Check back soon for new music!</div>
            </div>
        `;
                return;
            }

            soundLibraryState.allSounds.poseMusic = poseMusicLibrary;

            poseMusicLibrary.forEach(sound => {
                const item = createSoundItem(sound, 'poseMusic');
                container.appendChild(item);
            });
        }

        // Load Favourite Sounds
        async function loadFavouriteSounds() {
            const container = document.getElementById('favouriteSoundList');
            container.innerHTML = '<div class="sound-loading"><div class="sound-loading-spinner"></div><p>Loading favourites...</p></div>';

            try {
                if (!currentUser) {
                    container.innerHTML = `
                <div class="sound-empty">
                    <div class="sound-empty-icon"></div>
                    <div class="sound-empty-title">Login to save favourites</div>
                    <div class="sound-empty-text">Your favourite sounds will appear here</div>
                </div>
            `;
                    return;
                }

                // Load from Firestore
                const snapshot = await db.collection('users')
                    .doc(currentUser.uid)
                    .collection('favouriteSounds')
                    .orderBy('addedAt', 'desc')
                    .limit(50)
                    .get();

                container.innerHTML = '';

                if (snapshot.empty) {
                    container.innerHTML = `
                <div class="sound-empty">
                    <div class="sound-empty-icon"></div>
                    <div class="sound-empty-title">No favourites yet</div>
                    <div class="sound-empty-text">Add sounds to your favourites from Pose Music</div>
                </div>
            `;
                    return;
                }

                const sounds = [];
                snapshot.forEach(doc => {
                    sounds.push({ id: doc.id, ...doc.data() });
                });

                soundLibraryState.allSounds.favourite = sounds;

                sounds.forEach(sound => {
                    const item = createSoundItem(sound, 'favourite');
                    container.appendChild(item);
                });

            } catch (error) {
                console.error('Error loading favourites:', error);
                container.innerHTML = `
            <div class="sound-empty">
                <div class="sound-empty-icon"></div>
                <div class="sound-empty-title">Error loading favourites</div>
                <div class="sound-empty-text">${error.message}</div>
            </div>
        `;
            }
        }

        // Load Your Music
        async function loadYourMusic() {
            const container = document.getElementById('yourMusicSoundList');
            container.innerHTML = '<div class="sound-loading"><div class="sound-loading-spinner"></div><p>Loading your music...</p></div>';
            try {
                if (!currentUser) {
                    container.innerHTML = `
                <div class="sound-empty">
                    <div class="sound-empty-icon"></div>
                    <div class="sound-empty-title">Login to upload music</div>
                    <div class="sound-empty-text">Upload your own music tracks here</div>
                </div>
            `;
                    return;
                }

                // Load from Firestore
                const snapshot = await db.collection('users')
                    .doc(currentUser.uid)
                    .collection('uploadedMusic')
                    .orderBy('uploadedAt', 'desc')
                    .limit(50)
                    .get();

                container.innerHTML = '';

                if (snapshot.empty) {
                    container.innerHTML = `
                <div class="sound-empty">
                    <div class="sound-empty-icon"></div>
                    <div class="sound-empty-title">No music uploaded</div>
                    <div class="sound-empty-text">
                        <button class="modal-btn" onclick="uploadYourMusic()" style="margin-top: 20px;">
                             Upload Music
                        </button>
                    </div>
                </div>
            `;
                    return;
                }

                const sounds = [];
                snapshot.forEach(doc => {
                    sounds.push({ id: doc.id, ...doc.data() });
                });

                soundLibraryState.allSounds.yourMusic = sounds;

                sounds.forEach(sound => {
                    const item = createSoundItem(sound, 'yourMusic');
                    container.appendChild(item);
                });

            } catch (error) {
                console.error('Error loading your music:', error);
                container.innerHTML = `
            <div class="sound-empty">
                <div class="sound-empty-icon"></div>
                <div class="sound-empty-title">Error loading music</div>
                <div class="sound-empty-text">${error.message}</div>
            </div>
        `;
            }
        }

        // Create Sound Item with Trending Badge & Favorite
        function createSoundItem(sound, sourceTab) {
            const item = document.createElement('div');
            item.className = 'sound-item';
            item.dataset.soundId = sound.id;
            item.dataset.sourceTab = sourceTab;

            // Add trending badge if applicable
            const trendingBadge = sound.trending ? `
        <div class="trending-badge">
            <span class="trending-text"><i class="fas fa-fire"></i> Trending</span>
        </div>
        ` : '';

            // Favorite button
            const isFavorited = sound.isFavorited ? 'active' : '';
            const favoriteIcon = sound.isFavorited ? 'fas fa-heart' : 'far fa-heart';

            // Add extra actions for "yourMusic" tab
            const isYourMusic = sourceTab === 'yourMusic';
            const extraActions = isYourMusic ? `
                <button class="sound-action sound-delete-btn" data-sound-id="${sound.id}" title="Delete track" style="background: #dc2626;">
                    <i class="fas fa-trash"></i> Delete
                </button>
            ` : '';

            item.innerHTML = `
            <div class="sound-thumbnail">
            ${sound.thumbnail ? `<img src="${sound.thumbnail}" alt="${sound.title}">` : '<i class="fas fa-music"></i>'}
            <div class="sound-play-icon"><i class="fas fa-play"></i></div>
            ${trendingBadge}
            ${sound.previewNote ? `<div style="position: absolute; bottom: 4px; left: 4px; right: 4px; background: rgba(0,0,0,0.7); color: #fff; font-size: 10px; padding: 2px 4px; border-radius: 3px; text-align: center;">${sound.previewNote}</div>` : ''}
            </div>
            <div class="sound-info">
            <div class="sound-title">${sound.title}</div>
            <div class="sound-artist">${sound.artist || 'Unknown Artist'}</div>
            <div class="sound-meta">
                <span class="sound-duration" title="Full duration: ${sound.fullDuration || sound.duration}"><i class="fas fa-clock"></i> ${sound.duration || '0:00'}</span>
                ${sound.uses ? `<span class="sound-uses"><i class="fas fa-users"></i> ${sound.uses}</span>` : ''}
            </div>
            </div>
            <div class="sound-actions">
            <button class="sound-favorite-btn ${isFavorited}" onclick="toggleFavoriteSound('${sound.id}', '${sourceTab}', event)" title="Add to favorites">
                <i class="${favoriteIcon}"></i>
            </button>
            <button class="sound-action" onclick="selectSound('${sound.id}', '${sourceTab}', event)">
                <i class="fas fa-check"></i> Use
            </button>
            ${extraActions}
            </div>
            `;

            // Add play on click
            item.querySelector('.sound-thumbnail').onclick = (e) => {
                e.stopPropagation();
                toggleSoundPlay(sound);
            };

            // Add event listeners for your music buttons
            if (isYourMusic) {
                const deleteBtn = item.querySelector('.sound-delete-btn');

                if (deleteBtn) {
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteYourMusic(deleteBtn.dataset.soundId);
                    };
                }
            }

            return item;
        }

        // Toggle Sound Play
        function toggleSoundPlay(sound) {
            if (soundLibraryState.isPlaying && soundLibraryState.currentAudio?.src === sound.audioUrl) {
                // Pause current
                soundLibraryState.currentAudio.pause();
                soundLibraryState.isPlaying = false;
                document.querySelectorAll('.sound-item').forEach(item => {
                    item.classList.remove('playing');
                });
            } else {
                // Stop any current audio
                stopCurrentAudio();
                // Play new
                soundLibraryState.currentAudio = new Audio(sound.audioUrl);
                soundLibraryState.currentAudio.play();
                soundLibraryState.isPlaying = true;

                // Mark as playing
                const item = document.querySelector(`[data-sound-id="${sound.id}"]`);
                if (item) item.classList.add('playing');

                // Auto-remove playing state when ended
                soundLibraryState.currentAudio.onended = () => {
                    soundLibraryState.isPlaying = false;
                    item.classList.remove('playing');
                };
            }
        }

        // Stop Current Audio
        function stopCurrentAudio() {
            if (soundLibraryState.currentAudio) {
                soundLibraryState.currentAudio.pause();
                soundLibraryState.currentAudio.currentTime = 0;
                soundLibraryState.isPlaying = false;
            }
            document.querySelectorAll('.sound-item').forEach(item => {
                item.classList.remove('playing');
            });
        }

        // Toggle Favorite Sound
        async function toggleFavoriteSound(soundId, sourceTab, event) {
            event.stopPropagation();

            if (!currentUser) {
                showToastRecording('Please login to save favorites', 'error', '');
                return;
            }

            try {
                // Get sound from library
                const sound = soundLibraryState.allSounds[sourceTab]?.find(s => s.id === soundId);
                if (!sound) {
                    console.error('Sound not found:', soundId);
                    return;
                }

                const isFavorited = sound.isFavorited;
                const btn = event.target.closest('.sound-favorite-btn');

                if (isFavorited) {
                    // Remove from favorites
                    await db.collection('users').doc(currentUser.uid).collection('favouriteSounds').doc(soundId).delete();
                    sound.isFavorited = false;
                    btn.classList.remove('active');
                    btn.innerHTML = '<i class="far fa-heart"></i>';
                    showToastRecording('Removed from favorites', 'info', '');
                } else {
                    // Add to favorites
                    await db.collection('users').doc(currentUser.uid).collection('favouriteSounds').doc(soundId).set({
                        ...sound,
                        addedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    sound.isFavorited = true;
                    btn.classList.add('active');
                    btn.innerHTML = '<i class="fas fa-heart"></i>';
                    showToastRecording('Added to favorites ', 'success', '');

                    // Get recommendations based on this favorite
                    getRecommendedSongs(sound);
                }

                console.log(` Favorite toggled for: ${sound.title}`);

            } catch (error) {
                console.error('Error toggling favorite:', error);
                showToastRecording('Error saving favorite', 'error', '');
            }
        }

        // Get Recommended Songs Based on Favorite
        async function getRecommendedSongs(favoriteSound) {
            try {
                // Recommend based on same artist or category
                const artist = favoriteSound.artist;
                const category = favoriteSound.category || 'Afrobeat';

                // Search for more songs by same artist
                const response = await fetch(
                    `https://itunes.apple.com/search?term=${encodeURIComponent(artist)}&entity=song&limit=10`,
                    { mode: 'cors' }
                );

                const data = await response.json();

                if (data.results && data.results.length > 1) {
                    const recommended = data.results.slice(0, 5).map((song, index) => ({
                        id: `rec_${Date.now()}_${index}`,
                        title: song.trackName,
                        artist: song.artistName || artist,
                        duration: formatDuration(song.trackTimeMillis),
                        thumbnail: song.artworkUrl100,
                        audioUrl: song.previewUrl,
                        category: category,
                        isRecommended: true,
                        trending: false,
                        uses: '0M'
                    })).filter(s => s.audioUrl); // Only include songs with previews

                    if (recommended.length > 0) {
                        showToastRecording(` ${recommended.length} recommended songs added!`, 'success', '');
                        console.log(` Recommendations for ${artist}:`, recommended);
                    }
                }
            } catch (error) {
                console.warn('Could not fetch recommendations:', error.message);
            }
        }

        // Select Sound
        function selectSound(soundId, sourceTab, event) {
            event.stopPropagation();
            const sound = soundLibraryState.allSounds[sourceTab].find(s => s.id === soundId);
            if (!sound) return;

            soundLibraryState.selectedSound = sound;

            // Mark as selected in modal
            document.querySelectorAll('.sound-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.closest('.sound-item').classList.add('active');

            // Show success feedback
            showToastRecording(` "${sound.title}" selected`, 'success', '');

            console.log('Selected sound:', sound);

            // Check which screen is active
            const screen1 = document.getElementById('screen1');
            const screen3 = document.getElementById('screen3');
            const screen6 = document.getElementById('screen6');
            const screen7 = document.getElementById('screen7');

            const isScreen1Active = screen1 && screen1.classList.contains('active');
            const isScreen3Active = screen3 && screen3.style.display !== 'none';
            const isScreen6Active = screen6 && screen6.style.display !== 'none';
            const isScreen7Active = screen7 && screen7.style.display !== 'none';

            // Close modal
            setTimeout(() => {
                closeSoundLibrary();

                // Route to appropriate screen handler
                if (isScreen1Active) {
                    displaySelectedSoundOnScreen1(sound);
                } else if (isScreen3Active) {
                    displaySelectedSoundOnScreen3(sound);
                } else if (isScreen6Active) {
                    displaySelectedSoundOnScreen6(sound);
                } else if (isScreen7Active) {
                    displaySelectedSoundOnScreen6(sound);
                }
            }, 800);
        }


        // Preload and decode audio in background (so it's ready when recording starts)
        async function preloadAudioForRecording(sound) {
            if (!sound) return;

            try {
                const soundUrl = sound.audioUrl || sound.url || sound.preview_url || sound.filePath;
                console.log(' Preloading audio:', soundUrl);

                const audioResponse = await fetch(soundUrl);
                const audioBlob = await audioResponse.blob();

                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioContext.decodeAudioData(await audioBlob.arrayBuffer());

                // Store preloaded audio in recordingState
                recordingState.preloadedAudioBuffer = audioBuffer;
                recordingState.preloadedAudioContext = audioContext;

                console.log(' Audio preloaded and decoded:', audioBuffer.duration, 'seconds');
                return true;
            } catch (error) {
                console.warn(' Audio preload error:', error);
                return false;
            }
        }

        // Display Selected Sound on Screen 1 (Recording)
        function displaySelectedSoundOnScreen1(sound) {
            // Store sound in recordingState
            recordingState.selectedSound = {
                ...sound,
                url: sound.audioUrl || sound.url || sound.preview_url || sound.filePath
            };

            console.log(' Sound stored in recordingState:', recordingState.selectedSound);

            // Preload audio in background (non-blocking)
            preloadAudioForRecording(sound);

            // Update Screen 1 display
            const display = document.getElementById('recSoundDisplay');
            const thumbnail = document.getElementById('recSoundThumbnail');
            const title = document.getElementById('recSoundTitle');
            const artist = document.getElementById('recSoundArtist');

            if (display && thumbnail && title && artist) {
                // Update text info
                title.textContent = sound.title;
                artist.textContent = sound.artist || 'Unknown Artist';

                // Update thumbnail
                if (sound.thumbnail) {
                    thumbnail.innerHTML = `<img src="${sound.thumbnail}" alt="${sound.title}">`;
                } else {
                    thumbnail.innerHTML = '<i class="fas fa-music"></i>';
                }

                // Show display with animation
                display.style.display = 'block';
                display.style.animation = 'slideDown 0.4s ease-out';

                console.log(' Sound displayed on Screen 1');
            }
        }

        // Display Selected Sound on Screen 6 or Screen 7
        function displaySelectedSoundOnScreen6(sound) {
            // Store sound in photoState for download detection
            // Use the entire sound object plus the soundLibraryState reference
            photoState.selectedSound = {
                ...sound,
                url: sound.audioUrl || sound.url || sound.preview_url || sound.filePath
            };

            console.log(' Sound stored in photoState:', photoState.selectedSound);
            console.log(' Sound audioUrl:', sound.audioUrl);

            // Check which screen is active
            const screen6 = document.getElementById('screen6');
            const screen7 = document.getElementById('screen7');

            const isScreen6Active = screen6 && screen6.style.display !== 'none';
            const isScreen7Active = screen7 && screen7.style.display !== 'none';

            // If on Screen 6 (editing), update Screen 6 UI
            if (isScreen6Active) {
                const container = document.getElementById('selectedSoundContainer');
                const thumbnail = document.getElementById('soundDisplayThumbnail');
                const title = document.getElementById('soundDisplayTitle');
                const artist = document.getElementById('soundDisplayArtist');
                const playBtn = document.getElementById('soundPlayBtn');

                if (container && thumbnail && title && artist && playBtn) {
                    // Update display info
                    title.textContent = sound.title;
                    artist.textContent = sound.artist || 'Unknown Artist';

                    // Update thumbnail
                    if (sound.thumbnail) {
                        thumbnail.innerHTML = `<img src="${sound.thumbnail}" alt="${sound.title}">`;
                    } else {
                        thumbnail.innerHTML = '<i class="fas fa-music"></i>';
                    }

                    // Reset play button
                    playBtn.innerHTML = '<i class="fas fa-play"></i>';
                    playBtn.classList.remove('playing');

                    // Show container
                    container.classList.add('show');

                    console.log(' Sound displayed on Screen 6:', sound);
                }
            }

            // If on Screen 7 (posting), update Screen 7 UI
            if (isScreen7Active) {
                displayPhotoPostSound();
                console.log(' Sound displayed on Screen 7 (photo post settings):', sound);
            }
        }

        // Display & Play Sound on Screen 3 (Video Edit)
        function displaySelectedSoundOnScreen3(sound) {
            console.log(' Displaying sound on Screen 3:', sound.title);

            // Store sound in recordingState
            recordingState.selectedSound = {
                ...sound,
                url: sound.audioUrl || sound.url || sound.preview_url || sound.filePath
            };

            // Get audio element
            const audioElement = document.getElementById('editVideoSoundAudio');
            if (!audioElement) {
                console.error(' Audio element not found');
                return;
            }

            // Set audio source
            audioElement.src = recordingState.selectedSound.url;

            // Mute original video audio
            const videoElement = document.getElementById('editVideoPreview');
            if (videoElement) {
                recordingState.videoOriginalVolume = videoElement.volume;
                videoElement.muted = true;
                console.log(' Video audio muted');
            }

            // Display sound info in Screen 3
            displayScreen3SoundInfo(sound);

            // Initialize sync
            initializeAudioVideoSync();

            // Auto-play if video is playing
            if (videoElement && !videoElement.paused) {
                audioElement.currentTime = videoElement.currentTime;
                audioElement.play().catch(err => console.log('Audio auto-play prevented:', err));
                console.log(' Sound playback started');
            }
        }

        // Display Sound Info in Screen 3 UI
        function displayScreen3SoundInfo(sound) {
            let soundDisplay = document.getElementById('screen3SoundDisplay');

            // Create display if doesn't exist
            if (!soundDisplay) {
                const editControls = document.querySelector('#screen3 .rec-edit-controls');
                if (!editControls) return;

                soundDisplay = document.createElement('div');
                soundDisplay.id = 'screen3SoundDisplay';
                soundDisplay.className = 'screen3-sound-info';
                soundDisplay.style.cssText = `
                    background: rgba(255, 0, 80, 0.15);
                    border: 1px solid rgba(255, 0, 80, 0.3);
                    border-radius: 8px;
                    padding: 12px;
                    margin-bottom: 10px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    gap: 10px;
                `;
                editControls.insertBefore(soundDisplay, editControls.firstChild);
            }

            // Update content
            soundDisplay.innerHTML = `
                <div style="flex: 1; min-width: 0;">
                    <div style="color: #fff; font-weight: 600; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                         ${sound.title}
                    </div>
                    <div style="color: rgba(255, 255, 255, 0.6); font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        ${sound.artist || 'Unknown Artist'}
                    </div>
                </div>
                <button onclick="removeScreen3Sound()" style="
                    padding: 6px 12px;
                    background: rgba(255, 0, 80, 0.3);
                    border: 1px solid rgba(255, 0, 80, 0.5);
                    color: #ff0050;
                    border-radius: 6px;
                    cursor: pointer;
                    font-size: 12px;
                    font-weight: 600;
                    transition: all 0.3s;
                " onmouseover="this.style.background='rgba(255, 0, 80, 0.5)'" onmouseout="this.style.background='rgba(255, 0, 80, 0.3)'">
                     Remove
                </button>
            `;

            console.log(' Sound info displayed on Screen 3');
        }

        // Remove Sound from Screen 3
        function removeScreen3Sound() {
            console.log(' Removing sound from Screen 3');

            // Stop audio
            const audioElement = document.getElementById('editVideoSoundAudio');
            if (audioElement) {
                audioElement.pause();
                audioElement.currentTime = 0;
                audioElement.src = '';
            }

            // Unmute video
            const videoElement = document.getElementById('editVideoPreview');
            if (videoElement) {
                videoElement.muted = false;
                videoElement.volume = recordingState.videoOriginalVolume || 1;
                console.log(' Video audio restored');
            }

            // Clear recordingState
            recordingState.selectedSound = null;

            // Remove display
            const soundDisplay = document.getElementById('screen3SoundDisplay');
            if (soundDisplay) {
                soundDisplay.remove();
            }

            showToastRecording('Sound removed', 'success', '');
        }

        // Initialize Audio-Video Sync
        function initializeAudioVideoSync() {
            const video = document.getElementById('editVideoPreview');
            const audio = document.getElementById('editVideoSoundAudio');

            if (!video || !audio) return;

            // Remove old listeners to prevent duplicates
            video.removeEventListener('timeupdate', window.syncAudioToVideo);
            video.removeEventListener('ended', window.onVideoEnded);
            audio.removeEventListener('timeupdate', window.syncVideoToAudio);
            audio.removeEventListener('ended', window.onAudioEnded);

            // Define event handlers
            window.syncAudioToVideo = function () {
                if (!recordingState.selectedSound) return;
                if (!video.duration || video.duration === 0) return;

                // If audio time exceeds video duration, stop audio
                if (audio.currentTime >= video.duration) {
                    audio.currentTime = 0;
                    audio.pause();
                    if (!video.paused) video.pause();
                    console.log(' Audio duration exceeded, both stopped');
                    return;
                }

                // Sync audio to video
                if (Math.abs(audio.currentTime - video.currentTime) > 0.15) {
                    audio.currentTime = video.currentTime;
                }
            };

            window.syncVideoToAudio = function () {
                if (!recordingState.selectedSound) return;
                if (!video.duration || video.duration === 0) return;

                // Sync video to audio, but don't let audio push beyond video duration
                if (audio.currentTime >= video.duration) {
                    audio.currentTime = 0;
                    audio.pause();
                    if (!video.paused) video.pause();
                    console.log(' Audio exceeded video duration');
                    return;
                }

                if (Math.abs(video.currentTime - audio.currentTime) > 0.15) {
                    video.currentTime = audio.currentTime;
                }
            };

            window.onVideoEnded = function () {
                // When video ends, stop audio immediately
                if (audio && !audio.paused) {
                    audio.pause();
                    audio.currentTime = 0;
                    console.log(' Video ended, audio stopped');
                }
            };

            window.onAudioEnded = function () {
                // If audio ends, make sure it doesn't play past video
                if (!video.paused && video.currentTime < video.duration) {
                    // Audio ended but video is still playing - that's fine, let video continue
                    console.log(' Audio ended, video continues');
                } else {
                    if (!video.paused) {
                        video.pause();
                        console.log(' Audio ended, video paused');
                    }
                }
            };

            // Add listeners
            video.addEventListener('timeupdate', window.syncAudioToVideo);
            video.addEventListener('ended', window.onVideoEnded);
            audio.addEventListener('timeupdate', window.syncVideoToAudio);
            audio.addEventListener('ended', window.onAudioEnded);

            console.log(' Audio-Video sync initialized');
            console.log(' Video duration:', video.duration);
            console.log(' Audio duration:', audio.duration);
        }

        // Toggle Selected Sound Playback
        function toggleSelectedSoundPlayback() {
            if (!soundLibraryState.selectedSound) return;

            const sound = soundLibraryState.selectedSound;
            const btn = document.getElementById('soundPlayBtn');

            if (soundLibraryState.isPlaying && soundLibraryState.currentAudio?.src === sound.audioUrl) {
                // Pause current
                soundLibraryState.currentAudio.pause();
                soundLibraryState.isPlaying = false;
                btn.innerHTML = '<i class="fas fa-play"></i>';
                btn.classList.remove('playing');
            } else {
                // Stop any current audio
                stopCurrentAudio();

                // Play selected sound
                soundLibraryState.currentAudio = new Audio(sound.audioUrl);
                soundLibraryState.currentAudio.volume = 1;

                // Get trim boundaries (if trimmed)
                const startTime = sound.trimStart || 0;
                const endTime = sound.trimEnd || soundLibraryState.currentAudio.duration;

                // Start from trim point
                soundLibraryState.currentAudio.currentTime = startTime;
                soundLibraryState.currentAudio.play();
                soundLibraryState.isPlaying = true;
                btn.innerHTML = '<i class="fas fa-pause"></i>';
                btn.classList.add('playing');

                // Monitor playback and stop at trim end
                soundLibraryState.currentAudio.ontimeupdate = () => {
                    if (soundLibraryState.currentAudio.currentTime >= endTime) {
                        soundLibraryState.currentAudio.pause();
                        soundLibraryState.isPlaying = false;
                        btn.innerHTML = '<i class="fas fa-play"></i>';
                        btn.classList.remove('playing');
                    }
                };

                // Auto stop when finished
                soundLibraryState.currentAudio.onended = () => {
                    soundLibraryState.isPlaying = false;
                    btn.innerHTML = '<i class="fas fa-play"></i>';
                    btn.classList.remove('playing');
                };

                const trimInfo = sound.trimStart ? ` (${sound.trimDuration}s trimmed)` : '';
                showToastRecording(` Playing "${sound.title}"${trimInfo}`, 'info', '');
            }
        }

        // Remove Selected Sound
        function removeSelectedSound() {
            if (soundLibraryState.currentAudio) {
                soundLibraryState.currentAudio.pause();
                soundLibraryState.currentAudio = null;
                soundLibraryState.isPlaying = false;
            }

            soundLibraryState.selectedSound = null;
            // Also clear from photoState
            photoState.selectedSound = null;

            document.getElementById('selectedSoundContainer').classList.remove('show');
            document.getElementById('soundPlayBtn').innerHTML = '<i class="fas fa-play"></i>';
            document.getElementById('soundPlayBtn').classList.remove('playing');

            showToastRecording(' Sound removed', 'info', '');
            console.log(' Selected sound removed');
        }

        // Open Sound Trimmer
        function openSoundTrimmer() {
            if (!soundLibraryState.selectedSound) {
                showToastRecording('No sound selected', 'error', '');
                return;
            }

            const sound = soundLibraryState.selectedSound;
            const modal = document.createElement('div');
            modal.className = 'modal-overlay active';
            modal.id = 'soundTrimmerModal';

            // Use existing trim values or default to 0 and will detect actual duration
            const startVal = sound.trimStart !== undefined ? sound.trimStart : 0;
            // Will be updated once audio loads
            const endVal = sound.trimEnd !== undefined ? sound.trimEnd : null;

            modal.innerHTML = `
        <div class="modal" style="max-width: 95vw; width: 100%; max-height: 95vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeSoundTrimmer()"><i class="fas fa-times"></i></button>
            <h2><i class="fas fa-cut"></i> Trim Sound - ${sound.title}</h2>
            <p style="color: #aaa; font-size: 13px; margin-bottom: 20px;">Select where the audio should start and stop</p>
            <div style="margin: 20px 0;">
                <audio id="trimPreviewAudio" style="width: 100%; margin-bottom: 20px;" controls>
                    <source src="${sound.audioUrl}" type="audio/mpeg">
                </audio>
                <div id="durationLoading" style="text-align: center; color: #888; font-size: 12px; padding: 10px;">
                    <i class="fas fa-spinner fa-spin"></i> Loading audio duration...
                </div>
                
                <!-- VISUAL TIMELINE SLIDER -->
                <div style="margin-bottom: 25px;">
                    <label style="display: block; margin-bottom: 12px; font-weight: 600;"><i class="fas fa-sliders-h"></i> Visual Trim Timeline</label>
                    <div style="background: linear-gradient(90deg, #1a1a1a 0%, #2a2a2a 50%, #1a1a1a 100%); border-radius: 8px; padding: 20px; border: 1px solid #444;">
                        <!-- Timeline Bar -->
                        <div style="position: relative; height: 40px; background: #0a0a0a; border-radius: 6px; border: 1px solid #555; cursor: pointer;" id="timelineBar">
                            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center;">
                                <!-- Untrimmed region (gray) -->
                                <div id="beforeTrim" style="position: absolute; top: 0; height: 100%; background: rgba(255,255,255,0.1); border-radius: 6px 0 0 6px;"></div>
                                <!-- Trimmed region (blue) -->
                                <div id="trimmedRegion" style="position: absolute; top: 0; height: 100%; background: linear-gradient(90deg, #6366f1 0%, #8b5cf6 100%); border-radius: 4px;"></div>
                                <!-- After trim (gray) -->
                                <div id="afterTrim" style="position: absolute; top: 0; right: 0; height: 100%; background: rgba(255,255,255,0.1); border-radius: 0 6px 6px 0;"></div>
                                <!-- Start handle -->
                                <div id="startHandle" style="position: absolute; top: 50%; transform: translateY(-50%); width: 12px; height: 40px; background: #ff0050; border-radius: 4px; cursor: col-resize; z-index: 10; box-shadow: 0 0 10px rgba(255,0,80,0.6);"></div>
                                <!-- End handle -->
                                <div id="endHandle" style="position: absolute; top: 50%; transform: translateY(-50%); width: 12px; height: 40px; background: #ff0050; border-radius: 4px; cursor: col-resize; z-index: 10; box-shadow: 0 0 10px rgba(255,0,80,0.6);"></div>
                            </div>
                        </div>
                        <!-- Time labels -->
                        <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 12px; color: #888;">
                            <span><i class="fas fa-play"></i> <strong id="startLabel">0.0s</strong></span>
                            <span id="durationLabel" style="color: #6366f1;"><strong>60.0s</strong></span>
                            <span><i class="fas fa-stop"></i> <strong id="endLabel">60.0s</strong></span>
                        </div>
                    </div>
                </div>
                
                <!-- NUMBER INPUT METHOD -->
                <div style="background: #0a0a0a; border-radius: 8px; padding: 15px; border: 1px solid #333; margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 12px; font-weight: 600; color: #ccc;"><i class="fas fa-keyboard"></i> Manual Input</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <div>
                            <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;"><i class="fas fa-play"></i> Start (s)</label>
                            <input type="number" id="trimStart" min="0" max="600" value="${startVal}" step="0.1" style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; border-radius: 6px; color: white; font-size: 14px;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 6px; font-weight: 600; font-size: 13px;"><i class="fas fa-stop"></i> End (s)</label>
                            <input type="number" id="trimEnd" min="0" max="600" value="${endVal}" step="0.1" style="width: 100%; padding: 10px; background: #2a2a2a; border: 1px solid #444; border-radius: 6px; color: white; font-size: 14px;">
                        </div>
                    </div>
                </div>
                
                <!-- RANGE SLIDER METHOD -->
                <div style="background: #0a0a0a; border-radius: 8px; padding: 15px; border: 1px solid #333; margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 12px; font-weight: 600; color: #ccc;"><i class="fas fa-sliders-h"></i> Range Slider</label>
                    <div style="margin-bottom: 15px;">
                        <label style="font-size: 12px; color: #888; display: block; margin-bottom: 8px;">Start Time</label>
                        <input type="range" id="startSlider" min="0" max="600" value="${startVal}" step="0.1" style="width: 100%; cursor: pointer;">
                        <span id="startSliderLabel" style="font-size: 12px; color: #6366f1; display: block; margin-top: 4px;">${startVal}s</span>
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #888; display: block; margin-bottom: 8px;">End Time</label>
                        <input type="range" id="endSlider" min="0" max="600" value="${endVal}" step="0.1" style="width: 100%; cursor: pointer;">
                        <span id="endSliderLabel" style="font-size: 12px; color: #6366f1; display: block; margin-top: 4px;">${endVal}s</span>
                    </div>
                </div>
                
                <div id="trimDurationDisplay" style="background: rgba(99, 102, 241, 0.2); border: 1px solid #6366f1; border-radius: 8px; padding: 12px; margin-bottom: 20px; color: #c7d2fe;">
                    <i class="fas fa-info-circle"></i> Duration: <strong id="trimDurationValue">30.0s</strong>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button onclick="applyAudioTrim()" class="modal-btn" style="flex: 1;">
                        <i class="fas fa-check"></i> Apply Trim
                    </button>
                    <button onclick="closeSoundTrimmer()" class="modal-btn" style="flex: 1; background: #666;">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
        `;

            document.body.appendChild(modal);

            // Setup event listeners
            const trimStart = document.getElementById('trimStart');
            const trimEnd = document.getElementById('trimEnd');
            const startSlider = document.getElementById('startSlider');
            const endSlider = document.getElementById('endSlider');
            const audioElement = document.getElementById('trimPreviewAudio');
            const durationLoading = document.getElementById('durationLoading');

            // Detect actual audio duration
            audioElement.addEventListener('loadedmetadata', () => {
                const actualDuration = Math.ceil(audioElement.duration);

                // Update max values to actual duration
                const newEndVal = endVal !== null ? endVal : actualDuration;

                // Update all range limits
                trimStart.max = actualDuration;
                trimEnd.max = actualDuration;
                startSlider.max = actualDuration;
                endSlider.max = actualDuration;

                // Set end value if not already set
                if (endVal === null) {
                    trimEnd.value = actualDuration;
                    endSlider.value = actualDuration;
                    document.getElementById('endSliderLabel').textContent = actualDuration + 's';
                    document.getElementById('endLabel').textContent = actualDuration.toFixed(1) + 's';
                }

                // Hide loading message
                durationLoading.style.display = 'none';

                // Update timeline
                updateTrimTimeline();

                console.log(` Audio duration detected: ${actualDuration}s`);
                showToastRecording(` Audio duration: ${actualDuration}s`, 'info', '');
            });

            // Handle audio load errors
            audioElement.addEventListener('error', () => {
                console.error(' Error loading audio');
                durationLoading.innerHTML = '<span style="color: #ff6b6b;">Error loading audio duration</span>';
            });

            // Sync all inputs
            trimStart.addEventListener('input', () => {
                startSlider.value = trimStart.value;
                updateTrimTimeline();
            });

            trimEnd.addEventListener('input', () => {
                endSlider.value = trimEnd.value;
                updateTrimTimeline();
            });

            startSlider.addEventListener('input', () => {
                trimStart.value = startSlider.value;
                document.getElementById('startSliderLabel').textContent = startSlider.value + 's';
                updateTrimTimeline();
            });

            endSlider.addEventListener('input', () => {
                trimEnd.value = endSlider.value;
                document.getElementById('endSliderLabel').textContent = endSlider.value + 's';
                updateTrimTimeline();
            });

            // Setup timeline handle dragging
            setupTimelineHandles();

            updateTrimTimeline();

            console.log(' Sound trimmer opened for:', sound.title);
        }

        // Setup draggable timeline handles
        function setupTimelineHandles() {
            const timeline = document.getElementById('timelineBar');
            const startHandle = document.getElementById('startHandle');
            const endHandle = document.getElementById('endHandle');
            const trimStart = document.getElementById('trimStart');
            const trimEnd = document.getElementById('trimEnd');

            if (!timeline || !startHandle || !endHandle) return;

            let isDragging = false;
            let dragType = null;

            startHandle.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragType = 'start';
                e.preventDefault();
            });

            endHandle.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragType = 'end';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const rect = timeline.getBoundingClientRect();
                const percent = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
                const maxTime = parseFloat(trimEnd.max) || 600;
                const time = (percent / 100) * maxTime;

                if (dragType === 'start' && time < parseFloat(trimEnd.value)) {
                    trimStart.value = time.toFixed(1);
                    document.getElementById('startSlider').value = time.toFixed(1);
                    document.getElementById('startSliderLabel').textContent = time.toFixed(1) + 's';
                    updateTrimTimeline();
                } else if (dragType === 'end' && time > parseFloat(trimStart.value)) {
                    trimEnd.value = time.toFixed(1);
                    document.getElementById('endSlider').value = time.toFixed(1);
                    document.getElementById('endSliderLabel').textContent = time.toFixed(1) + 's';
                    updateTrimTimeline();
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                dragType = null;
            });
        }

        // Update timeline visual
        function updateTrimTimeline() {
            const trimStartInput = document.getElementById('trimStart');
            const trimEndInput = document.getElementById('trimEnd');
            const start = parseFloat(trimStartInput.value) || 0;
            const end = parseFloat(trimEndInput.value) || 60;
            // Use actual max from input or 600 as fallback
            const maxTime = parseFloat(trimEndInput.max) || 600;

            const startPercent = (start / maxTime) * 100;
            const endPercent = (end / maxTime) * 100;
            const duration = Math.max(0, end - start).toFixed(1);

            // Update timeline regions
            const beforeTrim = document.getElementById('beforeTrim');
            const trimmedRegion = document.getElementById('trimmedRegion');
            const afterTrim = document.getElementById('afterTrim');
            const startHandle = document.getElementById('startHandle');
            const endHandle = document.getElementById('endHandle');

            if (beforeTrim) beforeTrim.style.width = startPercent + '%';
            if (trimmedRegion) {
                trimmedRegion.style.left = startPercent + '%';
                trimmedRegion.style.width = (endPercent - startPercent) + '%';
            }
            if (afterTrim) {
                afterTrim.style.left = endPercent + '%';
                afterTrim.style.width = (100 - endPercent) + '%';
            }
            if (startHandle) startHandle.style.left = startPercent + '%';
            if (endHandle) endHandle.style.left = endPercent + '%';

            // Update labels
            document.getElementById('startLabel').textContent = start.toFixed(1) + 's';
            document.getElementById('endLabel').textContent = end.toFixed(1) + 's';
            document.getElementById('durationLabel').textContent = '<strong>' + duration + 's</strong>';
            document.getElementById('trimDurationValue').textContent = duration + 's';
        }

        // Update trim duration display
        function updateTrimDuration() {
            const start = parseFloat(document.getElementById('trimStart').value) || 0;
            const end = parseFloat(document.getElementById('trimEnd').value) || 0;
            const duration = Math.max(0, end - start).toFixed(1);
            document.getElementById('trimDurationValue').textContent = duration + 's';
        }

        // Close Sound Trimmer
        function closeSoundTrimmer() {
            const modal = document.getElementById('soundTrimmerModal');
            if (modal) modal.remove();
        }

        // Apply Audio Trim
        function applyAudioTrim() {
            const startTime = parseFloat(document.getElementById('trimStart').value) || 0;
            const endTime = parseFloat(document.getElementById('trimEnd').value) || 30;

            if (startTime >= endTime) {
                showToastRecording('Start time must be less than end time', 'error', '');
                return;
            }

            // Update selected sound with trim info
            soundLibraryState.selectedSound.trimStart = startTime;
            soundLibraryState.selectedSound.trimEnd = endTime;
            soundLibraryState.selectedSound.trimDuration = (endTime - startTime).toFixed(2);

            closeSoundTrimmer();
            showToastRecording(` Trimmed to ${soundLibraryState.selectedSound.trimDuration}s`, 'success', '');
            console.log(' Sound trimmed:', soundLibraryState.selectedSound.trimStart, '-', soundLibraryState.selectedSound.trimEnd);
        }

        // Genre mapping for iTunes API
        const genreToiTunesGenre = {
            'afrobeat': 'afrobeat',
            'hip-hop': 'hip hop',
            'pop': 'pop',
            'r&b': 'r&b',
            'amapiano': 'amapiano',
            'reggae': 'reggae',
            'house': 'house',
            'gospel': 'gospel'
        };

        // Country to artist mapping
        const countryArtists = {
            'NG': ['Wizkid', 'Burna Boy', 'Davido', 'Olamide', 'Asake', 'CKay', 'Tiwa Savage', 'Rema'],
            'GH': ['Sarkodie', 'Shatta Wale', 'King Promise', 'Ace Hood'],
            'ZA': ['Amapiano Artists', 'DJ Maphorisa', 'Kabza De Small'],
            'KE': ['Sauti Sol', 'Nyashinski'],
            'UG': ['Eddy Kenzo', 'Bobi Wine'],
            'CM': ['Stanley Enow', 'Magasco'],
            'US': ['The Weeknd', 'Drake', 'Kendrick Lamar'],
            'UK': ['Skepta', 'Ed Sheeran']
        };

        // Apply search filters
        function applySearchFilters() {
            const query = soundLibraryState.currentSearchQuery;
            if (!query || query.trim() === '') {
                loadPoseMusicLibrary();
                return;
            }
            searchSounds('poseMusic', query);
        }

        // Filter state for search
        let soundFilterState = {
            genre: '',
            country: '',
            year: '',
            currentQuery: '',
            currentTab: 'poseMusic'
        };

        // Debounce timers for search
        let searchDebounceTimer = {};

        // Search Sounds - Production-level Local + API Search with Advanced Filtering
        async function searchSounds(tab, query) {
            // Debounce to prevent excessive searches (wait 300ms)
            clearTimeout(searchDebounceTimer[tab]);

            soundFilterState.currentQuery = query;
            soundFilterState.currentTab = tab;

            searchDebounceTimer[tab] = setTimeout(() => {
                applySearchFilters();
            }, 300);
        }

        // Apply Search Filters with Relevance Scoring
        async function applySearchFilters() {
            const tab = soundFilterState.currentTab;
            const query = soundFilterState.currentQuery || '';

            // Get filter values only for poseMusic tab
            if (tab === 'poseMusic') {
                soundFilterState.genre = document.getElementById('genreFilter')?.value || '';
                soundFilterState.country = document.getElementById('countryFilter')?.value || '';
                soundFilterState.year = document.getElementById('yearFilter')?.value || '';
            }

            const containerMap = {
                'favourite': 'favouriteSoundList',
                'yourMusic': 'yourMusicSoundList',
                'poseMusic': 'poseMusicSoundList'
            };

            const container = document.getElementById(containerMap[tab]);

            // Ensure allSounds[tab] exists
            if (!soundLibraryState.allSounds[tab]) {
                soundLibraryState.allSounds[tab] = [];
            }

            const allSounds = soundLibraryState.allSounds[tab];

            // If query is empty, show trending/library songs
            if (!query || query.trim() === '') {
                container.innerHTML = '';

                // For poseMusic tab, show loaded library songs
                if (tab === 'poseMusic' && musicLibraryState.allLoadedSongs.length > 0) {
                    const filtered = applyFilters(musicLibraryState.allLoadedSongs, tab);

                    if (filtered.length === 0) {
                        container.innerHTML = `
                        <div class="sound-empty">
                            <div class="sound-empty-icon"></div>
                            <div class="sound-empty-title">No sounds found</div>
                            <div class="sound-empty-text">Try adjusting filters or search for songs</div>
                        </div>
                        `;
                        return;
                    }

                    filtered.forEach(sound => {
                        const item = createSoundItem(sound, tab);
                        container.appendChild(item);
                    });
                    console.log(` Showing ${filtered.length} songs from library with filters applied`);
                    return;
                }

                // For other tabs, show saved sounds
                const filtered = applyFilters(allSounds, tab);

                if (filtered.length === 0) {
                    container.innerHTML = `
                    <div class="sound-empty">
                        <div class="sound-empty-icon"></div>
                        <div class="sound-empty-title">No sounds found</div>
                        <div class="sound-empty-text">Try adjusting filters or adding more sounds</div>
                    </div>
                    `;
                    return;
                }

                filtered.forEach(sound => {
                    const item = createSoundItem(sound, tab);
                    container.appendChild(item);
                });
                console.log(` Showing ${filtered.length} sounds with filters applied`);
                return;
            }

            // Show loading
            container.innerHTML = '<div class="sound-loading"><div class="sound-loading-spinner"></div><p> Searching...</p></div>';

            // Normalize query
            const normalizedQuery = query.trim().toLowerCase();
            const queryTerms = normalizedQuery.split(/\s+/).filter(t => t.length > 0);

            // Local search with relevance scoring
            const localResultsWithScore = allSounds
                .map(sound => ({
                    sound,
                    score: calculateSearchRelevance(sound, normalizedQuery, queryTerms),
                    type: 'local'
                }))
                .filter(result => result.score > 0)
                .sort((a, b) => b.score - a.score);

            // For poseMusic tab, also search iTunes API
            let apiResultsWithScore = [];
            if (tab === 'poseMusic' && queryTerms.length > 0) {
                try {
                    console.log(` Searching iTunes API for: "${query}"`);
                    const iTunesUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(query)}&entity=song&limit=20`;
                    console.log(` API URL: ${iTunesUrl}`);

                    const response = await fetch(iTunesUrl, {
                        method: 'GET',
                        mode: 'cors',
                        headers: {
                            'Accept': 'application/json'
                        }
                    });

                    console.log(` API Response Status: ${response.status}`);

                    if (response.ok) {
                        const data = await response.json();
                        console.log(` iTunes API returned ${data.resultCount} results`);

                        if (data.results && data.results.length > 0) {
                            const apiResults = data.results
                                .filter(song => song.previewUrl && song.trackName && song.artistName)
                                .map((song, index) => ({
                                    id: `api_${Date.now()}_${index}`,
                                    title: song.trackName || 'Unknown',
                                    artist: song.artistName || 'Unknown Artist',
                                    duration: formatDuration(song.trackTimeMillis),
                                    fullDuration: formatDuration(song.trackTimeMillis),
                                    previewNote: '(30s preview)',
                                    thumbnail: song.artworkUrl100 || song.artworkUrl60,
                                    audioUrl: song.previewUrl,
                                    category: 'Search Result',
                                    releaseYear: new Date(song.releaseDate).getFullYear() || new Date().getFullYear(),
                                    uses: `${Math.floor(Math.random() * 100) + 10}K`,
                                    trending: index === 0,
                                    isTrimable: true,
                                    isAPIResult: true
                                }));

                            apiResultsWithScore = apiResults
                                .map(sound => ({
                                    sound,
                                    score: calculateSearchRelevance(sound, normalizedQuery, queryTerms) + 50, // Slight boost for API results
                                    type: 'api'
                                }))
                                .filter(result => result.score > 0);

                            console.log(` Found ${apiResults.length} songs with preview from iTunes API`);
                        } else {
                            console.warn(` iTunes API returned no results with preview URLs`);
                        }
                    } else {
                        console.warn(` iTunes API returned status ${response.status}`);
                    }
                } catch (error) {
                    console.error(' iTunes API search error:', error.message, error);
                    showToastRecording(`Error searching iTunes: ${error.message}`, 'error', '');
                }
            }

            // Combine results and sort by relevance
            let allResults = [...localResultsWithScore, ...apiResultsWithScore]
                .sort((a, b) => b.score - a.score)
                .slice(0, 20) // Limit to 20 results
                .map(r => r.sound);

            // Apply filters to results
            allResults = applyFilters(allResults, tab);

            container.innerHTML = '';

            if (allResults.length === 0) {
                container.innerHTML = `
                <div class="sound-empty">
                    <div class="sound-empty-icon"></div>
                    <div class="sound-empty-title">No results for "${query}"</div>
                    <div class="sound-empty-text">Try different keywords or adjust filters</div>
                </div>
            `;
                console.log(` No results for "${query}" in ${tab}`);
                return;
            }

            allResults.forEach(sound => {
                const item = createSoundItem(sound, tab);
                container.appendChild(item);
            });

            const localCount = localResultsWithScore.length;
            const apiCount = apiResultsWithScore.length;
            console.log(` Found ${allResults.length} results (${localCount} local + ${apiCount} API) for "${query}"`);
        }

        // Calculate search relevance score
        function calculateSearchRelevance(sound, normalizedQuery, queryTerms) {
            let score = 0;

            const title = (sound.title || '').toLowerCase();
            const artist = (sound.artist || '').toLowerCase();
            const category = (sound.category || '').toLowerCase();

            // Title matching (highest priority - 40% weight)
            if (title === normalizedQuery) {
                score += 1000;
            } else if (title.startsWith(normalizedQuery)) {
                score += 500;
            } else if (title.includes(normalizedQuery)) {
                score += 300;
            } else {
                // Multi-word partial matching
                queryTerms.forEach(term => {
                    if (title.includes(term)) {
                        score += 100;
                    }
                });
            }

            // Artist matching (medium priority - 30% weight)
            if (artist === normalizedQuery) {
                score += 800;
            } else if (artist.startsWith(normalizedQuery)) {
                score += 400;
            } else if (artist.includes(normalizedQuery)) {
                score += 200;
            } else {
                queryTerms.forEach(term => {
                    if (artist.includes(term)) {
                        score += 60;
                    }
                });
            }

            // Category matching (low priority - 15% weight)
            if (category === normalizedQuery) {
                score += 150;
            } else if (category.includes(normalizedQuery)) {
                score += 50;
            }

            // Popularity bonuses
            if (sound.uses) {
                const uses = parseInt(sound.uses);
                if (uses > 100000) score += 100; // Very popular
                else if (uses > 50000) score += 50;
                else if (uses > 10000) score += 20;
            }

            // Trending bonus
            if (sound.trending) {
                score += 150;
            }

            // Recent upload bonus
            if (sound.uploadedAt) {
                const daysSince = (Date.now() - sound.uploadedAt) / (1000 * 60 * 60 * 24);
                if (daysSince < 7) score += 100;
                else if (daysSince < 30) score += 50;
            }

            return score;
        }

        // Apply Filters to Results
        function applyFilters(sounds, tab) {
            if (tab !== 'poseMusic') {
                return sounds; // Only filter on poseMusic tab
            }

            const { genre, country, year } = soundFilterState;

            return sounds.filter(sound => {
                // Genre filter
                if (genre && sound.category) {
                    const soundGenre = sound.category.toLowerCase();
                    if (!soundGenre.includes(genre.toLowerCase())) {
                        return false;
                    }
                }

                // Year filter
                if (year) {
                    const soundYear = sound.releaseYear || new Date().getFullYear();
                    if (soundYear !== parseInt(year)) {
                        return false;
                    }
                }

                // Country filter (check artist origin based on category or use random match for demo)
                if (country) {
                    // In production, you'd have artist country metadata
                    const artistCountries = {
                        'NG': ['Wizkid', 'Burna Boy', 'Davido', 'Olamide', 'Asake'],
                        'GH': ['Sarkodie', 'Shatta Wale'],
                        'ZA': ['Amapiano', 'Kabza'],
                        'KE': ['Sauti Sol'],
                        'UG': ['Eddy Kenzo'],
                        'US': ['Beyonc', 'Drake'],
                        'UK': ['Stormzy', 'Skepta']
                    };

                    const countrySongs = artistCountries[country] || [];
                    const artistMatch = countrySongs.some(a =>
                        sound.artist?.toLowerCase().includes(a.toLowerCase())
                    );

                    if (!artistMatch && country !== '') {
                        return false;
                    }
                }

                return true;
            });
        }

        // Reset All Filters
        function resetSoundFilters() {
            soundFilterState.genre = '';
            soundFilterState.country = '';
            soundFilterState.year = '';
            soundFilterState.currentQuery = '';

            document.getElementById('genreFilter').value = '';
            document.getElementById('countryFilter').value = '';
            document.getElementById('yearFilter').value = '';
            document.querySelector('.sound-search-input').value = '';

            applySearchFilters();
            showToastRecording('Filters reset', 'info', '');
            console.log(' Filters reset');
        }

        // Upload Your Music
        function uploadYourMusic() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'audio/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                if (!currentUser) {
                    showToastRecording('Please login to upload music', 'error', '');
                    return;
                }

                try {
                    showToastRecording(' Uploading music to your library...', 'info', '');

                    // Upload to Cloudinary
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
                    formData.append('folder', 'user_music');

                    const response = await fetch(CLOUDINARY_API_URL, {
                        method: 'POST',
                        body: formData
                    });

                    const data = await response.json();

                    // Save to Firestore
                    await db.collection('users').doc(currentUser.uid).collection('uploadedMusic').add({
                        title: file.name.replace(/\.[^/.]+$/, ''),
                        artist: 'You',
                        audioUrl: data.secure_url,
                        duration: '0:00',
                        category: 'Uploaded',
                        isTrimable: true,
                        trimStart: 0,
                        trimEnd: null,
                        uploadedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    showToastRecording(' Uploaded to your music!', 'success', '');
                    console.log(' Music uploaded:', file.name);
                    loadYourMusic();

                } catch (error) {
                    console.error('Upload error:', error);
                    showToastRecording(' Upload failed: ' + error.message, 'error', '');
                }
            };
            input.click();
        }

        // Voice Recording Functions
        let voiceRecordingState = {
            recorder: null,
            chunks: [],
            startTime: 0,
            timerInterval: null
        };

        async function startVoiceRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                voiceRecordingState.recorder = new MediaRecorder(stream);
                voiceRecordingState.chunks = [];

                voiceRecordingState.recorder.ondataavailable = (e) => {
                    voiceRecordingState.chunks.push(e.data);
                };

                voiceRecordingState.recorder.onstop = () => {
                    const blob = new Blob(voiceRecordingState.chunks, { type: 'audio/webm' });
                    soundLibraryState.voiceRecordingBlob = blob;
                };

                voiceRecordingState.recorder.start();
                voiceRecordingState.startTime = Date.now();

                // Update UI
                document.getElementById('voiceRecordBtn').style.display = 'none';
                document.getElementById('voiceStopBtn').style.display = 'flex';
                document.getElementById('voiceVisualizer').classList.add('recording');

                // Start timer
                voiceRecordingState.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - voiceRecordingState.startTime) / 1000);
                    const mins = Math.floor(elapsed / 60);
                    const secs = elapsed % 60;
                    document.getElementById('voiceTimer').textContent =
                        `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
                }, 1000);

                showToastRecording(' Recording...', 'info', '');

            } catch (error) {
                console.error('Microphone error:', error);
                alert(' Microphone access denied');
            }
        }

        function stopVoiceRecording() {
            if (voiceRecordingState.recorder) {
                voiceRecordingState.recorder.stop();
                voiceRecordingState.recorder.stream.getTracks().forEach(track => track.stop());
                clearInterval(voiceRecordingState.timerInterval);

                // Update UI
                document.getElementById('voiceStopBtn').style.display = 'none';
                document.getElementById('voicePreviewControls').style.display = 'flex';
                document.getElementById('voiceVisualizer').classList.remove('recording');

                showToastRecording(' Recording stopped - Accept or Discard?', 'info', '');
            }
        }

        // Preview Voice Recording - Toggle Play/Pause
        function previewVoiceRecording() {
            if (!soundLibraryState.voiceRecordingBlob) {
                showToastRecording('No recording to play', 'error', '');
                return;
            }

            try {
                const btn = document.querySelector('.voice-preview-btn.listen');

                // If already playing, pause it
                if (soundLibraryState.isPlaying && soundLibraryState.currentAudio) {
                    soundLibraryState.currentAudio.pause();
                    soundLibraryState.isPlaying = false;
                    btn.innerHTML = '<i class="fas fa-play"></i> Listen';
                    showToastRecording(' Paused', 'info', '');
                    console.log(' Voice recording paused');
                    return;
                }

                // Otherwise play it
                stopCurrentAudio();

                // Create audio from blob
                const audioUrl = URL.createObjectURL(soundLibraryState.voiceRecordingBlob);
                soundLibraryState.currentAudio = new Audio(audioUrl);
                soundLibraryState.currentAudio.play();
                soundLibraryState.isPlaying = true;

                // Update button
                btn.innerHTML = '<i class="fas fa-pause"></i> Pause';

                // Auto-reset when finished
                soundLibraryState.currentAudio.onended = () => {
                    soundLibraryState.isPlaying = false;
                    btn.innerHTML = '<i class="fas fa-play"></i> Listen';
                    showToastRecording(' Recording finished', 'success', '');
                };

                showToastRecording(' Playing preview...', 'info', '');
                console.log(' Playing voice recording preview');

            } catch (error) {
                console.error('Error playing preview:', error);
                showToastRecording('Error playing preview', 'error', '');
            }
        }

        // Discard Voice Recording
        function discardVoiceRecording() {
            soundLibraryState.voiceRecordingBlob = null;

            // Reset UI
            document.getElementById('voiceTimer').textContent = '00:00';
            document.getElementById('voicePreviewControls').style.display = 'none';
            document.getElementById('voiceRecordBtn').style.display = 'flex';

            // Stop any playing audio
            stopCurrentAudio();

            showToastRecording(' Recording discarded', 'info', '');
            console.log('Voice recording discarded');
        }

        // Accept Voice Recording
        function acceptVoiceRecording() {
            if (!soundLibraryState.voiceRecordingBlob) {
                showToastRecording('No recording to save', 'error', '');
                return;
            }

            // Stop any playing audio
            stopCurrentAudio();

            // Show loading state on button
            const acceptBtn = document.querySelector('.voice-preview-btn.accept');
            const originalHTML = acceptBtn.innerHTML;
            acceptBtn.disabled = true;
            acceptBtn.style.opacity = '0.7';
            acceptBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';

            // Save to Firebase
            saveVoiceRecordingToFirebase().finally(() => {
                // Reset button state (if modal is still visible)
                if (document.getElementById('voicePreviewControls').style.display === 'flex') {
                    acceptBtn.disabled = false;
                    acceptBtn.style.opacity = '1';
                    acceptBtn.innerHTML = originalHTML;
                }
            });
        }

        // Save Voice Recording to Firebase
        async function saveVoiceRecordingToFirebase() {
            if (!soundLibraryState.voiceRecordingBlob) {
                showToastRecording('No recording to save', 'error', '');
                return;
            }
            if (!currentUser) {
                showToastRecording('Please login to save voice recording', 'error', '');
                return;
            }

            try {
                showToastRecording(' Saving voice to your music...', 'info', '');

                // Upload to Cloudinary
                const formData = new FormData();
                formData.append('file', soundLibraryState.voiceRecordingBlob);
                formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
                formData.append('folder', 'voice_recordings');

                const response = await fetch(CLOUDINARY_API_URL, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                // Save to Firestore
                const voiceData = {
                    title: `Voice Recording ${new Date().toLocaleString()}`,
                    artist: 'You',
                    audioUrl: data.secure_url,
                    duration: document.getElementById('voiceTimer').textContent,
                    uploadedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    category: 'Voice',
                    isTrimable: true,
                    trimStart: 0,
                    trimEnd: null,
                    id: `voice_${Date.now()}`
                };

                await db.collection('users').doc(currentUser.uid).collection('uploadedMusic').add(voiceData);

                // Also add to selected sound
                soundLibraryState.selectedSound = {
                    id: data.public_id,
                    ...voiceData
                };

                console.log(' Voice recording saved to your music');

                // Reset UI
                document.getElementById('voiceTimer').textContent = '00:00';
                document.getElementById('voicePreviewControls').style.display = 'none';
                document.getElementById('voiceRecordBtn').style.display = 'flex';

                // Reload your music tab
                await loadYourMusic();

                // Show success modal
                showVoiceSuccessModal();

            } catch (error) {
                console.error('Save error:', error);
                showToastRecording(' Save failed: ' + error.message, 'error', '');
            }
        }

        // Show Voice Success Modal
        function showVoiceSuccessModal() {
            const modal = document.getElementById('voiceSuccessModal');
            if (modal) {
                modal.style.display = 'flex';
            }
        }

        // Close Voice Success Modal
        function closeVoiceSuccessModal() {
            const modal = document.getElementById('voiceSuccessModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Use Voice Recording (like selectSound)
        function useVoiceRecording() {
            const sound = soundLibraryState.selectedSound;
            if (!sound) return;

            // Show success feedback
            showToastRecording(` "${sound.title}" selected`, 'success', '');

            // Close modals
            closeVoiceSuccessModal();
            setTimeout(() => {
                closeSoundLibrary();
                displaySelectedSoundOnScreen6(sound);
            }, 600);
        }

        // ====== YOUR MUSIC MANAGEMENT ======

        // Handle Music File Upload from Device
        async function handleMusicFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!currentUser) {
                showToastRecording('Please login to upload music', 'error', '');
                return;
            }

            // Show loading state on upload button
            const uploadBtn = document.querySelector('button[onclick*="uploadMusicInput"]');
            if (uploadBtn) {
                uploadBtn.disabled = true;
                uploadBtn.style.opacity = '0.7';
                uploadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Uploading...';
            }

            try {
                showToastRecording(' Uploading music...', 'info', '');

                // Upload to Cloudinary
                const formData = new FormData();
                formData.append('file', file);
                formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
                formData.append('folder', 'user_music');

                const response = await fetch(CLOUDINARY_API_URL, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                // Save to Firestore
                const musicData = {
                    title: file.name.replace(/\.[^/.]+$/, ''), // Remove file extension
                    artist: 'You',
                    audioUrl: data.secure_url,
                    duration: '0:00', // Will be set on first play
                    uploadedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    category: 'User Upload',
                    isTrimable: true,
                    trimStart: 0,
                    trimEnd: null,
                    id: `music_${Date.now()}`
                };

                await db.collection('users').doc(currentUser.uid).collection('uploadedMusic').add(musicData);

                showToastRecording(' Music uploaded successfully!', 'success', '');
                console.log(' Music uploaded to your library');

                // Reload your music tab
                await loadYourMusic();

                // Reset input and button
                document.getElementById('uploadMusicInput').value = '';
                if (uploadBtn) {
                    uploadBtn.disabled = false;
                    uploadBtn.style.opacity = '1';
                    uploadBtn.innerHTML = '<i class="fas fa-upload"></i> Add Music from Device';
                }

            } catch (error) {
                console.error('Upload error:', error);
                showToastRecording(' Upload failed: ' + error.message, 'error', '');
                // Reset button on error
                if (uploadBtn) {
                    uploadBtn.disabled = false;
                    uploadBtn.style.opacity = '1';
                    uploadBtn.innerHTML = '<i class="fas fa-upload"></i> Add Music from Device';
                }
            }
        }

        // Delete Your Music Track
        async function deleteYourMusic(soundId) {

            if (!confirm('Are you sure you want to delete this track?')) {
                return;
            }

            if (!currentUser) {
                showToastRecording('Please login', 'error', '');
                return;
            }

            // Show loading state on button
            const deleteBtn = document.querySelector(`[data-sound-id="${soundId}"].sound-delete-btn`);
            if (deleteBtn) {
                deleteBtn.disabled = true;
                deleteBtn.style.opacity = '0.7';
                deleteBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Deleting...';
            }

            try {
                showToastRecording(' Deleting...', 'info', '');

                // Delete from Firestore
                await db.collection('users').doc(currentUser.uid).collection('uploadedMusic').doc(soundId).delete();

                showToastRecording(' Track deleted', 'success', '');
                console.log('Deleted track:', soundId);

                // Reload your music
                await loadYourMusic();

            } catch (error) {
                console.error('Delete error:', error);
                showToastRecording(' Delete failed: ' + error.message, 'error', '');
                // Reset button
                if (deleteBtn) {
                    deleteBtn.disabled = false;
                    deleteBtn.style.opacity = '1';
                    deleteBtn.innerHTML = '<i class="fas fa-trash"></i> Delete';
                }
            }
        }

        // ============================================================================
        // AUTO-CLOSE CAMERA ON PAGE NAVIGATION
        // ============================================================================

        // Close camera when user navigates away
        window.addEventListener('beforeunload', () => {
            if (recordingState.stream) {
                stopVideoCamera();
                console.log(' Page unloading - Video camera stopped');
            }
            if (photoState.photoStream) {
                stopPhotoMode();
                console.log(' Page unloading - Photo camera stopped');
            }
        });

        // Close camera when tab becomes hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log(' Tab hidden - Closing camera streams');
                if (recordingState.stream) {
                    stopVideoCamera();
                }
                if (photoState.photoStream) {
                    stopPhotoMode();
                }
                // Also close recording UI if open
                const overlay = document.getElementById('recordingUIOverlay');
                if (overlay && overlay.style.display !== 'none') {
                    closeRecordingUI();
                }
            }
        });

        // Close camera if page loses focus
        window.addEventListener('blur', () => {
            console.log(' Window blurred - Monitoring camera state');
            // Optional: You can add additional checks here if needed
        });

        // Cleanup on page unload
        window.addEventListener('unload', () => {
            if (recordingState.stream) {
                recordingState.stream.getTracks().forEach(track => track.stop());
            }
            if (photoState.photoStream) {
                photoState.photoStream.getTracks().forEach(track => track.stop());
            }
        });



    </script>



</body>

</html>
